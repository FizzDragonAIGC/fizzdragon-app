<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FizzDragon AIGC番劇系統</title>
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            /* FizzDragon 官网配色 */
            --bg: #14141a;
            --surface: #1a1a22;
            --surface2: #22222c;
            --border: #2d2d3a;
            --text: #f0f0f5;
            --text2: #8a8a9a;
            --accent: #E31B23;      /* FizzDragon Logo红 */
            --accent2: #E31B23;     /* 保持一致 */
            --accent-gradient: linear-gradient(135deg, #E31B23, #C41920);
            --user-bg: #1c1c24;
            --ai-bg: transparent;
        }
        
        /* 广告模式配色 - 白色浅色主题 */
        body.ad-mode {
            --accent: #6366F1 !important;
            --accent2: #8B5CF6 !important;
            --accent-gradient: linear-gradient(135deg, #6366F1, #8B5CF6) !important;
            --bg: #f5f5f7 !important;
            --surface: #ffffff !important;
            --surface2: #f0f0f2 !important;
            --border: #e0e0e5 !important;
            --text: #1a1a2e !important;
            --text2: #6b6b80 !important;
            --user-bg: #e8e8f0 !important;
            background: #f5f5f7 !important;
        }
        
        body.ad-mode .sidebar {
            background: #ffffff !important;
            border-right-color: #e0e0e5 !important;
        }
        
        body.ad-mode .sidebar-header {
            background: #fafafa !important;
            border-bottom-color: #e0e0e5 !important;
        }
        
        body.ad-mode .main-content,
        body.ad-mode .chat-area,
        body.ad-mode .assets-panel {
            background: #f5f5f7 !important;
        }
        
        body.ad-mode .chat-container {
            background: #ffffff !important;
        }
        
        body.ad-mode .message.ai {
            background: #ffffff !important;
            border: 1px solid #e0e0e5 !important;
        }
        
        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            display: flex;
            overflow: hidden;
        }
        
        /* 左侧边栏 - Kimi风格 */
        .sidebar {
            width: 280px;
            height: 100vh;
            background: #0a0a0f;
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: transform;
        }
        
        .sidebar.hidden {
            transform: translateX(-100%);
            position: absolute;
        }
        
        .sidebar-header {
            padding: 20px 16px;
            border-bottom: 1px solid var(--border);
            background: #000;
        }
        
        .sidebar-logo {
            width: 100%;
            max-width: 200px;
            height: auto;
            margin-bottom: 8px;
            display: block;
        }
        
        .sidebar-tagline {
            font-size: 11px;
            color: var(--text2);
            letter-spacing: 2px;
            margin-bottom: 12px;
            text-transform: uppercase;
        }
        
        /* 模式切换Tabs - 垂直两行 */
        .mode-tabs {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 10px;
        }
        
        .mode-tab {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text2);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s;
            min-height: 36px;
        }
        
        .mode-tab:hover {
            background: rgba(255,255,255,0.06);
            color: var(--text);
        }
        
        .mode-tab.active {
            background: rgba(227, 27, 35, 0.15);
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .mode-tab .tab-icon {
            font-size: 18px;
        }
        
        .mode-tab .tab-text {
            font-size: 14px;
            font-weight: 500;
        }
        
        .new-chat-btn {
            width: 100%;
            padding: 8px 10px;
            background: rgba(232, 48, 48, 0.1);
            border: none;
            border-radius: 6px;
            color: #E31B23;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .new-chat-btn .btn-icon {
            font-size: 12px;
        }
        
        .new-chat-btn:hover {
            background: rgba(232, 48, 48, 0.2);
            color: #E31B23;
        }
        
        .sidebar-section {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }
        
        .sidebar-section-title {
            font-size: 11px;
            color: var(--text2);
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 8px 12px;
        }
        
        .project-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .project-item {
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .project-item:hover {
            background: var(--surface);
        }
        
        .project-item.active {
            background: var(--surface2);
        }
        
        /* 项目状态指示器 - 加大版 */
        .proj-status {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
            margin-right: 8px;
        }
        .proj-status.proj-idle { background: #444; } /* 灰色 = 待处理 */
        .proj-status.proj-active { 
            background: #6366F1; 
            box-shadow: 0 0 6px #6366F1;
            animation: proj-pulse 1.5s ease-in-out infinite;
        } /* 蓝点脉冲 = 对话式处理中 */
        .proj-status.proj-complete { 
            background: #4ade80; 
            box-shadow: 0 0 4px #4ade80;
        } /* 绿色 = 完成 */
        .proj-status.proj-error { 
            background: #ef4444; 
            box-shadow: 0 0 4px #ef4444;
        } /* 红色 = 有问题 */
        .proj-status.proj-running { 
            width: 10px; height: 10px;
            border: 2px solid #6366F1; 
            border-top-color: transparent; 
            background: transparent;
            animation: proj-spin 0.6s linear infinite;
            box-shadow: 0 0 8px rgba(99,102,241,0.5);
        } /* 蓝色转圈 = Auto-Pilot */
        @keyframes proj-spin { to { transform: rotate(360deg); } }
        @keyframes proj-pulse { 0%,100% { opacity:1; transform:scale(1); } 50% { opacity:0.7; transform:scale(1.1); } }
        
        .project-item .icon {
            font-size: 16px;
        }
        
        .project-item .info {
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }
        
        .project-item .title {
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }
        
        .project-item .meta {
            font-size: 11px;
            color: var(--text2);
        }
        .project-item .meta-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px 8px;
            font-size: 10px;
            color: var(--text2);
            margin-top: 4px;
        }
        .project-item .meta-grid span {
            white-space: nowrap;
        }
        .project-item .meta-step {
            font-size: 10px;
            color: var(--accent);
            margin-top: 3px;
        }
        
        .project-item .action-btn {
            opacity: 0;
            padding: 4px 8px;
            background: rgba(227, 27, 35, 0.2);
            border: none;
            border-radius: 4px;
            color: #E31B23;
            cursor: pointer;
            font-size: 12px;
            transition: opacity 0.2s;
            margin-left: 4px;
        }
        
        .project-item:hover .action-btn {
            opacity: 1;
        }
        
        .project-item .action-btn:hover {
            background: rgba(227, 27, 35, 0.4);
        }
        
        .project-item .actions {
            display: flex;
            gap: 2px;
        }
        
        .project-item[draggable="true"] {
            cursor: grab;
        }
        
        .project-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .project-item.drag-over {
            border-top: 2px solid var(--accent);
        }
        
        .sidebar-footer {
            padding: 16px;
            border-top: 1px solid var(--border);
        }
        
        .beta-badge {
            text-align: center;
            padding: 10px;
            background: rgba(227, 27, 35, 0.1);
            border-radius: 8px;
            color: #E31B23;
            font-size: 12px;
            font-weight: 500;
        }
        
        /* 主内容区 */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        
        /* 三栏布局容器 */
        .content-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        
        /* 右侧资产面板 - 更宽 */
        .assets-panel {
            width: 520px;
            background: #0a0a0f;
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-shrink: 0;
        }
        
        .assets-panel-header {
            padding: 10px 12px;
            border-bottom: 1px solid var(--border);
            background: #000;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        
        .assets-panel-header h3 {
            font-size: 13px;
            color: var(--accent);
            margin: 0;
            white-space: nowrap;
        }
        
        .assets-header-actions {
            display: flex;
            gap: 6px;
        }
        
        .assets-action-btn {
            background: #1a1a1a;
            border: 1px solid #333;
            color: #999;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .assets-action-btn:hover {
            background: #252525;
            color: #fff;
            border-color: #444;
        }
        
        .assets-action-btn.primary {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 600;
        }
        
        .assets-action-btn.primary:hover {
            background: #C41920;
            transform: scale(1.02);
        }
        
        .assets-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }
        
        /* 并排布局 */
        .asset-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .asset-section {
            flex: 1;
            padding: 12px;
            background: linear-gradient(135deg, var(--surface) 0%, var(--surface2) 100%);
            border-radius: 10px;
            border: 1px solid var(--border);
            min-width: 0;
            transition: all 0.2s;
        }
        
        .asset-section:hover {
            border-color: var(--accent);
            box-shadow: 0 2px 8px rgba(227, 27, 35, 0.1);
        }
        
        .asset-section.full-width {
            flex: none;
            width: 100%;
        }
        
        .asset-section-title {
            font-size: 12px;
            color: var(--accent);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border);
        }
        
        .asset-section-content {
            font-size: 12px;
            color: var(--text);
            line-height: 1.6;
        }
        
        .asset-item {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.03);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .asset-item b {
            color: var(--text2);
            font-weight: 500;
        }
        
        .asset-item:last-child {
            border-bottom: none;
        }
        
        .asset-status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            margin-left: 4px;
        }
        
        .asset-status.done { background: rgba(56, 161, 105, 0.2); color: #38a169; }
        .asset-status.pending { background: rgba(214, 158, 46, 0.2); color: #d69e2e; }
        
        /* 画布式资产流 */
        .canvas-flow {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .canvas-empty {
            text-align: center;
            padding: 40px 20px;
            color: var(--text2);
        }
        
        .canvas-empty .empty-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }
        
        .canvas-empty .empty-text {
            font-size: 13px;
            line-height: 1.6;
        }
        
        /* 资产区块（两大分组）*/
        .assets-section {
            margin-bottom: 16px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
        }
        .assets-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            background: linear-gradient(135deg, rgba(227,27,35,0.15) 0%, rgba(227,27,35,0.05) 100%);
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            color: var(--accent);
        }
        .assets-section-header:hover {
            background: linear-gradient(135deg, rgba(227,27,35,0.2) 0%, rgba(227,27,35,0.1) 100%);
        }
        .assets-section-stats {
            font-size: 10px;
            color: var(--text2);
            font-weight: 400;
            margin-left: auto;
            margin-right: 8px;
        }
        .assets-section-body {
            padding: 8px;
        }
        
        /* FizzStudio 素材庫 */
        .fizzstudio-item {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
        }
        .fizzstudio-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: 500;
        }
        .fizzstudio-count {
            font-size: 10px;
            color: var(--text2);
            background: var(--surface2);
            padding: 2px 6px;
            border-radius: 10px;
        }
        .fizzstudio-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        .fizzstudio-btn {
            padding: 5px 10px;
            font-size: 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--surface2);
            color: var(--text);
            cursor: pointer;
            transition: all 0.2s;
        }
        .fizzstudio-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        .fizzstudio-btn.primary {
            background: linear-gradient(135deg, #6366F1, #8B5CF6);
            border: none;
            color: white;
        }
        .fizzstudio-btn.primary:hover {
            opacity: 0.9;
            transform: scale(1.02);
        }
        .fizzstudio-char-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 6px;
            margin-bottom: 8px;
        }
        .fizzstudio-char-card {
            text-align: center;
            cursor: pointer;
            padding: 4px;
            border-radius: 6px;
            transition: all 0.2s;
        }
        .fizzstudio-char-card:hover {
            background: var(--surface2);
        }
        .fizzstudio-char-img {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 50%;
            border: 2px solid var(--border);
        }
        .fizzstudio-char-placeholder {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--surface2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            margin: 0 auto;
        }
        .fizzstudio-char-name {
            font-size: 9px;
            margin-top: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .fizzstudio-char-status {
            font-size: 8px;
        }
        
        /* 资产卡片 */
        .canvas-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .canvas-card-header {
            display: flex;
            align-items: center;
            padding: 10px 14px;
            background: var(--surface2);
            border-bottom: 1px solid var(--border);
            gap: 8px;
        }
        
        .canvas-card-num {
            background: var(--accent);
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
        }
        
        .canvas-card-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text);
            flex: 1;
        }
        
        .canvas-card-status {
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 10px;
            background: rgba(56, 161, 105, 0.2);
            color: #38a169;
        }
        
        .canvas-card-body {
            padding: 12px 14px;
            font-size: 12px;
            color: var(--text2);
            line-height: 1.5;
        }
        
        .canvas-card-row {
            display: flex;
            margin: 4px 0;
        }
        
        .canvas-card-label {
            color: var(--text2);
            min-width: 60px;
        }
        
        .canvas-card-value {
            color: var(--text);
            flex: 1;
        }
        
        /* 角色资产项 */
        .character-asset-item {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.2s;
        }
        .character-asset-item:last-child { border-bottom: none; }
        .character-asset-item:hover { background: rgba(227,27,35,0.05); }
        .character-asset-header {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
        }
        .character-asset-name { color: var(--text); }
        .character-asset-role { color: var(--text2); font-size: 11px; }
        .character-asset-toggle { margin-left: auto; color: var(--text2); font-size: 10px; transition: transform 0.2s; }
        .character-asset-detail {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px dashed var(--border);
        }
        .char-section { margin-bottom: 8px; }
        .char-section:last-child { margin-bottom: 0; }
        .char-section-title {
            font-size: 10px;
            color: var(--accent);
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .char-section-content {
            font-size: 11px;
            color: var(--text);
            line-height: 1.5;
            white-space: pre-wrap;
        }
        .char-prompt {
            background: #1a1a1a;
            padding: 6px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 10px;
            user-select: all;
        }
        .copy-btn {
            background: #333;
            border: none;
            color: #aaa;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            cursor: pointer;
            margin-left: auto;
        }
        .copy-btn:hover { background: var(--accent); color: white; }
        
        /* 故事源卡片 */
        .story-card { border-left: 3px solid #E31B23 !important; }
        .story-info { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .story-title { font-size: 13px; }
        .story-meta { font-size: 11px; color: var(--text2); }
        .story-preview { font-size: 11px; color: #888; line-height: 1.5; max-height: 60px; overflow: hidden; margin-bottom: 8px; }
        .story-actions { display: flex; gap: 8px; }
        .story-btn { flex: 1; padding: 6px; background: rgba(227,27,35,0.1); border: 1px solid var(--border); border-radius: 4px; color: var(--accent); font-size: 11px; cursor: pointer; }
        .story-btn:hover { background: var(--accent); color: white; }
        
        /* 故事模态框 */
        .story-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 1000; display: flex; align-items: center; justify-content: center; }
        .story-modal-content { background: var(--surface); border-radius: 12px; width: 90%; max-width: 800px; max-height: 80vh; display: flex; flex-direction: column; }
        .story-edit-content { max-width: 900px; height: 80vh; }
        .story-modal-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
        .story-modal-header h3 { margin: 0; font-size: 16px; }
        .story-modal-close { background: none; border: none; color: #888; font-size: 20px; cursor: pointer; }
        .story-modal-close:hover { color: white; }
        .story-modal-body { flex: 1; padding: 20px; overflow-y: auto; }
        .story-full-text { white-space: pre-wrap; font-size: 14px; line-height: 1.8; font-family: inherit; }
        .story-modal-footer { display: flex; justify-content: space-between; align-items: center; padding: 12px 20px; border-top: 1px solid var(--border); }
        .story-modal-footer button { padding: 8px 16px; background: var(--accent); border: none; border-radius: 6px; color: white; cursor: pointer; }
        .story-title-input { width: 100%; padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 16px; margin-bottom: 12px; }
        .story-content-edit { width: 100%; height: calc(100% - 60px); padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 14px; line-height: 1.8; resize: none; font-family: inherit; }
        .story-save-btn { background: var(--accent) !important; }
        
        /* 角色编辑按钮 */
        .char-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--border);
        }
        .char-edit-btn, .char-delete-btn, .char-gen-btn {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .char-gen-btn {
            background: linear-gradient(135deg, rgba(99,102,241,0.2), rgba(139,92,246,0.2));
            color: #8B5CF6;
            border-color: #6366F1;
        }
        .char-gen-btn:hover {
            background: linear-gradient(135deg, #6366F1, #8B5CF6);
            color: white;
        }
        .char-edit-btn {
            background: rgba(227, 27, 35, 0.1);
            color: var(--accent);
        }
        .char-edit-btn:hover {
            background: var(--accent);
            color: white;
        }
        .char-delete-btn {
            background: transparent;
            color: #888;
        }
        .char-delete-btn:hover {
            background: #ff4444;
            color: white;
            border-color: #ff4444;
        }
        .char-image-container {
            margin-bottom: 8px;
            border-radius: 6px;
            overflow: hidden;
        }
        .char-image {
            width: 100%;
            height: auto;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .char-image:hover {
            transform: scale(1.02);
        }
        
        /* 章节盒子 */
        .chapter-box {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .chapter-box-header {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: var(--surface2);
            border-bottom: 1px solid var(--border);
            font-size: 12px;
            font-weight: 600;
        }
        
        .chapter-box-content {
            display: flex;
        }
        
        .chapter-box-left {
            flex: 1;
            padding: 10px 12px;
            border-right: 1px solid var(--border);
            font-size: 11px;
        }
        
        .chapter-box-right {
            flex: 1;
            padding: 10px 12px;
            font-size: 11px;
        }
        
        .chapter-box-label {
            font-size: 10px;
            color: var(--text2);
            margin-bottom: 4px;
        }
        
        .chapter-box-footer {
            display: flex;
            justify-content: flex-end;
            padding: 8px 12px;
            border-top: 1px solid var(--border);
            background: var(--surface2);
        }
        
        .chapter-box-btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
        }
        
        .chapter-box-btn:hover {
            background: #C41920;
        }
        
        /* 章节内容展开面板 */
        .chapter-content-panel {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: #0d0d0d;
        }
        
        .chapter-content-panel.expanded {
            max-height: 400px;
        }
        
        .chapter-content-scroll {
            max-height: 350px;
            overflow-y: auto;
            padding: 12px;
            font-size: 12px;
            line-height: 1.6;
            color: #ccc;
            white-space: pre-wrap;
        }
        
        .chapter-content-scroll::-webkit-scrollbar {
            width: 4px;
        }
        
        .chapter-content-scroll::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 2px;
        }
        
        .chapter-content-edit {
            width: 100%;
            min-height: 200px;
            max-height: 350px;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #ccc;
            padding: 10px;
            font-size: 12px;
            line-height: 1.6;
            resize: vertical;
            border-radius: 4px;
        }
        
        .chapter-tab-btn {
            background: transparent;
            border: none;
            color: var(--text2);
            padding: 6px 10px;
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .chapter-tab-btn:hover {
            background: #252525;
            color: #fff;
        }
        
        .chapter-tab-btn.active {
            background: var(--accent);
            color: white;
        }
        
        /* 手机端隐藏右侧面板 */
        @media (max-width: 1024px) {
            .assets-panel {
                display: none;
            }
        }
        
        @media (max-width: 1200px) {
            .assets-panel {
                width: 350px;
            }
        }
        
        .menu-toggle {
            background: var(--surface);
            border: none;
            border-radius: 8px;
            color: var(--text);
            font-size: 22px;
            cursor: pointer;
            padding: 8px 12px;
            display: none;
            transition: background 0.2s;
        }
        .menu-toggle:hover, .menu-toggle:active {
            background: var(--surface2);
        }
        
        .header-title {
            font-size: 14px;
            color: var(--text2);
        }
        
        /* 智能体进度条 */
        .agent-progress-bar {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: 12px;
            padding: 4px 8px;
            background: var(--surface);
            border-radius: 20px;
            border: 1px solid var(--border);
        }
        .ap-dot {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.4;
            filter: grayscale(1);
        }
        .ap-dot:hover {
            transform: scale(1.2);
            opacity: 1;
            filter: grayscale(0);
        }
        .ap-dot.done {
            opacity: 1;
            filter: grayscale(0);
            background: rgba(74, 222, 128, 0.2);
        }
        .ap-dot.running {
            opacity: 1;
            filter: grayscale(0);
            animation: ap-pulse 1s infinite;
        }
        @keyframes ap-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }
        
        /* 768px 媒体查询移至底部统一管理 */
        
        /* 顶部栏 - FizzDragon风格 */
        .header {
            padding: 16px 24px;
            background: var(--bg);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .header img {
            height: 24px;
            filter: brightness(1.1);
        }
        
        .logo {
            font-size: 14px;
            font-weight: 500;
            color: var(--text2);
            letter-spacing: 0.5px;
        }
        
        .status {
            margin-left: auto;
            font-size: 12px;
            color: var(--text2);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #22c55e;
        }
        
        .status-dot.offline { background: #ef4444; }
        .status-dot.loading { background: #E31B23; animation: pulse 1s infinite; }
        
        /* Auto-Pilot 开关 */
        .auto-pilot-toggle {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 12px;
            border: 1px solid #333;
            background: #1a1a22;
            color: #666;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: 8px;
        }
        .auto-pilot-toggle:hover {
            border-color: #E31B23;
            color: #ccc;
        }
        .auto-pilot-toggle.active {
            background: linear-gradient(135deg, #E31B23, #C41920);
            border-color: #E31B23;
            color: white;
            box-shadow: 0 0 10px rgba(227, 27, 35, 0.4);
        }
        .auto-pilot-toggle.active:hover {
            background: linear-gradient(135deg, #ff3b42, #E31B23);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-10px); }
            20% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-10px); }
        }
        
        /* 语言选择器 */
        .lang-select {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 12px;
        }
        
        .lang-select:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .user-menu {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 0 10px;
            color: #888;
            font-size: 12px;
        }
        
        .user-menu button:hover {
            color: #E31B23 !important;
        }
        
        /* 拖放文件覆盖层 */
        .drop-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(99, 102, 241, 0.15);
            border: 3px dashed #6366F1;
            border-radius: 12px;
            z-index: 100;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            pointer-events: none;
        }
        .drop-overlay.active { display: flex; }
        .drop-icon { font-size: 48px; animation: drop-bounce 0.5s ease infinite alternate; }
        .drop-text { font-size: 16px; font-weight: 600; color: #6366F1; }
        .drop-hint { font-size: 12px; color: var(--text2); }
        @keyframes drop-bounce { from { transform: translateY(0); } to { transform: translateY(-8px); } }
        .chat-area { position: relative; }
        
        /* 聊天区域 */
        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        /* 滚动条样式 - 深黑灰色 */
        .chat-container::-webkit-scrollbar {
            width: 5px;
        }
        .chat-container::-webkit-scrollbar-track {
            background: #0d0d0d;
        }
        .chat-container::-webkit-scrollbar-thumb {
            background: #2a2a2a;
            border-radius: 3px;
        }
        .chat-container::-webkit-scrollbar-thumb:hover {
            background: #3a3a3a;
        }
        
        /* 全局滚动条样式 */
        *::-webkit-scrollbar {
            width: 5px;
            height: 5px;
        }
        *::-webkit-scrollbar-track {
            background: #0d0d0d;
        }
        *::-webkit-scrollbar-thumb {
            background: #2a2a2a;
            border-radius: 3px;
        }
        *::-webkit-scrollbar-thumb:hover {
            background: #3a3a3a;
        }
        
        .message {
            max-width: 95%;
            padding: 6px 10px;
            line-height: 1.4;
            font-size: 14px;
            border-radius: 8px;
            margin-bottom: 4px;
        }
        
        /* 包含可编辑框的消息全宽 */
        .message:has(.editable-result) {
            max-width: 95%;
            width: 95%;
        }
        
        .message.user {
            background: rgba(227, 27, 35, 0.15);
            border: 1px solid rgba(227, 27, 35, 0.3);
            margin-left: auto;  /* 靠右 */
            border-radius: 10px 10px 4px 10px;
        }
        
        .message.ai {
            background: var(--surface);
            border: 1px solid var(--border);
            margin-right: auto;  /* 靠左 */
            border-radius: 10px 10px 10px 4px;
        }
        
        .message .role {
            font-size: 11px;
            color: var(--text2);
            margin-bottom: 2px;
            font-weight: 600;
        }
        
        .message.user .role { color: var(--accent); }
        .message.ai .role { color: #888; }
        
        /* 可编辑确认框 - 紧凑布局 */
        .editable-result {
            background: #0d0d0d;
            border: 2px solid #E31B23;
            border-radius: 6px;
            padding: 10px 12px;
            margin: 6px 0;
            width: 100%;
            max-width: 100%;
            box-shadow: 0 4px 20px rgba(227, 27, 35, 0.15);
        }
        
        .editable-result .result-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
            padding-bottom: 4px;
            border-bottom: 1px solid #333;
        }
        
        .editable-result .result-number {
            background: var(--accent);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            flex-shrink: 0;
        }
        
        .editable-result .result-title {
            font-size: 14px;
            font-weight: 600;
            color: #e0e0e0;
        }
        
        .editable-result .result-tag {
            background: rgba(227, 27, 35, 0.2);
            color: var(--accent);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            margin-left: auto;
        }
        
        .editable-result textarea {
            width: 100%;
            min-height: 200px;
            max-height: 70vh;
            background: #1a1a1a;
            border: 1px solid #404040;
            border-radius: 6px;
            color: #e0e0e0;
            padding: 12px 15px;
            font-size: 13px;
            line-height: 1.7;
            resize: vertical;
            font-family: inherit;
            white-space: pre-wrap;
            overflow-y: auto;
        }
        
        .editable-result textarea:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(227, 27, 35, 0.2);
        }
        
        .editable-result .actions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            justify-content: flex-end;
        }
        
        .editable-result .btn-confirm {
            background: var(--accent);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .editable-result .btn-confirm:hover {
            background: #C41920;
        }
        
        .editable-result .btn-regenerate {
            background: #2a2a2a;
            color: #999;
            border: 1px solid #404040;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        
        .editable-result .btn-regenerate:hover {
            background: #333;
            border-color: #555;
            color: #ccc;
        }
        
        /* 分镜选择器 */
        .storyboard-selector {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 12px;
        }
        
        .selector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }
        
        .selector-header .total-info {
            font-size: 11px;
            color: #888;
        }
        
        .selector-actions-top {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .selector-actions-top button {
            background: #252525;
            border: 1px solid #404040;
            color: #999;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        }
        
        .selector-actions-top button:hover {
            background: #333;
            color: #fff;
        }
        
        .selector-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 12px;
        }
        
        .storyboard-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .storyboard-checkbox:hover {
            background: #252525;
        }
        
        .storyboard-checkbox input {
            accent-color: var(--accent);
        }
        
        .checkbox-label {
            flex: 1;
            font-size: 13px;
            color: #ccc;
        }
        
        .checkbox-label .shot-count {
            float: right;
            font-size: 11px;
            color: #666;
        }
        
        .selector-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        
        .selector-actions .btn-cancel {
            background: #252525;
            border: 1px solid #404040;
            color: #999;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
        }
        
        .selector-actions .btn-confirm {
            background: var(--accent);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
        }
        
        /* 结果卡片 - 紧凑大纲样式 (暗色主题) */
        .result-card {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 12px 16px;
            margin: 6px 0;
        }
        
        .result-card .card-row {
            display: flex;
            margin: 4px 0;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .result-card .card-label {
            color: #777;
            min-width: 60px;
            flex-shrink: 0;
        }
        
        .result-card .card-value {
            color: #e0e0e0;
            flex: 1;
        }
        
        .message .content { white-space: pre-wrap; }
        
        .message .content h3 {
            font-size: 14px;
            margin: 12px 0 8px;
            color: var(--accent);
        }
        
        .message .content ul {
            margin-left: 20px;
            margin-top: 8px;
        }
        
        .message .content li { margin: 4px 0; }
        
        /* 快捷回复 - FizzDragon风格 */
        .quick-replies {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 10px;
            max-width: 100%;
        }
        
        .quick-reply {
            padding: 6px 12px;
            background: rgba(232, 48, 48, 0.08);
            border: none;
            border-radius: 14px;
            color: #E31B23;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s ease;
            max-width: 100%;
            word-break: break-word;
            line-height: 1.3;
        }
        
        .quick-reply:hover, .quick-reply:active {
            background: rgba(232, 48, 48, 0.18);
            color: #E31B23;
        }
        
        .quick-reply:active {
            transform: scale(0.97);
        }
        
        /* 移动端快捷回复 - 全宽垂直排列 */
        @media (max-width: 600px) {
            .message {
                max-width: 100% !important;
                overflow: hidden;
            }
            .message .content {
                overflow: hidden;
                word-wrap: break-word;
            }
            .quick-replies {
                display: flex !important;
                flex-direction: column !important;
                gap: 8px;
                width: 100%;
            }
            .quick-reply {
                width: 100% !important;
                max-width: 100% !important;
                text-align: center;
                padding: 14px 16px;
                font-size: 14px;
                box-sizing: border-box;
            }
        }
        
        /* 输入区域 */
        .input-area {
            padding: 16px 20px;
            background: var(--bg);
            border-top: none;
        }
        
        .input-row {
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }
        
        .input-wrapper {
            flex: 1;
            position: relative;
        }
        
        #userInput {
            width: 100%;
            padding: 14px 16px;
            padding-right: 100px;
            background: #1a1a1a;
            border: none;
            border-radius: 8px;
            color: var(--text);
            font-size: 14px;
            resize: none;
            min-height: 48px;
            max-height: 150px;
            font-family: inherit;
        }
        
        #userInput:focus {
            outline: none;
            box-shadow: 0 0 0 1px #E31B23;
        }
        
        .input-actions {
            position: absolute;
            right: 8px;
            bottom: 8px;
            display: flex;
            gap: 8px;
        }
        
        .btn {
            padding: 6px 12px;
            border-radius: 6px;
            border: none;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .btn-primary {
            background: var(--accent-gradient);
            color: white;
            border: none;
            padding: 8px 14px;
            font-size: 13px;
        }
        
        .btn-primary:hover { 
            opacity: 0.9;
            transform: translateY(-1px);
        }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn-upload {
            background: #252525;
            color: var(--text2);
            border: 1px solid #333;
            padding: 8px 12px;
            font-size: 16px;
            border-radius: 8px;
        }
        
        .btn-upload:hover { 
            color: var(--accent); 
            border-color: var(--accent);
            background: #1a1a1a;
        }
        
        #fileInput { display: none; }
        
        /* 打字动画 */
        .typing {
            display: flex;
            gap: 4px;
            padding: 8px 0;
        }
        
        .typing span {
            width: 6px;
            height: 6px;
            background: #E31B23;
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }
        
        .typing span:nth-child(2) { animation-delay: 0.2s; }
        .typing span:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-8px); }
        }
        
        /* 进度卡片 */
        .progress-card {
            background: transparent;
            border: none;
            border-left: 2px solid #E31B23;
            border-radius: 0;
            padding: 8px 12px;
            margin-top: 8px;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
            color: #E31B23;
        }
        
        .progress-bar {
            height: 3px;
            background: #2d2d3a;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: #E31B23;
            transition: width 0.3s;
        }
        
        /* 结果卡片 */
        .result-card {
            background: transparent;
            border: none;
            border-left: 2px solid #333;
            border-radius: 0;
            overflow: hidden;
            margin-top: 12px;
            padding-left: 16px;
        }
        
        .result-header {
            padding: 8px 0;
            background: transparent;
            border-bottom: none;
            font-size: 13px;
            font-weight: 600;
            color: var(--text2);
        }
        
        .result-content {
            padding: 8px 0;
            font-size: 13px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        /* 用户助手浮动按钮 */
        .fizzdragon-fab {
            position: fixed;
            bottom: 100px;
            right: 24px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--accent);
            color: white;
            border: none;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(227, 27, 35, 0.4);
            transition: all 0.2s;
            z-index: 1000;
        }
        
        .fizzdragon-fab:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(227, 27, 35, 0.5);
        }
        
        .help-fab {
            position: fixed;
            bottom: 30px;
            right: 24px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, #E31B23, #B51820);
            border: none;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(232, 48, 48, 0.4);
            transition: all 0.3s;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .help-fab:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 30px rgba(232, 48, 48, 0.6);
        }
        
        .help-fab:active {
            transform: scale(0.95);
        }
        
        .help-fab.loading {
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* ==================== 移动端适配（Apple HIG标准）==================== */
        
        /* 底部导航栏 - 默认隐藏 */
        .bottom-toolbar {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: #0a0a0f;
            border-top: 1px solid var(--border);
            padding: 6px 4px;
            padding-bottom: calc(6px + env(safe-area-inset-bottom, 0px));
            z-index: 100;
            justify-content: space-around;
            align-items: center;
        }
        
        .toolbar-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            min-width: 64px;
            min-height: 48px;
            padding: 6px 8px;
            background: transparent;
            border: none;
            color: var(--text2);
            font-size: 11px;
            cursor: pointer;
            border-radius: 8px;
        }
        
        .toolbar-btn:active {
            background: rgba(227, 27, 35, 0.2);
        }
        
        .toolbar-btn.active {
            color: var(--accent);
        }
        
        .toolbar-btn .icon {
            font-size: 24px;
            line-height: 1;
        }

        /* ===== 手机端适配 (<=768px) ===== */
        @media (max-width: 768px) {
            /* 隐藏桌面端元素 */
            .fizzdragon-fab,
            .help-fab,
            .menu-toggle.mobile-assets-btn,
            .status,
            .lang-select {
                display: none !important;
            }
            
            /* 显示底部导航 */
            .bottom-toolbar {
                display: flex;
            }
            
            /* 🔧 修复滚动问题 - 简单粗暴方案 */
            html, body {
                height: 100%;
                overflow: hidden;
                position: fixed;
                width: 100%;
            }
            .main-content {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                display: flex;
                flex-direction: column;
            }
            .content-wrapper {
                flex: 1;
                position: relative;
                overflow: hidden;
            }
            .chat-area {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                display: flex;
                flex-direction: column;
            }
            .chat-container {
                flex: 1;
                overflow-y: scroll !important;
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
                padding: 12px;
                padding-bottom: 160px;
            }
            
            /* 头部 - 44px最小触控 */
            .header {
                padding: 8px 12px;
                min-height: 50px;
                flex-shrink: 0;
            }
            .header-title {
                font-size: 16px;
                text-align: center;
                flex: 1;
            }
            .menu-toggle {
                display: flex !important;
                min-width: 44px;
                min-height: 44px;
                font-size: 20px;
                align-items: center;
                justify-content: center;
            }
            
            /* 左侧边栏 */
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                width: 300px;
                max-width: 85vw;
                z-index: 1001;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }
            .sidebar.show {
                transform: translateX(0);
            }
            
            /* 侧边栏内按钮 - 44px最小 */
            .new-chat-btn {
                min-height: 48px;
                font-size: 15px;
            }
            .mode-tab {
                min-height: 44px;
                padding: 10px;
            }
            .project-item {
                min-height: 48px;
                padding: 12px;
            }
            
            /* 右侧资产面板 */
            .assets-panel {
                position: fixed !important;
                right: 0;
                top: 0;
                bottom: 0;
                width: 320px !important;
                max-width: 90vw !important;
                z-index: 1001;
                transform: translateX(100%);
                transition: transform 0.3s ease;
                display: flex !important;
            }
            .assets-panel.show {
                transform: translateX(0);
            }
            
            /* 资产面板内按钮 */
            .assets-action-btn {
                min-height: 44px;
                padding: 12px;
                font-size: 13px;
            }
            
            /* 遮罩层 */
            .sidebar-overlay,
            .assets-overlay {
                position: fixed;
                inset: 0;
                background: rgba(0,0,0,0.5);
                z-index: 1000;
                opacity: 0;
                visibility: hidden;
                transition: all 0.3s;
            }
            .sidebar-overlay.show,
            .assets-overlay.show {
                opacity: 1;
                visibility: visible;
            }
            
            /* 聊天区域 */
            .chat-container {
                padding: 12px;
                padding-bottom: 140px;
            }
            
            /* 消息气泡 */
            .message {
                max-width: 90%;
                padding: 14px;
                border-radius: 16px;
                font-size: 15px;
                line-height: 1.6;
                word-wrap: break-word;
                overflow-wrap: break-word;
            }
            .message.ai {
                background: var(--surface);
                border: 1px solid var(--border);
                margin-right: auto;
            }
            .message.user {
                background: rgba(227, 27, 35, 0.15);
                border: 1px solid rgba(227, 27, 35, 0.3);
                margin-left: auto;
                margin-right: 0;
                max-width: 80%;
            }
            
            /* 快捷回复 - 44px最小触控 */
            .quick-replies {
                display: flex;
                flex-direction: column;
                gap: 10px;
                margin-top: 14px;
            }
            .quick-reply {
                width: 100%;
                min-height: 48px;
                padding: 14px 18px;
                text-align: center;
                border-radius: 24px;
                font-size: 15px;
                background: var(--surface);
                border: 1px solid var(--border);
                color: var(--text);
            }
            .quick-reply:active {
                background: rgba(227, 27, 35, 0.15);
                border-color: var(--accent);
                color: var(--accent);
            }
            
            /* 输入区域 */
            .input-area {
                position: fixed;
                left: 0;
                right: 0;
                bottom: 60px;
                padding: 8px 12px;
                padding-bottom: calc(8px + env(safe-area-inset-bottom, 0px));
                background: var(--bg);
                border-top: 1px solid var(--border);
                z-index: 150;  /* 🔧 提高z-index确保按钮可点击 */
            }
            
            .input-wrapper {
                position: relative;
            }
            
            #userInput {
                width: 100%;
                min-height: 44px;
                padding: 12px 90px 12px 16px;
                border-radius: 22px;
                font-size: 16px;
                background: var(--surface);
                border: 1px solid var(--border);
            }
            
            .input-actions {
                position: absolute;
                right: 6px;
                top: 50%;
                transform: translateY(-50%);
                display: flex;
                gap: 6px;
                z-index: 100;  /* 🔧 确保按钮在最上层 */
            }
            
            /* 输入按钮 - 44px触控 */
            .btn-upload,
            .btn-primary {
                min-width: 44px;  /* 🔧 增加到Apple HIG标准44px */
                min-height: 44px;
                padding: 0;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 18px;
                position: relative;
                z-index: 101;  /* 🔧 确保按钮可点击 */
            }
        }
        
        /* ===== 小屏手机 (<=375px) ===== */
        @media (max-width: 375px) {
            .sidebar {
                width: 100vw;
                max-width: none;
            }
            .header-title {
                font-size: 14px;
            }
            /* 底部导航只显示图标 */
            .toolbar-btn span:not(.icon) {
                display: none;
            }
            .toolbar-btn {
                min-width: 50px;
            }
        }
        
        /* ===== 中等手机 (376-428px) ===== */
        @media (min-width: 376px) and (max-width: 428px) {
            .header-title {
                font-size: 15px;
            }
        }
        
        /* iOS安全区域（刘海屏） */
        @supports (padding: env(safe-area-inset-bottom)) {
            .bottom-toolbar {
                padding-bottom: calc(6px + env(safe-area-inset-bottom));
                height: calc(60px + env(safe-area-inset-bottom));
            }
            @media (max-width: 768px) {
                .input-area {
                    bottom: calc(60px + env(safe-area-inset-bottom));
                }
                .chat-container {
                    padding-bottom: calc(140px + env(safe-area-inset-bottom));
                }
            }
        }
        
        /* 流式输出实时预览 */
        .stream-preview {
            background: rgba(227, 27, 35, 0.1) !important;
            border-left: 3px solid var(--accent);
        }
        .stream-content {
            font-size: 12px;
            line-height: 1.6;
            color: #bbb;
            max-height: 300px;
            overflow-y: auto;
        }
        .typing-cursor {
            animation: blink 0.8s infinite;
            color: var(--accent);
            font-weight: bold;
        }
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
    </style>
</head>
<body>
    <!-- 侧边栏遮罩（手机端点击关闭） -->
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="toggleSidebar()"></div>
    
    <!-- 资产面板遮罩（手机端点击关闭） -->
    <div class="assets-overlay" id="assetsOverlay" onclick="toggleAssetsPanel()"></div>
    
    <!-- 左侧边栏 -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <img src="logo.jpg" alt="FizzDragon" class="sidebar-logo">
            <div class="sidebar-tagline" id="sidebarTagline">創造好故事</div>
            
            <!-- 模式Tabs -->
            <div class="mode-tabs">
                <button class="mode-tab active" data-mode="drama" onclick="switchAppMode('drama')">
                    <span class="tab-icon">🎬</span>
                    <span class="tab-text">AI影視項目</span>
                </button>
                <button class="mode-tab" data-mode="ad" onclick="switchAppMode('ad')">
                    <span class="tab-icon">📺</span>
                    <span class="tab-text">AI廣告分鏡</span>
                </button>
            </div>
            
            <button class="new-chat-btn" id="newProjectBtn" onclick="startNewProject()">
                <span class="btn-icon">✨</span> <span id="newBtnText">新建影視項目</span>
            </button>
        </div>
        
        <div class="sidebar-section">
            <div class="sidebar-section-title" id="projectListTitle">我的影視項目</div>
            <div class="project-list" id="projectList">
                <!-- 项目列表动态生成 -->
            </div>
        </div>
        
        <div class="sidebar-footer">
            <div class="beta-badge">✨ 讓每個人都能創作影視</div>
        </div>
    </div>
    
    <!-- 主内容区 -->
    <div class="main-content">
        <div class="header">
            <button class="menu-toggle" onclick="toggleSidebar()">☰</button>
            <div class="header-title" id="headerTitle">FizzDragon AIGC番劇系統</div>
            <div class="agent-progress-bar" id="agentProgressBar" style="display:none;">
                <span class="ap-dot" id="apDot1" title="概念" onclick="triggerAgentWithCheck('concept')">💡</span>
                <span class="ap-dot" id="apDot2" title="人物" onclick="triggerAgentWithCheck('character')">👤</span>
                <span class="ap-dot" id="apDot3" title="章節" onclick="triggerAgentWithCheck('chapters')">📝</span>
                <span class="ap-dot" id="apDot4" title="編劇" onclick="triggerAgentWithCheck('script')">✍️</span>
                <span class="ap-dot" id="apDot5" title="分鏡" onclick="triggerAgentWithCheck('storyboard')">🎬</span>
            </div>
            <div class="status">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">連接中...</span>
            </div>
            <button class="auto-pilot-toggle" id="autoPilotToggle" onclick="toggleAutoPilotMode()" title="Auto-Pilot 模式">
                🚀 <span id="autoPilotLabel">OFF</span>
            </button>
            <select class="lang-select" id="langSelect" onchange="changeLanguage(this.value)">
                <option value="en">English</option>
                <option value="zh-CN">简体中文</option>
                <option value="zh-TW">繁體中文</option>
            </select>
            <div class="user-menu" id="userMenu">
                <span id="currentUsername">👤</span>
                <button onclick="handleLogout()" title="登出" style="background:none;border:none;color:#888;cursor:pointer;padding:5px;">🚪</button>
            </div>
            <button class="menu-toggle mobile-assets-btn" onclick="toggleAssetsPanel()" style="margin-left:auto;">📦 <span class="mobile-only">資產</span></button>
        </div>
        
        <div class="content-wrapper">
            <!-- 中间对话区 -->
            <div class="chat-area" id="chatArea" ondragover="handleChatDragOver(event)" ondragleave="handleChatDragLeave(event)" ondrop="handleChatDrop(event)">
                <div class="drop-overlay" id="dropOverlay">
                    <div class="drop-icon">📄</div>
                    <div class="drop-text">拖放文件到這裡導入</div>
                    <div class="drop-hint">.txt .docx .pdf</div>
                </div>
                <div class="chat-container" id="chatContainer">
                    <!-- 消息会动态添加到这里 -->
                </div>
            
                <div class="input-area">
            <div class="input-row">
                <div class="input-wrapper">
                    <textarea id="userInput" placeholder="輸入消息..." rows="1"></textarea>
                    <div class="input-actions">
                        <input type="file" id="fileInput" accept=".txt,.docx,.pdf">
                        <button class="btn btn-upload" onclick="document.getElementById('fileInput').click()">📄</button>
                        <button class="btn btn-primary" id="sendBtn" onclick="sendMessage()">➤</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Kimi风格底部工具栏 (仅移动端显示) -->
        <div class="bottom-toolbar" id="bottomToolbar">
            <button class="toolbar-btn" onclick="toggleSidebar()" id="toolbarProjects">
                <span class="icon">📁</span>
                <span>項目</span>
            </button>
            <button class="toolbar-btn" onclick="document.getElementById('fileInput').click()">
                <span class="icon">📄</span>
                <span>導入</span>
            </button>
            <button class="toolbar-btn active" onclick="startNewProject()">
                <span class="icon">✨</span>
                <span>新建</span>
            </button>
            <button class="toolbar-btn" onclick="toggleAssetsPanel()">
                <span class="icon">📦</span>
                <span>資產</span>
            </button>
            <button class="toolbar-btn" onclick="showMobileExportMenu()">
                <span class="icon">📤</span>
                <span>導出</span>
            </button>
        </div>
            </div><!-- 关闭 chat-area -->
            
            <!-- 右侧项目资产面板 -->
            <div class="assets-panel" id="assetsPanel">
                <div class="assets-panel-header">
                    <h3>📦 項目資產</h3>
                    <div class="assets-header-actions">
                        <button class="assets-action-btn" onclick="exportStoryboards()" title="導出分鏡表Excel">📊 導出Excel</button>
                        <button class="assets-action-btn primary" onclick="importToFizzDragon()" title="導入FizzStudio製作">🚀 導入FizzStudio</button>
                    </div>
                </div>
                <div class="assets-panel-content" id="assetsPanelContent">
                    <!-- 画布式动态内容 -->
                    <div class="canvas-flow" id="canvasFlow">
                        <div class="canvas-empty">
                            <div class="empty-icon">📦</div>
                            <div class="empty-text" data-i18n-title="emptyAssetsTitle" data-i18n-desc="emptyAssetsDesc">導入小說後<br>資產會在這裡展示</div>
                        </div>
                    </div>
                </div>
            </div>
        </div><!-- 关闭 content-wrapper -->
    </div><!-- 关闭 main-content -->

    <!-- FizzDragon导入浮动按钮 -->
    <button class="fizzdragon-fab" onclick="importToFizzDragon()" title="導入 FizzDragon">
        🚀
    </button>

    <!-- 用户助手浮动按钮 -->
    <button class="help-fab" onclick="callHelpAgent()" title="遇到問題？點我求助">
        🆘
    </button>

    <script src="https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    
    <script>
// ==================== 配置 ====================
// 后端API地址 - 优先使用隧道（GitHub Pages需要HTTPS）
const TUNNEL_URL = 'https://fizzdragon-backend.onrender.com';
const API_ENDPOINTS = [
    '/api',  // 同源部署
    TUNNEL_URL + '/api',  // Cloudflare隧道
    'http://localhost:3001/api'  // 本地开发
];
// 自动选择：如果是GitHub Pages，使用隧道；否则用相对路径
let API_BASE = window.location.hostname.includes('github.io') ? TUNNEL_URL + '/api' : '/api';

// ==================== Agent人格系统 ====================
const AGENT_PERSONAS = {
    concept: {
        name: '概念分析師',
        avatar: '🦉',  // 猫头鹰 - 智慧
        personality: '愛思考的老貓頭鷹',
        phrases: {
            start: '嗚～讓我仔細讀讀這個故事...',
            working: '「正在打開故事分析引擎，提取核心衝突...」',
            step1: '「我正在調用《故事》方法論，分析類型與基調...」',
            step2: '「讓我看看這故事的靈魂是什麼...」',
            analyzing: '「這個故事的深層主題是...」',
            done: '嗚嗚！我看透了這個故事的本質！'
        }
    },
    character: {
        name: '角色設計師',
        avatar: '🐱',  // 猫咪 - 敏锐观察
        personality: '善解人心的貓咪',
        phrases: {
            start: '喵～讓我來認識每一個角色...',
            working: '「正在調用人物心理分析模組...」',
            step1: '「我正在讀取角色的背景故事...」',
            step2: '「分析人物的欲望與恐懼...」',
            step3: '「設計角色的視覺形象...」',
            analyzing: '「這個角色的內心世界很豐富呢...」',
            done: '喵！每個角色都活起來了！'
        }
    },
    narrative: {
        name: '章節規劃師',
        avatar: '🦊',  // 狐狸 - 聪明
        personality: '聰明的小狐狸',
        phrases: {
            start: '嘿嘿～讓我來安排故事節奏...',
            working: '「正在調用三幕劇結構模型...」',
            step1: '「我正在分析故事的起承轉合...」',
            step2: '「計算每集的情感節拍...」',
            step3: '「設計懸念鉤子，讓觀眾欲罷不能...」',
            analyzing: '「這裡應該放個轉折點...」',
            done: '搞定！故事結構完美！'
        }
    },
    production_design: {
        name: '服化道設計師',
        avatar: '🐰',  // 兔子 - 细致
        personality: '細心的小兔子',
        phrases: {
            start: '讓我來設計每個細節～',
            working: '「正在調用時代背景資料庫...」',
            step1: '「研究這個時代的服裝風格...」',
            step2: '「為每個角色設計專屬造型...」',
            step3: '「規劃場景的視覺氛圍...」',
            analyzing: '「這件衣服要換個顏色才對味...」',
            done: '完成！每個細節都經過精心設計！'
        }
    },
    screenwriter: {
        name: '編劇',
        avatar: '🐻',  // 熊 - 沉稳
        personality: '穩重的大棕熊',
        phrases: {
            start: '讓我來寫這個故事...',
            working: '「正在調用劇本寫作技巧庫...」',
            step1: '「回顧前面的劇情上下文...」',
            step2: '「構建這一集的場景結構...」',
            step3: '「撰寫對白和動作描述...」',
            analyzing: '「這句台詞要再打磨一下...」',
            done: '寫完了！這集很精彩！'
        }
    },
    storyboard: {
        name: '分鏡導演',
        avatar: '🐕',  // 金毛狗 - 热情
        personality: '熱情的金毛導演',
        phrases: {
            start: '汪！讓我來把劇本變成畫面！',
            working: '「正在打開 storyboard_complete skill...」',
            step1: '「調用場景分析引擎，識別轉場點...」',
            step2: '「啟動構圖設計模組，計算黃金分割...」',
            step3: '「生成運鏡方案，crane、dolly、steadicam...」',
            step4: '「輸出 Image_Prompt 和 Video_Prompt...」',
            analyzing: '「這個鏡頭用低角度會更有力量感！」',
            done: '汪汪！分鏡完成，每個鏡頭都是藝術品！'
        }
    },
    interview: {
        name: '訪談師',
        avatar: '🦜',  // 鹦鹉 - 善于交流
        personality: '愛聊天的鸚鵡',
        phrases: {
            start: '嗨！讓我來了解你的想法～',
            working: '「正在設計最能啟發創意的問題...」',
            step1: '「分析你的故事，找出關鍵問題...」',
            step2: '「準備深度訪談題目...」',
            analyzing: '「你的回答給了我新靈感！」',
            done: '太棒了！我已經完全理解你的創作意圖！'
        }
    }
};

function getAgentPhrase(agentId, phase = 'working') {
    const persona = AGENT_PERSONAS[agentId];
    if (persona?.phrases?.[phase]) {
        return `${persona.avatar} ${persona.phrases[phase]}`;
    }
    return null;
}

// ==================== 多语言系统 ====================
let currentLang = localStorage.getItem('lang') || 'zh-TW';

const i18n = {
    'zh-TW': {
        // 基础UI
        title: 'FizzDragon AIGC番劇系統',
        connecting: '連接中...',
        connected: 'FizzDragon世界觀大模型 已連接',
        newProject: '新建影視項目',
        myProjects: '我的影視項目',
        noProjects: '還沒有項目',
        beta: '✨ 讓每個人都能創作影視',
        tagline: '創造好故事',
        
        // 资产面板
        projectAssets: '📦 項目資產',
        concept: '💡 高概念',
        characters: '👤 角色',
        chapters: '📝 章節',
        production: '👗 服化道',
        scripts: '✍️ 劇本',
        storyboards: '🎬 分鏡CSV',
        exportJson: '📥 導出JSON',
        exportCsv: '📊 導出CSV',
        notGenerated: '未生成',
        
        // 输入和按钮
        inputPlaceholder: '輸入消息...',
        importNovel: '📄 導入小說',
        aiWrite: '✍️ AI幫我寫',
        deepInterview: '🎤 深度訪談（更精準）',
        directAnalysis: '⚡ 直接分析（更快速）',
        confirm: '✅ 確認保存',
        regenerate: '🔄 重新生成',
        skip: '⏭️ 跳過',
        skipAll: '⏭️ 跳過所有訪談',
        continue: '繼續',
        help: '幫助',
        
        // 欢迎消息
        welcome: '✨ **歡迎來到 FizzDragon AIGC番劇系統**',
        welcomeDesc: '我是你的AI創作夥伴，能幫你把小說/故事轉化為專業分鏡表。',
        chooseStart: '請選擇開始方式：',
        
        // 流程提示
        conceptDone: '📖 **高概念分析完成！**',
        charactersDone: '👤 **角色分析完成！**',
        chaptersDone: '📝 **章節規劃完成！**',
        productionDone: '👗 **服化道設計完成！**',
        scriptDone: '✍️ **劇本完成！**',
        storyboardDone: '🎬 **分鏡完成！**',
        
        // 状态
        analyzing: '正在分析...',
        generating: '正在生成...',
        saving: '正在保存...',
        saved: '💾 已保存',
        
        // 项目
        episodes: '集',
        scriptsCount: '劇本',
        storyboardsCount: '分鏡',
        unnamed: '未命名',
        stepNotStarted: '待開始',
        stepConcept: '概念',
        stepCharacter: '角色',
        stepChapter: '章節',
        stepProduction: '服化道',
        stepScript: '劇本',
        stepStoryboard: '分鏡',
        rename: '重命名',
        delete: '刪除',
        
        // 错误
        errorRetry: '重試',
        errorSkip: '跳過',
        noContent: '還沒有導入小說內容',
        
        // 导出
        exportToFizzDragon: '🚀 導入 FizzDragon',
        emptyAssetsTitle: '導入小說後',
        emptyAssetsDesc: '資產會在這裡展示',
        // 创作模式
        writeMode: '✍️ **創作模式**',
        writeModeDesc: '讓我們一起創作你的故事！',
        writeModePrompt: `首先，簡單描述你的**故事靈感**：
- 可以是一句話概念
- 可以是一個場景
- 可以是一個角色

比如：「一個香港紅Van司機，凌晨載客時遇到奇怪的乘客」`,
        randomGenerate: '🎲 幫我隨機生成',
        seeExamples: '📚 看範例',
        storyExamples: '📚 **故事範例**',
        supernatural: '靈異類 🔮',
        romance: '愛情類 💕',
        mystery: '懸疑類 🔍',
        fantasy: '奇幻類 ✨',
        supernaturalEx: '「深夜食堂的老闆七叔，專門招待那些...已經不在人世的客人」',
        romanceEx: '「她每天搭同一班港鐵，暗戀車廂裡看書的男生，直到有一天發現他看的是她寫的小說」',
        mysteryEx: '「建築師發現自己設計的大樓裡，有一層不存在於圖紙上的樓層」',
        fantasyEx: '「香港最後一個風水師的孫女，意外繼承了能看見城市龍脈的能力」',
        pickOrInput: '選一個開始，或輸入你自己的想法：',
        randomIdea: '🎲 **隨機靈感**',
        likeThis: '👍 就這個！',
        tryAnother: '🎲 換一個',
        editIt: '✏️ 我來改'
    },
    'zh-CN': {
        title: 'FizzDragon AIGC番剧系统',
        connecting: '连接中...',
        connected: '影视模型已连接',
        newProject: '+ 新建项目',
        myProjects: '我的项目',
        noProjects: '还没有项目',
        beta: '✨ 让每个人都能创作影视',
        projectAssets: '📦 项目资产',
        concept: '💡 高概念',
        characters: '👤 角色',
        chapters: '📝 章节',
        production: '👗 服化道',
        scripts: '✍️ 剧本',
        storyboards: '🎬 分镜CSV',
        exportJson: '📥 导出JSON',
        exportCsv: '📊 导出CSV',
        notGenerated: '未生成',
        inputPlaceholder: '输入消息...',
        importNovel: '📄 导入小说',
        aiWrite: '✍️ AI帮我写',
        deepInterview: '🎤 深度访谈（更精准）',
        directAnalysis: '⚡ 直接分析（更快速）',
        confirm: '✅ 确认保存',
        regenerate: '🔄 重新生成',
        skip: '⏭️ 跳过',
        skipAll: '⏭️ 跳过所有访谈',
        continue: '继续',
        help: '帮助',
        welcome: '✨ **欢迎来到 FizzDragon AIGC番剧系统**',
        welcomeDesc: '我是你的AI创作伙伴，能帮你把小说/故事转化为专业分镜表。',
        chooseStart: '请选择开始方式：',
        conceptDone: '📖 **高概念分析完成！**',
        charactersDone: '👤 **角色分析完成！**',
        chaptersDone: '📝 **章节规划完成！**',
        productionDone: '👗 **服化道设计完成！**',
        scriptDone: '✍️ **剧本完成！**',
        storyboardDone: '🎬 **分镜完成！**',
        analyzing: '正在分析...',
        generating: '正在生成...',
        saving: '正在保存...',
        saved: '💾 已保存',
        episodes: '集',
        scriptsCount: '剧本',
        storyboardsCount: '分镜',
        unnamed: '未命名',
        stepNotStarted: '待开始',
        stepConcept: '概念',
        stepCharacter: '角色',
        stepChapter: '章节',
        stepProduction: '服化道',
        stepScript: '剧本',
        stepStoryboard: '分镜',
        rename: '重命名',
        delete: '删除',
        errorRetry: '重试',
        errorSkip: '跳过',
        noContent: '还没有导入小说内容',
        exportToFizzDragon: '🚀 导入 FizzDragon',
        emptyAssetsTitle: '导入小说后',
        emptyAssetsDesc: '资产会在这里展示',
        // 创作模式
        writeMode: '✍️ **创作模式**',
        writeModeDesc: '让我们一起创作你的故事！',
        writeModePrompt: `首先，简单描述你的**故事灵感**：
- 可以是一句话概念
- 可以是一个场景
- 可以是一个角色

比如：「一个香港红Van司机，凌晨载客时遇到奇怪的乘客」`,
        randomGenerate: '🎲 帮我随机生成',
        seeExamples: '📚 看范例',
        storyExamples: '📚 **故事范例**',
        supernatural: '灵异类 🔮',
        romance: '爱情类 💕',
        mystery: '悬疑类 🔍',
        fantasy: '奇幻类 ✨',
        supernaturalEx: '「深夜食堂的老板七叔，专门招待那些...已经不在人世的客人」',
        romanceEx: '「她每天搭同一班港铁，暗恋车厢里看书的男生，直到有一天发现他看的是她写的小说」',
        mysteryEx: '「建筑师发现自己设计的大楼里，有一层不存在于图纸上的楼层」',
        fantasyEx: '「香港最后一个风水师的孙女，意外继承了能看见城市龙脉的能力」',
        pickOrInput: '选一个开始，或输入你自己的想法：',
        randomIdea: '🎲 **随机灵感**',
        likeThis: '👍 就这个！',
        tryAnother: '🎲 换一个',
        editIt: '✏️ 我来改'
    },
    'en': {
        title: 'FizzDragon AIGC Drama Studio',
        connecting: 'Connecting...',
        connected: 'FizzDragon Worldbuilding AI Connected',
        newProject: 'New Project',
        myProjects: 'My Projects',
        noProjects: 'No projects yet',
        beta: '✨ Empowering Everyone to Create',
        tagline: 'Create Good Stories',
        projectAssets: '📦 Project Assets',
        concept: '💡 Concept',
        characters: '👤 Characters',
        chapters: '📝 Chapters',
        production: '👗 Production Design',
        scripts: '✍️ Scripts',
        storyboards: '🎬 Storyboard CSV',
        exportJson: '📥 Export JSON',
        exportCsv: '📊 Export CSV',
        notGenerated: 'Not generated',
        inputPlaceholder: 'Type a message...',
        importNovel: '📄 Import Novel',
        aiWrite: '✍️ AI Write for Me',
        deepInterview: '🎤 Deep Interview (More Precise)',
        directAnalysis: '⚡ Direct Analysis (Faster)',
        confirm: '✅ Confirm',
        regenerate: '🔄 Regenerate',
        skip: '⏭️ Skip',
        skipAll: '⏭️ Skip All Questions',
        continue: 'Continue',
        help: 'Help',
        welcome: '✨ **Welcome to FizzDragon AIGC Drama Studio**',
        welcomeDesc: "I'm your AI creative partner, helping you transform novels/stories into professional storyboards.",
        chooseStart: 'Choose how to start:',
        conceptDone: '📖 **Concept Analysis Complete!**',
        charactersDone: '👤 **Character Analysis Complete!**',
        chaptersDone: '📝 **Chapter Planning Complete!**',
        productionDone: '👗 **Production Design Complete!**',
        scriptDone: '✍️ **Script Complete!**',
        storyboardDone: '🎬 **Storyboard Complete!**',
        analyzing: 'Analyzing...',
        generating: 'Generating...',
        saving: 'Saving...',
        saved: '💾 Saved',
        episodes: 'episodes',
        scriptsCount: 'scripts',
        storyboardsCount: 'storyboards',
        unnamed: 'Untitled',
        stepNotStarted: 'Not Started',
        stepConcept: 'Concept',
        stepCharacter: 'Character',
        stepChapter: 'Chapter',
        stepProduction: 'Production',
        stepScript: 'Script',
        stepStoryboard: 'Storyboard',
        rename: 'Rename',
        delete: 'Delete',
        errorRetry: 'Retry',
        errorSkip: 'Skip',
        noContent: 'No novel content imported yet',
        exportToFizzDragon: '🚀 Import to FizzDragon',
        emptyAssetsTitle: 'Import a novel',
        emptyAssetsDesc: 'Assets will be displayed here',
        // 创作模式
        writeMode: '✍️ **Creative Mode**',
        writeModeDesc: "Let's create your story together!",
        writeModePrompt: `First, describe your **story idea**:
- A one-line concept
- A scene
- A character

For example: "A Hong Kong minibus driver picks up strange passengers at midnight"`,
        randomGenerate: '🎲 Random Generate',
        seeExamples: '📚 See Examples',
        storyExamples: '📚 **Story Examples**',
        supernatural: 'Supernatural 🔮',
        romance: 'Romance 💕',
        mystery: 'Mystery 🔍',
        fantasy: 'Fantasy ✨',
        supernaturalEx: '"Uncle Seven runs a late-night diner that serves customers who are... no longer alive"',
        romanceEx: '"She takes the same MTR train every day, secretly admiring the guy reading a book, until she discovers he\'s reading her novel"',
        mysteryEx: '"An architect discovers a floor in his building that doesn\'t exist in the blueprints"',
        fantasyEx: '"The granddaughter of Hong Kong\'s last feng shui master inherits the ability to see the city\'s dragon veins"',
        pickOrInput: 'Pick one to start, or type your own idea:',
        randomIdea: '🎲 **Random Idea**',
        likeThis: '👍 Use this!',
        tryAnother: '🎲 Try another',
        editIt: '✏️ Let me edit'
    }
};

function t(key) {
    return i18n[currentLang]?.[key] || i18n['zh-TW'][key] || key;
}

function changeLanguage(lang) {
    currentLang = lang;
    localStorage.setItem('lang', lang);
    applyLanguage();
}

function applyLanguage() {
    // 更新静态UI元素
    document.getElementById('headerTitle').textContent = t('title');
    document.getElementById('statusText').textContent = t('connected');
    document.getElementById('userInput').placeholder = t('inputPlaceholder');
    
    // 更新侧边栏（只更新文字部分，保留图标）
    const newBtnText = document.getElementById('newBtnText');
    if (newBtnText) newBtnText.textContent = t('newProject');
    
    const projectListTitle = document.getElementById('projectListTitle');
    if (projectListTitle) projectListTitle.textContent = t('myProjects');
    
    const sidebarTagline = document.getElementById('sidebarTagline');
    if (sidebarTagline) sidebarTagline.textContent = t('tagline') || '創造好故事';
    
    const betaBadge = document.querySelector('.beta-badge');
    if (betaBadge) betaBadge.textContent = t('beta');
    
    // 更新资产面板标题（顺序：高概念|章节, 角色|服化道, 剧本|分镜）
    const assetsTitles = document.querySelectorAll('.asset-section-title');
    const titleKeys = ['concept', 'chapters', 'characters', 'production', 'scripts', 'storyboards'];
    assetsTitles.forEach((el, i) => {
        if (titleKeys[i]) el.textContent = t(titleKeys[i]);
    });
    
    // 更新资产面板标题
    const assetsPanelHeader = document.querySelector('.assets-panel-header h3');
    if (assetsPanelHeader) assetsPanelHeader.textContent = t('projectAssets');
    
    // 更新导出按钮
    const exportBtns = document.querySelectorAll('.asset-row .new-chat-btn');
    if (exportBtns[0]) exportBtns[0].textContent = t('exportJson');
    if (exportBtns[1]) exportBtns[1].textContent = t('exportCsv');
    
    // 更新未生成文本
    document.querySelectorAll('.asset-section-content').forEach(el => {
        if (el.textContent.trim() === '未生成' || el.textContent.trim() === 'Not generated' || el.textContent.trim() === '未生成') {
            el.textContent = t('notGenerated');
        }
    });
    
    // 更新空资产提示
    const emptyText = document.querySelector('.empty-text');
    if (emptyText) {
        emptyText.innerHTML = `${t('emptyAssetsTitle')}<br>${t('emptyAssetsDesc')}`;
    }
    
    // 更新语言选择器
    document.getElementById('langSelect').value = currentLang;
    
    // 语言切换时刷新欢迎消息（仅在手动切换语言时）
    // 初始加载由 init() 处理，不在这里调用
}

// 多语言欢迎消息
function showWelcome() {
    const projects = getProjects();
    const projectCount = Object.keys(projects).length;
    
    const welcomeTexts = {
        'en': `✨ **Welcome to FizzDragon AIGC Drama Studio**

We've studied **hundreds of master works**, including:
• Robert McKee "Story" - Value Transformation Theory
• Joseph Campbell "The Hero with a Thousand Faces"
• Blake Snyder "Save the Cat" - 15 Beat Sheet
• Christopher Vogler "The Writer's Journey"
• Syd Field "Screenplay" - Three-Act Structure
• Steven D. Katz "Shot by Shot" - Storyboarding

**Empowering every creator to work with the masters.**

───────────────────────
Choose how to start:
${projectCount > 0 ? `📂 You have **${projectCount}** saved project(s)\n` : ''}`,
        'zh-CN': `✨ **欢迎来到 FizzDragon AIGC番剧系统**

我们学习了**上百本大师著作**，包括：
• Robert McKee《故事》- 价值转换理论
• Joseph Campbell《千面英雄》- 英雄旅程原型
• Blake Snyder《Save the Cat》- 15节拍表
• Christopher Vogler《作家之路》- 12阶段结构
• Syd Field《Screenplay》- 三幕剧圣经
• Steven D. Katz《Shot by Shot》- 分镜导演学

**让每一个创作者有机会和真正的大师共同创作。**

───────────────────────
选择开始方式：
${projectCount > 0 ? `📂 你有 **${projectCount}** 个已保存的项目\n` : ''}`,
        'zh-TW': `✨ **歡迎來到 FizzDragon AIGC番劇系統**

我們學習了**上百本大師著作**，包括：
• Robert McKee《故事》- 價值轉換理論
• Joseph Campbell《千面英雄》- 英雄旅程原型
• Blake Snyder《Save the Cat》- 15節拍表
• Christopher Vogler《作家之路》- 12階段結構
• Syd Field《Screenplay》- 三幕劇聖經
• Steven D. Katz《Shot by Shot》- 分鏡導演學

**讓每一個創作者有機會和真正的大師共同創作。**

───────────────────────
選擇開始方式：
${projectCount > 0 ? `📂 你有 **${projectCount}** 個已保存的項目\n` : ''}`
    };
    
    addAIMessage(welcomeTexts[currentLang] || welcomeTexts['zh-TW'], [
        { text: '📄 導入現有故事', action: () => document.getElementById('fileInput').click() },
        { text: '✍️ 我要寫故事', action: () => startWriteStory() },
        { text: '🤖 AI幫我寫', action: () => startAIStoryWriting() },
        { text: '🚀 Auto-Pilot 全自動', action: () => showAutoPilotOptions() }
    ]);
}

// ==================== Auto-Pilot 模式開關 ====================
function toggleAutoPilotMode() {
    state.autoPilotMode = !state.autoPilotMode;
    updateAutoPilotToggle();
    
    if (state.autoPilotMode) {
        addAIMessage(`🚀 **Auto-Pilot 模式已開啟**

系統將自動推進每個步驟。
完成一步後自動進入下一步。

點擊按鈕再次關閉，回到對話模式。`);
    } else {
        addAIMessage(`⏸️ **Auto-Pilot 已關閉**

回到對話模式。
每個步驟完成後會等待你的指令。`);
    }
}

function updateAutoPilotToggle() {
    const btn = document.getElementById('autoPilotToggle');
    const label = document.getElementById('autoPilotLabel');
    if (state.autoPilotMode) {
        btn.classList.add('active');
        label.textContent = 'ON';
    } else {
        btn.classList.remove('active');
        label.textContent = 'OFF';
    }
}

// 检查是否应该自动进入下一步
function checkAutoPilotNext(currentStep) {
    if (!state.autoPilotMode) return;
    
    const steps = ['concept', 'character', 'chapters', 'production', 'script', 'storyboard'];
    const currentIndex = steps.indexOf(currentStep);
    
    if (currentIndex < 0 || currentIndex >= steps.length - 1) return;
    
    const nextStep = steps[currentIndex + 1];
    
    // 延迟1秒后自动进入下一步
    setTimeout(() => {
        if (!state.autoPilotMode) return; // 再次检查，用户可能关闭了
        
        switch(nextStep) {
            case 'character':
                addAIMessage('🚀 Auto-Pilot: 進入角色設計...');
                runCharacterAnalysis();
                break;
            case 'chapters':
                addAIMessage('🚀 Auto-Pilot: 進入章節規劃...');
                runChapterPlanning();
                break;
            case 'production':
                addAIMessage('🚀 Auto-Pilot: 進入服化道設計...');
                runProductionDesign();
                break;
            case 'script':
                addAIMessage('🚀 Auto-Pilot: 進入劇本生成...');
                runScriptWriting(1);
                break;
            case 'storyboard':
                addAIMessage('🚀 Auto-Pilot: 進入分鏡生成...');
                runStoryboardGeneration(1);
                break;
        }
    }, 1000);
}

// ==================== Auto-Pilot 全自動模式 ====================
function showAutoPilotOptions() {
    addAIMessage(`🚀 **Auto-Pilot 全自動模式**

系統將自動完成所有步驟：
1️⃣ 高概念分析
2️⃣ 角色設計（6個角色）
3️⃣ 章節規劃
4️⃣ 服化道設計
5️⃣ 劇本生成
6️⃣ 分鏡生成

**預計時間**：5-10分鐘
**完成後**：可逐項調整並重新生成

───────────────────────
請先導入你的故事：`, [
        { text: '📄 導入故事後啟動', action: () => { state.autoPilotEnabled = true; document.getElementById('fileInput').click(); } },
        { text: '🤖 AI寫故事後啟動', action: () => { state.autoPilotEnabled = true; startAIStoryWriting(); } },
        { text: '↩️ 返回', action: () => showWelcome() }
    ]);
}

// Auto-Pilot 入口（检查是否需要配置）
function runAutoPilot() {
    if (!state.novel) {
        addAIMessage('❌ 請先導入故事');
        return;
    }
    
    // 如果已有配置，直接开始；否则先问配置
    if (state.production?.episodes && state.production?.durationMin) {
        runAutoPilotCore();
    } else {
        askAutoPilotConfig();
    }
}

// Auto-Pilot 配置问题
function askAutoPilotConfig() {
    if (!state.novel) {
        addAIMessage('❌ 請先導入故事');
        return;
    }
    
    // 估算字数
    const wordCount = state.novel.length;
    const suggestedEpisodes = Math.max(10, Math.min(50, Math.ceil(wordCount / 5000)));
    
    addAIMessage(`🚀 **Auto-Pilot 配置**

📖 故事字數：**${wordCount.toLocaleString()}** 字
📊 建議集數：**${suggestedEpisodes}** 集

請選擇集數：`, [
        { text: '10集（短篇）', action: () => askEpisodeDuration(10) },
        { text: '24集（標準）', action: () => askEpisodeDuration(24) },
        { text: '50集（長篇）', action: () => askEpisodeDuration(50) },
        { text: `${suggestedEpisodes}集（推薦）`, action: () => askEpisodeDuration(suggestedEpisodes) },
        { text: '自定義...', action: () => askCustomEpisodes() }
    ]);
}

function askCustomEpisodes() {
    addAIMessage(`請輸入集數（1-100）：`);
    state.waitingForEpisodeInput = true;
}

function askEpisodeDuration(episodes) {
    state.production = state.production || {};
    state.production.episodes = episodes;
    
    addAIMessage(`✅ 已選擇 **${episodes}集**

請選擇每集時長：`, [
        { text: '3分鐘（短視頻）', action: () => startAutoPilotWithConfig(episodes, 3) },
        { text: '5分鐘（標準）', action: () => startAutoPilotWithConfig(episodes, 5) },
        { text: '10分鐘（長篇）', action: () => startAutoPilotWithConfig(episodes, 10) },
        { text: '自定義...', action: () => askCustomDuration(episodes) }
    ]);
}

function askCustomDuration(episodes) {
    state.production = state.production || {};
    state.production.episodes = episodes;
    addAIMessage(`請輸入每集時長（分鐘，1-30）：`);
    state.waitingForDurationInput = true;
}

function startAutoPilotWithConfig(episodes, duration) {
    state.production = {
        episodes: episodes,
        durationMin: duration,
        shotsPerMin: 10  // 默认每分钟10镜头
    };
    
    const totalShots = episodes * duration * 10;
    addAIMessage(`📋 **配置確認**

• 集數：**${episodes}集**
• 時長：**${duration}分鐘/集**
• 預計分鏡：**${totalShots.toLocaleString()}** 個

即將開始自動生成...`, [
        { text: '🚀 開始！', action: () => runAutoPilotCore() },
        { text: '↩️ 重新配置', action: () => askAutoPilotConfig() }
    ]);
}

// Auto-Pilot 主流程（原runAutoPilot改名）
async function runAutoPilotCore() {
    if (!state.novel) {
        addAIMessage('❌ 請先導入故事');
        return;
    }
    
    // 标记项目正在运行
    if (currentProjectId) {
        runningProjects[currentProjectId] = true;
        renderProjectList();
    }
    
    addAIMessage(`🚀 **Auto-Pilot 啟動！**

📊 配置：${state.production?.episodes || 10}集 × ${state.production?.durationMin || 5}分鐘

正在後台自動執行所有步驟...
請在右側「項目資產」面板查看進度 →

<div id="autoPilotProgress" style="background:var(--surface);padding:16px;border-radius:8px;margin:12px 0;">
    <div class="ap-step" id="ap-concept"><span class="ap-indicator ap-waiting"></span> 1. 高概念分析</div>
    <div class="ap-step" id="ap-character"><span class="ap-indicator ap-pending"></span> 2. 角色設計</div>
    <div class="ap-step" id="ap-chapters"><span class="ap-indicator ap-pending"></span> 3. 章節規劃</div>
    <div class="ap-step" id="ap-production"><span class="ap-indicator ap-pending"></span> 4. 服化道設計</div>
    <div class="ap-step" id="ap-script"><span class="ap-indicator ap-pending"></span> 5. 劇本生成</div>
    <div class="ap-step" id="ap-storyboard"><span class="ap-indicator ap-pending"></span> 6. 分鏡生成</div>
</div>

<style>
.ap-step { padding:10px 12px; margin:4px 0; border-radius:6px; font-size:13px; display:flex; align-items:center; gap:10px; }
.ap-indicator { width:12px; height:12px; border-radius:50%; display:inline-block; flex-shrink:0; }
.ap-indicator.ap-pending { background:#555; }
.ap-indicator.ap-waiting { background:#6366F1; animation: ap-pulse 1.5s infinite; }
.ap-indicator.ap-running { border:2px solid #6366F1; border-top-color:transparent; animation: ap-spin 0.8s linear infinite; background:transparent; }
.ap-indicator.ap-done { background:#E31B23; } /* 红点 = 完成 */
.ap-indicator.ap-need-input { background:#4ade80; } /* 绿点 = 需沟通 */
.ap-indicator.ap-error { background:#FFD700; clip-path: polygon(50% 0%, 0% 100%, 100% 100%); border-radius:0; } /* 闪电/三角 = 失败 */
.ap-step.running { background:rgba(99,102,241,0.15); }
.ap-step.done { background:rgba(227,27,35,0.1); }
.ap-step.error { background:rgba(239,68,68,0.15); }
@keyframes ap-spin { to { transform: rotate(360deg); } }
@keyframes ap-pulse { 0%,100% { opacity:1; } 50% { opacity:0.5; } }
</style>`);
    
    const updateStep = (id, status, text) => {
        const el = document.getElementById(id);
        if (el) {
            el.className = 'ap-step ' + status;
            const indicatorClass = status === 'running' ? 'ap-running' : status === 'done' ? 'ap-done' : status === 'error' ? 'ap-error' : 'ap-pending';
            el.innerHTML = `<span class="ap-indicator ${indicatorClass}"></span> ${text}`;
        }
    };
    
    try {
        // 1. 高概念
        updateStep('ap-concept', 'running', '🔄 1. 高概念分析中...');
        await runConceptStepSilent();
        updateStep('ap-concept', 'done', '✅ 1. 高概念分析完成');
        
        // 2. 角色
        updateStep('ap-character', 'running', '🔄 2. 角色設計中...');
        await runCharacterStepSilent();
        updateStep('ap-character', 'done', '✅ 2. 角色設計完成');
        
        // 3. 章节
        updateStep('ap-chapters', 'running', '🔄 3. 章節規劃中...');
        await runChaptersStepSilent();
        updateStep('ap-chapters', 'done', '✅ 3. 章節規劃完成');
        
        // 4. 服化道
        updateStep('ap-production', 'running', '🔄 4. 服化道設計中...');
        await runProductionStepSilent();
        updateStep('ap-production', 'done', '✅ 4. 服化道設計完成');
        
        // 5. 剧本（第1章）
        updateStep('ap-script', 'running', '🔄 5. 劇本生成中...');
        await runScriptStepSilent(1);
        updateStep('ap-script', 'done', '✅ 5. 劇本生成完成');
        
        // 6. 分镜（第1章）
        updateStep('ap-storyboard', 'running', '🔄 6. 分鏡生成中...');
        await runStoryboardStepSilent(1);
        updateStep('ap-storyboard', 'done', '✅ 6. 分鏡生成完成');
        
        // 完成！
        showAutoPilotComplete();
        
    } catch (err) {
        // 清除运行状态
        if (currentProjectId) {
            delete runningProjects[currentProjectId];
            renderProjectList();
        }
        console.error('Auto-Pilot error:', err);
        
        // 判断是网络问题还是其他问题
        const isNetworkError = err.message?.includes('NETWORK') || 
                               err.message?.includes('fetch') || 
                               err.message?.includes('超時') ||
                               err.message?.includes('timeout');
        
        addAIMessage(`❌ Auto-Pilot ${isNetworkError ? '網絡中斷' : '遇到問題'}：${err.message}

${isNetworkError ? '⚠️ 請檢查網絡連接，穩定後點「續跑」繼續\n\n' : ''}已完成的步驟已保存，可從斷點繼續。`, [
            { text: '🔄 從斷點續跑', action: () => resumeAutoPilot() },
            { text: '🔄 重新開始', action: () => runAutoPilot() },
            { text: '✋ 手動繼續', action: () => continueImportProject() }
        ]);
    }
}

// 从断点续跑Auto-Pilot
async function resumeAutoPilot() {
    if (!state.novel) {
        addAIMessage('❌ 請先導入故事');
        return;
    }
    
    const a = state.assets || {};
    
    // 检测哪些步骤已完成
    const hasConcept = !!a.concept;
    const hasChars = (a.characters?.length || 0) > 0;
    const hasChapters = (a.chapters?.length || 0) > 0;
    const hasProduction = (a.costumes?.length || 0) > 0 || (a.sets?.length || 0) > 0;
    const hasScript = Object.keys(a.scripts || {}).length > 0;
    const hasStoryboard = Object.keys(a.storyboards || {}).length > 0;
    
    let startFrom = 1;
    if (hasConcept) startFrom = 2;
    if (hasChars) startFrom = 3;
    if (hasChapters) startFrom = 4;
    if (hasProduction) startFrom = 5;
    if (hasScript) startFrom = 6;
    if (hasStoryboard) startFrom = 7; // 全部完成
    
    if (startFrom >= 7) {
        addAIMessage('✅ 所有步驟都已完成！');
        showAutoPilotComplete();
        return;
    }
    
    addAIMessage(`🔄 **從第 ${startFrom} 步繼續...**\n\n已完成: ${startFrom - 1}/6 步`);
    
    // 标记项目正在运行
    if (currentProjectId) {
        runningProjects[currentProjectId] = true;
        renderProjectList();
    }
    
    const updateStep = (id, status, text) => {
        const el = document.getElementById(id);
        if (el) {
            const indicatorClass = status === 'running' ? 'ap-running' : status === 'done' ? 'ap-done' : status === 'error' ? 'ap-error' : 'ap-pending';
            el.className = 'ap-step ' + status;
            el.innerHTML = `<span class="ap-indicator ${indicatorClass}"></span> ${text}`;
        }
    };
    
    try {
        if (startFrom <= 1) {
            updateStep('ap-concept', 'running', '🔄 1. 高概念分析中...');
            await runConceptStepSilent();
            updateStep('ap-concept', 'done', '✅ 1. 高概念分析完成');
        }
        if (startFrom <= 2) {
            updateStep('ap-character', 'running', '🔄 2. 角色設計中...');
            await runCharacterStepSilent();
            updateStep('ap-character', 'done', '✅ 2. 角色設計完成');
        }
        if (startFrom <= 3) {
            updateStep('ap-chapters', 'running', '🔄 3. 章節規劃中...');
            await runChaptersStepSilent();
            updateStep('ap-chapters', 'done', '✅ 3. 章節規劃完成');
        }
        if (startFrom <= 4) {
            updateStep('ap-production', 'running', '🔄 4. 服化道設計中...');
            await runProductionStepSilent();
            updateStep('ap-production', 'done', '✅ 4. 服化道設計完成');
        }
        if (startFrom <= 5) {
            updateStep('ap-script', 'running', '🔄 5. 劇本生成中...');
            await runScriptStepSilent(1);
            updateStep('ap-script', 'done', '✅ 5. 劇本生成完成');
        }
        if (startFrom <= 6) {
            updateStep('ap-storyboard', 'running', '🔄 6. 分鏡生成中...');
            await runStoryboardStepSilent(1);
            updateStep('ap-storyboard', 'done', '✅ 6. 分鏡生成完成');
        }
        
        showAutoPilotComplete();
        
    } catch (err) {
        if (currentProjectId) {
            delete runningProjects[currentProjectId];
            renderProjectList();
        }
        console.error('Resume Auto-Pilot error:', err);
        addAIMessage(`❌ 續跑失敗：${err.message}`, [
            { text: '🔄 再試一次', action: () => resumeAutoPilot() },
            { text: '✋ 手動繼續', action: () => continueImportProject() }
        ]);
    }
}

// Auto-Pilot 完成
function showAutoPilotComplete() {
    // 清除运行状态
    if (currentProjectId) {
        delete runningProjects[currentProjectId];
        renderProjectList();
    }
    saveProject(state.novelTitle, true);
    
    addAIMessage(`🎉 **Auto-Pilot 完成！**

所有內容已自動生成：
✅ 高概念（類型/主題/基調）
✅ ${state.assets.characters?.length || 0} 個角色設計
✅ ${state.assets.chapters?.length || 0} 章劇情規劃
✅ 服化道設計
✅ 第1章劇本
✅ 第1章分鏡

───────────────────────
**下一步：調整並重新生成**

選擇要調整的內容：`, [
        { text: '👤 調整角色', action: () => showCharacterAdjustment() },
        { text: '📝 調整章節', action: () => showChapterAdjustment() },
        { text: '🎬 調整分鏡', action: () => showStoryboardAdjustment() },
        { text: '📊 查看全部資產', action: () => toggleAssetsPanel() },
        { text: '📤 導出Excel', action: () => exportToExcel() }
    ]);
}

// 静默执行各步骤（不显示对话，只更新资产）
async function runConceptStepSilent() {
    const result = await callAgent('concept', state.novel.substring(0, 3000), {});
    const concept = safeJSONParse(result, 'concept');
    state.assets.concept = concept;
    state.step = 1;
    saveProject(null, true);
    updateAssetsPanel();
}

async function runCharacterStepSilent() {
    const result = await callAgent('character', state.novel.substring(0, 3000), { concept: state.assets.concept });
    const parsed = safeJSONParse(result, 'character');
    state.assets.characters = parsed.characters || parsed || [];
    state.step = 2;
    saveProject(null, true);
    updateAssetsPanel();
}

async function runChaptersStepSilent() {
    const result = await callAgent('narrative', state.novel.substring(0, 3000), { 
        concept: state.assets.concept,
        production: state.production 
    });
    const parsed = safeJSONParse(result, 'narrative');
    state.assets.chapters = parsed.chapters || parsed || [];
    state.step = 3;
    saveProject(null, true);
    updateAssetsPanel();
}

async function runProductionStepSilent() {
    const result = await callAgent('production_design', state.novel.substring(0, 2000), {
        concept: state.assets.concept,
        characters: state.assets.characters
    });
    const parsed = safeJSONParse(result, 'production_design');
    state.assets.costumes = parsed.costumes || [];
    state.assets.sets = parsed.sets || [];
    state.assets.props = parsed.props || [];
    state.step = 4;
    saveProject(null, true);
    updateAssetsPanel();
}

async function runScriptStepSilent(chapterNum) {
    const chapter = state.assets.chapters?.[chapterNum - 1];
    const result = await callAgent('screenwriter', state.novel.substring(0, 2500), {
        concept: state.assets.concept,
        characters: state.assets.characters,
        chapter: chapter,
        chapterNumber: chapterNum
    });
    state.assets.scripts = state.assets.scripts || {};
    state.assets.scripts[chapterNum] = result;
    state.step = 5;
    saveProject(null, true);
    updateAssetsPanel();
}

async function runStoryboardStepSilent(chapterNum) {
    const script = state.assets.scripts?.[chapterNum] || state.novel.substring(0, 2500);
    const result = await callAgent('storyboard', script.substring(0, 2500), {
        concept: state.assets.concept,
        characters: state.assets.characters,
        production: state.production
    });
    const parsed = safeJSONParse(result, 'storyboard');
    state.assets.storyboards = state.assets.storyboards || {};
    state.assets.storyboards[chapterNum] = parsed.shots || parsed || [];
    state.step = 6;
    saveProject(null, true);
    updateAssetsPanel();
}

// 调整界面
function showCharacterAdjustment() {
    const chars = state.assets.characters || [];
    addAIMessage(`👤 **調整角色設計**

目前有 ${chars.length} 個角色：
${chars.map((c, i) => `${i+1}. **${c.name}** (${c.role || '角色'})`).join('\n')}

請告訴我要如何調整：
- 修改某個角色的設定
- 添加新角色
- 刪除角色
- 重新生成全部角色

例如：「把主角改成女性」「添加一個反派角色」`);
    state.adjustMode = 'character';
}

function showChapterAdjustment() {
    const chapters = state.assets.chapters || [];
    addAIMessage(`📝 **調整章節規劃**

目前有 ${chapters.length} 章：
${chapters.slice(0, 5).map((c, i) => `${i+1}. ${c.title || '第'+(i+1)+'章'}`).join('\n')}
${chapters.length > 5 ? `...還有 ${chapters.length - 5} 章` : ''}

請告訴我要如何調整：
- 修改某章的情節
- 增加/減少章節數
- 調整節奏和結構

例如：「第3章太平淡，加入轉折」`);
    state.adjustMode = 'chapters';
}

function showStoryboardAdjustment() {
    const sb = state.assets.storyboards || {};
    const totalShots = Object.values(sb).flat().length;
    addAIMessage(`🎬 **調整分鏡**

目前有 ${totalShots} 個鏡頭

請告訴我要如何調整：
- 修改某個鏡頭的構圖
- 調整運鏡方式
- 重新生成某章分鏡

例如：「第1個鏡頭改成俯拍」「增加更多特寫」`);
    state.adjustMode = 'storyboard';
}

// 页面加载时应用语言
document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('langSelect').value = currentLang;
    applyLanguage();
});

// ==================== 状态 ====================
// ==================== 项目资产结构 ====================
const state = {
    novel: null,
    novelTitle: '',
    mode: null,  // 'import' | 'write'
    step: 0,     // 0=等待, 1=高概念, 2=角色, 3=章节规划, 4=服化道, 5=剧本, 6=分镜
    
    // 项目资产 (Project Assets)
    assets: {
        // 1. 高概念
        concept: null,           // {genre, theme, tone, logline, episodeSummaries[]}
        
        // 2. 角色
        characters: [],          // [{name, role, bio, appearance, prompt}]
        
        // 3. 章节规划
        chapters: [],            // [{number, title, duration, summary}]
        
        // 4. 服化道 (Production Design)
        costumes: [],            // [{character, scene, outfit, props, prompt}]
        sets: [],                // [{name, description, prompt}]
        props: [],               // [{name, description, prompt}]
        
        // 5. 剧本 (分章存储)
        scripts: {},             // {1: "第1章剧本", 2: "第2章剧本", ...}
        
        // 6. 分镜 (分章存储)
        storyboards: {}          // {1: [{shot_id, scene, lighting, camera, acting, action, image_prompt, video_prompt}], ...}
    },
    
    // 制作设置
    production: {
        episodes: 10,
        durationMin: 3,
        shotsPerMin: 15,
        totalShots: 450
    },
    
    // 访谈状态
    interview: {},
    interviewQuestions: [],
    
    // Auto-Pilot 状态
    autoPilotEnabled: false,
    autoPilotMode: false,  // 持续开关模式
    adjustMode: null,  // 'character' | 'chapters' | 'storyboard'
    currentQuestion: 0,
    
    // 当前编辑
    currentChapter: 0            // 当前正在写/生成的章节
};

// 写作状态
const writeState = {
    idea: null,
    interview: {},
    outline: null,
    chapters: [],
    currentChapter: 0,
    currentQuestion: null,  // null=未开始, -1=等待输入故事灵感, 0+=访谈问题编号
    storyboard: null
};

// ==================== 应用模式 ====================
let appMode = 'drama';  // 'drama' | 'ad'

// 广告分镜状态
const adState = {
    step: 0,           // 0=等待, 1=信息收集, 2=策略分析, 3=分镜设计, 4=执行生成, 5=修改导出
    productImage: null,       // Base64 或 URL
    actorImages: [],          // 演员图片
    requirement: '',          // 一句话需求
    duration: 30,             // 15/30/60秒
    style: '',                // 风格
    
    // 项目资产
    assets: {
        userProfile: null,    // 用户画像JSON
        creativeBrief: null,  // 创意简报
        storyboard: [],       // 分镜脚本 [{shot_id, scene_type, angle, camera_move, description, product_show, actor, props, color_lighting, copy, duration}]
        previews: [],         // 预览图
        video: null           // 预览视频
    }
};

// 广告Agent人格
const AD_AGENT_PERSONAS = {
    ad_director: {
        name: '廣告導演',
        avatar: '🎬',
        personality: '經驗豐富的創意總監',
        phrases: {
            start: '嗨！我是你的廣告導演，讓我們來打造一支精彩的廣告！',
            working: '「正在分析你的需求...」',
            step1: '「收集產品和受眾信息...」',
            done: '太棒了！我已經完全理解你的需求！'
        }
    },
    ad_strategy: {
        name: '策略師',
        avatar: '🧠',
        personality: '洞察人心的策略專家',
        phrases: {
            start: '讓我來分析最佳創意方向...',
            working: '「正在調用《定位》和《消費者行為學》...」',
            step1: '「提煉產品核心賣點...」',
            step2: '「構建目標受眾畫像...」',
            step3: '「確定情緒關鍵詞和敘事方向...」',
            done: '策略分析完成！創意方向已確定！'
        }
    },
    ad_visual: {
        name: '視覺導演',
        avatar: '👁️',
        personality: '視覺藝術家',
        phrases: {
            start: '讓我來設計每個鏡頭的畫面...',
            working: '「正在調用《AIGC動畫分鏡設計》...」',
            step1: '「拆解鏡頭數量和類型...」',
            step2: '「設計景別、角度、運鏡...」',
            step3: '「補充畫面描述和光影...」',
            done: '視覺分鏡設計完成！'
        }
    },
    ad_copywriter: {
        name: '文案師',
        avatar: '✍️',
        personality: '妙筆生花的文案大師',
        phrases: {
            start: '讓我來為每個鏡頭配上文案...',
            working: '「正在調用《文案訓練手冊》...」',
            step1: '「設計主Slogan...」',
            step2: '「為每個鏡頭配文案...」',
            done: '文案創作完成！'
        }
    }
};

// ==================== 标题提取（Bug #5 fix）====================
function extractTitleFromText(text) {
    if (!text || typeof text !== 'string') return null;
    
    const lines = text.split('\n').map(l => l.trim()).filter(l => l);
    const firstLines = lines.slice(0, 10); // 检查前10行
    
    // 1. 查找《标题》格式
    for (const line of firstLines) {
        const match = line.match(/《(.+?)》/);
        if (match && match[1].length <= 30) {
            console.log('📚 提取标题（书名号）:', match[1]);
            return match[1];
        }
    }
    
    // 2. 查找"标题："或"Title:"格式
    for (const line of firstLines) {
        const match = line.match(/(?:标题|題目|Title|书名|片名)[：:]\s*(.+)/i);
        if (match && match[1].length <= 30) {
            console.log('📚 提取标题（前缀）:', match[1]);
            return match[1].trim();
        }
    }
    
    // 3. 第一个非空行如果是短文本（可能是标题）
    if (firstLines[0] && firstLines[0].length <= 30 && !firstLines[0].includes('。')) {
        // 检查第二行是不是作者名
        const secondLine = firstLines[1] || '';
        if (secondLine.match(/作者|著|编剧|导演|Author/i) || secondLine.length < firstLines[0].length) {
            console.log('📚 提取标题（首行）:', firstLines[0]);
            return firstLines[0];
        }
    }
    
    console.log('📚 未能提取标题，使用文件名');
    return null;
}

// ==================== 剧本清理（去除Markdown标记）====================
function cleanScriptMarkdown(text) {
    if (!text || typeof text !== 'string') return text;
    
    return text
        // 去除粗体标记 **文字**
        .replace(/\*\*([^*]+)\*\*/g, '$1')
        // 去除斜体标记 *文字* 或 _文字_
        .replace(/\*([^*]+)\*/g, '$1')
        .replace(/_([^_]+)_/g, '$1')
        // 去除行内代码 `文字`
        .replace(/`([^`]+)`/g, '$1')
        // 去除标题标记 # ## ###
        .replace(/^#{1,3}\s+/gm, '')
        // 清理多余空行
        .replace(/\n{3,}/g, '\n\n')
        .trim();
}

// ==================== JSON解析（带自动修复）====================
function safeJSONParse(text, context = 'unknown') {
    // 如果已经是对象，直接返回
    if (typeof text === 'object' && text !== null) {
        console.log(`safeJSONParse [${context}]: 已经是对象，直接返回`);
        return text;
    }
    
    if (!text || typeof text !== 'string') {
        console.warn(`safeJSONParse [${context}]: 空输入或非字符串`, typeof text);
        return {};
    }
    
    // 清理常见问题
    let cleaned = text
        .replace(/```json\n?/g, '')
        .replace(/```\n?/g, '')
        .trim();
    
    // 尝试直接解析
    try {
        return JSON.parse(cleaned);
    } catch (e) {
        console.warn(`safeJSONParse [${context}]: 首次解析失败，尝试修复...`);
    }
    
    // 修复1: 提取JSON对象/数组
    const jsonMatch = cleaned.match(/(\{[\s\S]*\}|\[[\s\S]*\])/);
    if (jsonMatch) {
        try {
            return JSON.parse(jsonMatch[1]);
        } catch (e) {}
    }
    
    // 修复2: 移除尾部逗号
    try {
        const noTrailing = cleaned.replace(/,(\s*[\}\]])/g, '$1');
        return JSON.parse(noTrailing);
    } catch (e) {}
    
    // 修复3: 修复单引号
    try {
        const doubleQuotes = cleaned.replace(/'/g, '"');
        return JSON.parse(doubleQuotes);
    } catch (e) {}
    
    console.error(`safeJSONParse [${context}]: 所有修复尝试失败`);
    return {};
}

// ==================== 流程定义 ====================
const STEPS = [
    { id: 0, name: '導入小說', agent: null },
    { id: 1, name: '概念提取', agent: 'concept' },
    { id: 2, name: '創意訪談', agent: 'interview' },
    { id: 3, name: '章節規劃', agent: 'narrative' },
    { id: 4, name: '角色設計', agent: 'character' },
    { id: 5, name: '分鏡生成', agent: 'storyboard' }
];

// ==================== 内测模式（无积分系统）====================
const MEMBERSHIP = {
    free: { name: '內測版', maxProjects: 999, icon: '🎉' }
};

let currentUser = {
    id: localStorage.getItem('user_id') || 'guest_' + Date.now(),
    plan: 'free'
};

function initUser() {
    localStorage.setItem('user_id', currentUser.id);
}

function updateUserUI() {
    // 内测版不需要更新UI
}

// ==================== 侧边栏 ====================
let currentProjectId = null;
let runningProjects = {}; // 追踪正在运行Auto-Pilot的项目
let activeProjects = {}; // 追踪对话式处理中的项目
let errorProjects = {}; // 追踪有错误的项目

function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('sidebarOverlay');
    sidebar.classList.toggle('show');
    overlay.classList.toggle('show');
}

function toggleAssetsPanel() {
    const panel = document.getElementById('assetsPanel');
    const overlay = document.getElementById('assetsOverlay');
    const isMobile = window.innerWidth <= 768;
    
    if (isMobile) {
        // 移动端：滑出效果
        panel.classList.toggle('show');
        overlay.classList.toggle('show');
    } else {
        // 桌面端：显示/隐藏
        if (panel.style.display === 'none') {
            panel.style.display = 'flex';
        } else {
            panel.style.display = 'none';
        }
    }
}

// 更新右侧资产面板
// 智能体依赖检查 - 带依赖的智能体触发
function triggerAgentWithCheck(agentType) {
    console.log('🎯 triggerAgentWithCheck:', agentType, { novel: !!state.novel, novelLen: state.novel?.length });
    
    const a = state.assets || {};
    const hasConcept = !!a.concept;
    const hasChars = (a.characters?.length || 0) > 0;
    const hasChapters = (a.chapters?.length || 0) > 0;
    const hasScripts = Object.keys(a.scripts || {}).length > 0;
    
    switch(agentType) {
        case 'concept':
            if (!state.novel) {
                console.log('❌ No novel content');
                addAIMessage('❌ 請先導入故事內容', [
                    { text: '📄 導入故事', action: () => document.getElementById('fileInput').click() }
                ]);
                return;
            }
            console.log('✅ Calling runConceptStep');
            runConceptStep();
            break;
            
        case 'character':
            if (!hasConcept) {
                addAIMessage('⚠️ 請先完成「💡 概念分析」，才能生成角色', [
                    { text: '💡 先分析概念', action: () => triggerAgentWithCheck('concept') }
                ]);
                return;
            }
            runCharacterStep();
            break;
            
        case 'chapters':
            if (!hasConcept) {
                addAIMessage('⚠️ 請先完成「💡 概念分析」，才能規劃章節', [
                    { text: '💡 先分析概念', action: () => triggerAgentWithCheck('concept') }
                ]);
                return;
            }
            runChaptersStep();
            break;
            
        case 'script':
            if (!hasConcept || !hasChars || !hasChapters) {
                const missing = [];
                if (!hasConcept) missing.push('💡 概念');
                if (!hasChars) missing.push('👤 人物');
                if (!hasChapters) missing.push('📝 章節');
                addAIMessage(`⚠️ 編劇需要先完成：${missing.join('、')}`, [
                    { text: '🚀 Auto-Pilot 自動完成', action: () => runAutoPilot() }
                ]);
                return;
            }
            runScriptStepForNextChapter();
            break;
            
        case 'storyboard':
            if (!hasScripts) {
                addAIMessage('⚠️ 請先生成「✍️ 劇本」，才能生成分鏡', [
                    { text: '✍️ 先寫劇本', action: () => triggerAgentWithCheck('script') }
                ]);
                return;
            }
            runStoryboardStepForNextChapter();
            break;
    }
}

// 更新顶部智能体进度条
function updateAgentProgressBar(assets) {
    const bar = document.getElementById('agentProgressBar');
    if (!bar) return;
    
    const a = assets || state.assets || {};
    const hasAnyContent = a.concept || (a.characters?.length > 0) || (a.chapters?.length > 0);
    
    // 有内容时显示进度条
    bar.style.display = hasAnyContent || state.novel ? 'flex' : 'none';
    
    // 更新各智能体状态
    const dots = [
        { id: 'apDot1', done: !!a.concept },
        { id: 'apDot2', done: (a.characters?.length || 0) > 0 },
        { id: 'apDot3', done: (a.chapters?.length || 0) > 0 },
        { id: 'apDot4', done: Object.keys(a.scripts || {}).length > 0 },
        { id: 'apDot5', done: Object.keys(a.storyboards || {}).length > 0 }
    ];
    
    dots.forEach(d => {
        const el = document.getElementById(d.id);
        if (el) {
            el.classList.toggle('done', d.done);
        }
    });
}

function updateAssetsPanel() {
    const a = state.assets || {};
    const p = state.production || {};
    
    // 🔧 更新顶部智能体进度条
    updateAgentProgressBar(a);
    
    // 🔧 调试：打印当前资产状态
    console.log('📦 updateAssetsPanel - 当前资产:', {
        concept: !!a.concept,
        characters: a.characters?.length || 0,
        chapters: a.chapters?.length || 0,
        costumes: a.costumes?.length || 0,
        scripts: Object.keys(a.scripts || {}).length,
        storyboards: Object.keys(a.storyboards || {}).length
    });
    const container = document.getElementById('canvasFlow');
    
    // 检查是否有任何内容
    const hasContent = a.story || a.concept || a.characters?.length > 0 || a.chapters?.length > 0 || a.costumes?.length > 0 || a.sets?.length > 0;
    
    if (!hasContent) {
        container.innerHTML = `
            <div class="canvas-empty">
                <div class="empty-icon">📦</div>
                <div class="empty-text">${t('emptyAssetsTitle')}<br>${t('emptyAssetsDesc')}</div>
            </div>
        `;
        return;
    }
    
    let html = '';
    
    // ==================== 区块0：故事源 ====================
    if (a.story) {
        const storyTypeLabels = { upload: '📄 上傳', ai: '🤖 AI生成', manual: '✍️ 自己寫' };
        const storyLabel = storyTypeLabels[a.story.type] || '📖 故事';
        html += `
            <div class="canvas-card story-card">
                <div class="canvas-card-header">
                    <span class="canvas-card-num">00</span>
                    <span class="canvas-card-title">📖 故事源</span>
                    <span class="canvas-card-status">${storyLabel}</span>
                </div>
                <div class="canvas-card-body">
                    <div class="story-info">
                        <div class="story-title"><b>${a.story.title || '未命名故事'}</b></div>
                        <div class="story-meta">${(a.story.content?.length || 0).toLocaleString()} 字</div>
                    </div>
                    <div class="story-preview">${(a.story.content || '').substring(0, 200)}${(a.story.content?.length || 0) > 200 ? '...' : ''}</div>
                    <div class="story-actions">
                        <button class="story-btn" onclick="viewFullStory()">👁️ 查看全文</button>
                        ${a.story.type !== 'upload' ? '<button class="story-btn" onclick="editStory()">✏️ 編輯</button>' : ''}
                    </div>
                </div>
            </div>
        `;
    }
    
    // ==================== 区块1：基础设定 ====================
    const hasBaseSettings = a.concept || a.characters?.length > 0 || a.costumes?.length > 0 || a.sets?.length > 0;
    if (hasBaseSettings) {
        html += `<div class="assets-section">
            <div class="assets-section-header" onclick="toggleSection('baseSettings')">
                <span>📋 基礎設定</span>
                <span id="baseSettingsToggle">▼</span>
            </div>
            <div class="assets-section-body" id="baseSettingsBody">`;
        
        // 01 高概念
        if (a.concept) {
            const c = a.concept;
            html += `
                <div class="canvas-card">
                    <div class="canvas-card-header">
                        <span class="canvas-card-num">01</span>
                        <span class="canvas-card-title">💡 高概念</span>
                        <span class="canvas-card-status">✓</span>
                    </div>
                    <div class="canvas-card-body">
                        <div class="canvas-card-row"><span class="canvas-card-label">類型</span><span class="canvas-card-value">${c.genre || '-'}</span></div>
                        <div class="canvas-card-row"><span class="canvas-card-label">主題</span><span class="canvas-card-value">${c.theme || '-'}</span></div>
                        <div class="canvas-card-row"><span class="canvas-card-label">基調</span><span class="canvas-card-value">${c.tone || '-'}</span></div>
                        ${c.logline ? `<div style="margin-top:6px;font-size:10px;color:var(--text2);line-height:1.4;">"${c.logline.substring(0, 80)}..."</div>` : ''}
                    </div>
                </div>
            `;
        }
        
        // 02 人物小传
        if (a.characters?.length > 0) {
            const withPrompt = a.characters.filter(c => c.prompt).length;
            html += `
                <div class="canvas-card">
                    <div class="canvas-card-header">
                        <span class="canvas-card-num">02</span>
                        <span class="canvas-card-title">👤 人物小傳 (${a.characters.length})</span>
                        <span class="canvas-card-status">${withPrompt} Prompt</span>
                    </div>
                    <div class="canvas-card-body" style="padding:0;">
                        ${a.characters.map((c, i) => `
                            <div class="character-asset-item">
                                <div class="character-asset-header" onclick="toggleCharacterDetail(${i})" style="cursor:pointer;">
                                    <span class="character-asset-name">• <b>${c.name}</b></span>
                                    <span class="character-asset-role">(${c.role || '角色'})</span>
                                    <span class="character-asset-toggle" id="charToggle${i}">▼</span>
                                </div>
                                <div class="character-asset-detail" id="charDetail${i}" style="display:none;" onclick="event.stopPropagation()">
                                    ${c.image_url ? `<div class="char-section"><div class="char-image-container"><img src="${c.image_url}" class="char-image" onclick="window.open('${c.image_url}','_blank')"/></div></div>` : ''}
                                    ${c.bio ? `<div class="char-section"><div class="char-section-title">📖 小傳</div><div class="char-section-content">${formatBio(c.bio)}</div></div>` : ''}
                                    ${c.appearance ? `<div class="char-section"><div class="char-section-title">👤 外貌</div><div class="char-section-content">${c.appearance}</div></div>` : ''}
                                    ${(c.prompt || c.ai_prompt) ? `<div class="char-section"><div class="char-section-title">🎨 Prompt <button class="copy-btn" onclick="event.stopPropagation();copyCharPrompt(${i})">📋</button></div><div class="char-section-content char-prompt" id="charPrompt${i}">${c.prompt || c.ai_prompt}</div></div>` : ''}
                                    <div class="char-section char-actions">
                                        <button class="char-gen-btn" onclick="event.stopPropagation();generateCharacterImage(${i})" ${c.image_url ? 'style="opacity:0.6;"' : ''}>🎨 ${c.image_url ? '重新生成' : '生成形象'}</button>
                                        <button class="char-edit-btn" onclick="event.stopPropagation();editCharacter(${i})">✏️ 編輯</button>
                                        <button class="char-delete-btn" onclick="event.stopPropagation();deleteCharacter(${i})">🗑️</button>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        // 03 服化道
        if (a.costumes?.length > 0 || a.sets?.length > 0 || a.props?.length > 0) {
            const costumeCount = a.costumes?.length || 0;
            const setCount = a.sets?.length || 0;
            html += `
                <div class="canvas-card">
                    <div class="canvas-card-header" onclick="toggleProductionDetail()" style="cursor:pointer;">
                        <span class="canvas-card-num">03</span>
                        <span class="canvas-card-title">👗 服化道</span>
                        <span class="canvas-card-status">${costumeCount}服 ${setCount}景</span>
                    </div>
                    <div class="canvas-card-body" id="productionDetail" style="display:none;padding:0;">
                        ${costumeCount > 0 ? `
                            <div style="padding:6px 10px;border-bottom:1px solid var(--border);">
                                ${a.costumes.slice(0, 3).map(c => `
                                    <div style="font-size:10px;margin:3px 0;"><b>${c.character || '角色'}</b>: ${c.outfit || '-'}</div>
                                `).join('')}
                            </div>
                        ` : ''}
                        ${setCount > 0 ? `
                            <div style="padding:6px 10px;">
                                ${a.sets.slice(0, 3).map(s => `
                                    <div style="font-size:10px;margin:3px 0;"><b>${s.name || '場景'}</b>: ${s.atmosphere || '-'}</div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }
        
        html += `</div></div>`; // 关闭 baseSettings
    }
    
    // ==================== 区块2：内容生产 ====================
    const hasProduction = a.chapters?.length > 0;
    if (hasProduction) {
        const scriptCount = Object.keys(a.scripts || {}).length;
        const sbCount = Object.keys(a.storyboards || {}).length;
        const totalShots = Object.values(a.storyboards || {}).reduce((sum, arr) => sum + (arr?.length || 0), 0);
        
        html += `<div class="assets-section">
            <div class="assets-section-header" onclick="toggleSection('production')">
                <span>📝 內容生產</span>
                <span class="assets-section-stats">${a.chapters.length}章 | ${scriptCount}劇本 | ${totalShots}鏡</span>
                <span id="productionToggle2">▼</span>
            </div>
            <div class="assets-section-body" id="productionBody">`;
        
        // 章节列表（包含剧本和分镜）
        html += getChaptersHtml(a);
        
        html += `</div></div>`; // 关闭 production
    }
    
    // ==================== 区块3：FizzStudio 素材庫 ====================
    const hasAnyAssets = a.characters?.length > 0 || Object.keys(a.storyboards || {}).length > 0;
    if (hasAnyAssets) {
        const charCount = a.characters?.length || 0;
        const charWithImage = a.characters?.filter(c => c.image_url)?.length || 0;
        const charWithPrompt = a.characters?.filter(c => c.ai_prompt || c.prompt)?.length || 0;
        const totalShots = Object.values(a.storyboards || {}).reduce((sum, arr) => sum + (arr?.length || 0), 0);
        const costumeCount = a.costumes?.length || 0;
        const setCount = a.sets?.length || 0;
        
        html += `<div class="assets-section">
            <div class="assets-section-header" onclick="toggleSection('fizzstudio')" style="background:linear-gradient(135deg,rgba(99,102,241,0.1),rgba(139,92,246,0.1));">
                <span>🚀 FizzStudio 素材</span>
                <span class="assets-section-stats">${charWithPrompt}人 | ${totalShots}鏡 | ${charWithImage}圖</span>
                <span id="fizzstudioToggle2">▼</span>
            </div>
            <div class="assets-section-body" id="fizzstudioBody" style="display:none;">
                
                <!-- 分镜表 -->
                <div class="fizzstudio-item">
                    <div class="fizzstudio-item-header">
                        <span>📊 分鏡表</span>
                        <span class="fizzstudio-count">${totalShots} 鏡頭</span>
                    </div>
                    ${totalShots > 0 ? `
                        <div class="fizzstudio-actions">
                            <button onclick="exportToExcel()" class="fizzstudio-btn">📥 導出Excel</button>
                            <button onclick="copyAllStoryboardPrompts()" class="fizzstudio-btn">📋 複製全部Prompt</button>
                        </div>
                    ` : '<div style="font-size:10px;color:var(--text2);padding:4px;">尚未生成分鏡</div>'}
                </div>
                
                <!-- 角色形象 -->
                <div class="fizzstudio-item">
                    <div class="fizzstudio-item-header">
                        <span>👤 角色形象</span>
                        <span class="fizzstudio-count">${charWithPrompt} Prompt / ${charWithImage} 圖片</span>
                    </div>
                    ${charCount > 0 ? `
                        <div class="fizzstudio-char-grid">
                            ${a.characters.map((c, i) => `
                                <div class="fizzstudio-char-card" onclick="showCharacterDetail(${i})">
                                    ${c.image_url ? `<img src="${c.image_url}" class="fizzstudio-char-img"/>` : `<div class="fizzstudio-char-placeholder">👤</div>`}
                                    <div class="fizzstudio-char-name">${c.name}</div>
                                    <div class="fizzstudio-char-status">${c.image_url ? '✅' : (c.ai_prompt ? '📝' : '⏳')}</div>
                                </div>
                            `).join('')}
                        </div>
                        <div class="fizzstudio-actions">
                            <button onclick="generateAllCharacterImages()" class="fizzstudio-btn primary">🎨 批量生成形象</button>
                            <button onclick="copyAllCharacterPrompts()" class="fizzstudio-btn">📋 複製全部Prompt</button>
                        </div>
                    ` : '<div style="font-size:10px;color:var(--text2);padding:4px;">尚未設計角色</div>'}
                </div>
                
                <!-- 服化道 -->
                ${(costumeCount > 0 || setCount > 0) ? `
                <div class="fizzstudio-item">
                    <div class="fizzstudio-item-header">
                        <span>👗 服化道</span>
                        <span class="fizzstudio-count">${costumeCount} 服裝 / ${setCount} 場景</span>
                    </div>
                    <div class="fizzstudio-actions">
                        <button onclick="copyAllProductionPrompts()" class="fizzstudio-btn">📋 複製全部Prompt</button>
                    </div>
                </div>
                ` : ''}
                
            </div>
        </div>`;
    }
    
    container.innerHTML = html;
}

// 切换区块展开/收起
function toggleSection(sectionId) {
    const body = document.getElementById(sectionId + 'Body');
    const toggle = document.getElementById(sectionId + 'Toggle') || document.getElementById(sectionId + 'Toggle2');
    if (body && toggle) {
        const isHidden = body.style.display === 'none';
        body.style.display = isHidden ? 'block' : 'none';
        toggle.textContent = isHidden ? '▲' : '▼';
    }
}

// 03 章节盒子列表 - 单独函数（可展开查看/编辑内容）
function getChaptersHtml(a) {
    if (!a.chapters?.length) return '';
    
    // 计算起承转合分布
    const total = a.chapters.length;
    const phaseRanges = {
        起: Math.ceil(total * 0.25),
        承: Math.ceil(total * 0.5),
        转: Math.ceil(total * 0.75)
    };
    
    let html = `<div style="font-size:11px;color:var(--text2);padding:8px 0 4px;">📝 章節劇本 & 分鏡（點擊查看內容）</div>`;
    
    a.chapters.forEach((ch, i) => {
        const num = i + 1;
        const hasScript = a.scripts?.[num];
        const hasStoryboard = a.storyboards?.[num];
        const shotCount = a.storyboards?.[num]?.length || 0;
        const scriptPreview = hasScript ? a.scripts[num].substring(0, 100) + '...' : '';
        
        // 获取phase标签
        let phase = ch.phase || '';
        if (!phase) {
            if (num <= phaseRanges.起) phase = '起';
            else if (num <= phaseRanges.承) phase = '承';
            else if (num <= phaseRanges.转) phase = '转';
            else phase = '合';
        }
        
        const phaseColors = { '起': '#4CAF50', '承': '#2196F3', '转': '#FF9800', '合': '#E91E63' };
        const phaseColor = phaseColors[phase] || '#888';
        
        // 提取章节详细信息
        const summary = ch.summary || '';
        const conflict = ch.conflict || '';
        const highlight = ch.highlight || '';
        const hook = ch.hook || '';
        const emotion = ch.emotion || '';
        
        html += `
            <div class="chapter-box" id="chapterBox${num}">
                <div class="chapter-box-header" style="cursor:pointer;" onclick="toggleChapterContent(${num})">
                    <span style="background:${phaseColor};color:white;padding:1px 6px;border-radius:3px;margin-right:6px;font-size:9px;font-weight:600;">【${phase}】</span>
                    <span style="color:var(--accent);margin-right:6px;font-weight:600;">E${String(num).padStart(2,'0')}</span>
                    <span style="flex:1;font-weight:500;">${ch.title || `第${num}集`}</span>
                    <span id="chapterToggle${num}" style="font-size:10px;color:#666;">▼</span>
                </div>
                <!-- 章节详情（大纲、冲突、亮点）-->
                <div class="chapter-info" style="padding:8px 10px;background:rgba(0,0,0,0.2);font-size:10px;line-height:1.6;">
                    ${summary ? `<div style="color:var(--text);margin-bottom:6px;padding:6px 8px;background:rgba(255,255,255,0.05);border-radius:4px;border-left:2px solid var(--accent);">
                        <div style="color:var(--accent);font-weight:600;margin-bottom:3px;">📖 本集大綱</div>
                        <div style="color:var(--text2);">${summary}</div>
                    </div>` : ''}
                    <div style="display:flex;flex-wrap:wrap;gap:6px;">
                        ${conflict ? `<div style="color:#E31B23;font-weight:500;flex:1;min-width:120px;"><b>⚔️ 衝突</b> ${conflict}</div>` : ''}
                        ${highlight ? `<div style="color:#FFD700;flex:1;min-width:120px;"><b>🌟 亮點</b> ${highlight}</div>` : ''}
                    </div>
                    <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px;">
                        ${hook ? `<div style="color:#9C27B0;flex:1;min-width:120px;"><b>🎣 懸念鉤子</b> ${hook}</div>` : ''}
                        ${emotion ? `<div style="color:#03A9F4;flex:1;min-width:120px;"><b>💫 情感弧線</b> ${emotion}</div>` : ''}
                    </div>
                    ${ch.scenes ? `<div style="color:var(--text2);margin-top:4px;">🎬 場景: ${ch.scenes}</div>` : ''}
                </div>
                <div class="chapter-box-content">
                    <div class="chapter-box-left" style="cursor:pointer;" onclick="showChapterScript(${num})">
                        <div class="chapter-box-label">✍️ 劇本</div>
                        ${hasScript 
                            ? `<span style="color:#38a169;">✅ 點擊查看</span>` 
                            : `<span style="color:var(--text2);">⏳ 待生成</span>`}
                    </div>
                    <div class="chapter-box-right" style="cursor:pointer;" onclick="showChapterStoryboard(${num})">
                        <div class="chapter-box-label">🎬 分鏡</div>
                        ${hasStoryboard 
                            ? `<span style="color:#38a169;">✅ ${shotCount}鏡 點擊查看</span>` 
                            : `<span style="color:var(--text2);">⏳ 待生成</span>`}
                    </div>
                </div>
                <!-- 展开的内容面板 -->
                <div class="chapter-content-panel" id="chapterPanel${num}">
                    <div class="chapter-content-scroll" id="chapterContent${num}">
                        ${hasScript ? scriptPreview : '尚未生成劇本'}
                    </div>
                </div>
            </div>
        `;
    });
    return html;
}

// 切换角色详情展开/收起
function toggleCharacterDetail(index) {
    const detail = document.getElementById(`charDetail${index}`);
    const toggle = document.getElementById(`charToggle${index}`);
    if (detail.style.display === 'none') {
        detail.style.display = 'block';
        toggle.textContent = '▲';
        toggle.style.transform = 'rotate(180deg)';
    } else {
        detail.style.display = 'none';
        toggle.textContent = '▼';
        toggle.style.transform = 'rotate(0deg)';
    }
}

// 复制角色Prompt
function copyCharPrompt(index) {
    const chars = state.assets?.characters || [];
    const char = chars[index];
    const prompt = char?.prompt || char?.ai_prompt;
    if (prompt) {
        navigator.clipboard.writeText(prompt).then(() => {
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '✓ 已複製';
            btn.style.background = '#4CAF50';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '';
            }, 1500);
        });
    }
}

// 📋 复制所有角色Prompt
function copyAllCharacterPrompts() {
    const chars = state.assets?.characters || [];
    const prompts = chars
        .filter(c => c.ai_prompt || c.prompt)
        .map(c => `【${c.name}】(${c.role || '角色'})\n${c.ai_prompt || c.prompt}`)
        .join('\n\n---\n\n');
    
    if (prompts) {
        navigator.clipboard.writeText(prompts);
        addAIMessage(`✅ 已複製 ${chars.filter(c => c.ai_prompt || c.prompt).length} 個角色的Prompt！`);
    } else {
        addAIMessage('❌ 沒有角色Prompt可複製');
    }
}

// 📋 复制所有分镜Prompt
function copyAllStoryboardPrompts() {
    const sbs = state.assets?.storyboards || {};
    let allPrompts = [];
    
    Object.entries(sbs).forEach(([ep, shots]) => {
        if (Array.isArray(shots)) {
            shots.forEach((shot, i) => {
                const prompt = shot.Image_Prompt || shot.image_prompt || shot.ai_prompt;
                if (prompt) {
                    allPrompts.push(`E${ep.toString().padStart(2,'0')}_S${(i+1).toString().padStart(3,'0')}: ${prompt}`);
                }
            });
        }
    });
    
    if (allPrompts.length > 0) {
        navigator.clipboard.writeText(allPrompts.join('\n\n'));
        addAIMessage(`✅ 已複製 ${allPrompts.length} 個分鏡Prompt！`);
    } else {
        addAIMessage('❌ 沒有分鏡Prompt可複製');
    }
}

// 📋 复制所有服化道Prompt
function copyAllProductionPrompts() {
    const costumes = state.assets?.costumes || [];
    const sets = state.assets?.sets || [];
    
    let prompts = [];
    
    costumes.forEach(c => {
        const prompt = c.ai_prompt || c.prompt;
        if (prompt) prompts.push(`【服裝】${c.character || '角色'}: ${prompt}`);
    });
    
    sets.forEach(s => {
        const prompt = s.ai_prompt || s.prompt;
        if (prompt) prompts.push(`【場景】${s.name || '場景'}: ${prompt}`);
    });
    
    if (prompts.length > 0) {
        navigator.clipboard.writeText(prompts.join('\n\n'));
        addAIMessage(`✅ 已複製 ${prompts.length} 個服化道Prompt！`);
    } else {
        addAIMessage('❌ 沒有服化道Prompt可複製');
    }
}

// 🎨 批量生成所有角色形象
async function generateAllCharacterImages() {
    const chars = state.assets?.characters || [];
    const toGenerate = chars.filter(c => !c.image_url && (c.ai_prompt || c.prompt));
    
    if (toGenerate.length === 0) {
        addAIMessage('✅ 所有角色都已有形象圖片，或缺少Prompt');
        return;
    }
    
    addAIMessage(`🎨 **批量生成 ${toGenerate.length} 個角色形象**\n\n預計耗時 ${toGenerate.length * 15}-${toGenerate.length * 25} 秒，請耐心等待...`);
    
    let success = 0, failed = 0;
    
    for (let i = 0; i < chars.length; i++) {
        const char = chars[i];
        if (char.image_url || !(char.ai_prompt || char.prompt)) continue;
        
        try {
            const response = await fetch(`${API_BASE}/aliyun/generate`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt: char.ai_prompt || char.prompt,
                    size: '1024*1280'
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data.url) {
                    chars[i].image_url = data.url;
                    success++;
                    addAIMessage(`✅ ${char.name} 生成成功 (${success}/${toGenerate.length})`);
                }
            } else {
                failed++;
            }
        } catch (e) {
            failed++;
            console.error(`生成 ${char.name} 失敗:`, e);
        }
        
        // 避免API限流
        await new Promise(r => setTimeout(r, 2000));
    }
    
    state.assets.characters = chars;
    updateAssetsPanel();
    saveProject(null, true);
    
    addAIMessage(`🎉 **批量生成完成！**\n\n✅ 成功: ${success}\n❌ 失敗: ${failed}\n\n圖片已保存到項目資產中。`);
}

// 显示角色详情（点击FizzStudio缩略图）
function showCharacterDetail(index) {
    // 展开角色区域并滚动到对应角色
    const toggle = document.getElementById('charToggle' + index);
    const detail = document.getElementById('charDetail' + index);
    if (detail && toggle) {
        detail.style.display = 'block';
        toggle.textContent = '▲';
        detail.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}

// 🎨 生成角色形象图片（阿里云通义万相）
async function generateCharacterImage(index) {
    const chars = state.assets?.characters || [];
    const char = chars[index];
    if (!char) return;
    
    const prompt = char.ai_prompt || char.prompt;
    if (!prompt) {
        addAIMessage(`❌ 角色 **${char.name}** 缺少AI Prompt，無法生成圖片。請先編輯添加Prompt。`);
        return;
    }
    
    addAIMessage(`🎨 **正在生成 ${char.name} 的形象...**\n\n使用通義萬相AI生成中，請稍候（約10-20秒）...`);
    
    try {
        const response = await fetch(`${API_BASE}/aliyun/generate`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                prompt: prompt,
                size: '1024*1280'  // 人像比例
            })
        });
        
        if (!response.ok) {
            const err = await response.json();
            throw new Error(err.error || '生成失敗');
        }
        
        const data = await response.json();
        
        if (data.url) {
            // 保存图片URL到角色数据
            chars[index].image_url = data.url;
            state.assets.characters = chars;
            
            // 更新资产面板
            updateAssetsPanel();
            
            // 保存项目
            saveProject(null, true);
            
            addAIMessage(`✅ **${char.name} 形象生成成功！**\n\n圖片已保存到項目資產中，點擊圖片可放大查看。`, [
                { text: '🔄 重新生成', action: () => generateCharacterImage(index) },
                { text: '📋 複製圖片URL', action: () => { navigator.clipboard.writeText(data.url); addAIMessage('✅ URL已複製'); } }
            ]);
        } else {
            throw new Error('未返回圖片URL');
        }
        
    } catch (err) {
        console.error('生成角色圖片失敗:', err);
        addAIMessage(`❌ 生成失敗：${err.message}\n\n可能原因：\n- 阿里云API未配置\n- 網絡問題\n- Prompt格式問題`, [
            { text: '🔄 重試', action: () => generateCharacterImage(index) }
        ]);
    }
}

// 编辑单个角色
function editCharacter(index) {
    const chars = state.assets?.characters || [];
    const char = chars[index];
    if (!char) return;
    
    addAIMessage(`📝 **編輯角色：${char.name}**

當前內容：
- 📖 小傳：${(char.bio || '').substring(0, 100)}...
- 👤 外貌：${(char.appearance || '').substring(0, 50)}...

請告訴我你想怎麼修改這個角色？
例如：
- "讓他的性格更內向一點"
- "增加童年創傷的描述"
- "修改外貌，讓他戴眼鏡"
- "重新生成AI Prompt"`);
    
    // 设置等待用户输入的状态
    window.pendingCharacterEdit = {
        index,
        character: char,
        onEdit: async (feedback) => {
            await reviseCharacter(index, char, feedback);
        }
    };
    
    scrollToBottom();
}

// 修改角色
async function reviseCharacter(index, originalChar, feedback) {
    addAIMessage(`🔄 正在修改角色 **${originalChar.name}**...`);
    
    try {
        const revisionPrompt = `
這是原始角色資料：
${JSON.stringify(originalChar, null, 2)}

用戶的修改意見：
${feedback}

請根據意見修改，輸出完整的角色JSON（保持原有格式）：
{
  "name": "角色名",
  "role": "主角/配角/反派",
  "bio": "【人物小傳】完整描述...",
  "appearance": "【外貌特徵】完整描述...",
  "ai_prompt": "英文Prompt..."
}`;
        
        const result = await callAgent('character', revisionPrompt, { revision: true });
        const revisedChar = safeJSONParse(result, 'character');
        
        // 如果返回的是characters数组，取第一个
        const newChar = revisedChar.characters?.[0] || revisedChar;
        
        // 更新角色
        state.assets.characters[index] = { ...originalChar, ...newChar };
        
        // 保存并刷新
        saveProject(null, true);
        updateAssetsPanel();
        
        addAIMessage(`✅ 角色 **${newChar.name || originalChar.name}** 已更新！

查看右側資產面板確認修改。`);
        
    } catch (err) {
        addAIMessage(`❌ 修改失敗：${err.message}

請重試或手動編輯。`);
    }
    
    window.pendingCharacterEdit = null;
}

// 删除角色
function deleteCharacter(index) {
    const chars = state.assets?.characters || [];
    const char = chars[index];
    if (!char) return;
    
    if (confirm(`確定要刪除角色「${char.name}」嗎？此操作不可撤銷。`)) {
        state.assets.characters.splice(index, 1);
        saveProject(null, true);
        updateAssetsPanel();
        addAIMessage(`🗑️ 已刪除角色：${char.name}`);
    }
}

// ==================== 故事源管理 ====================
// 查看完整故事
function viewFullStory() {
    const story = state.assets?.story;
    if (!story) return;
    
    // 创建模态框显示全文
    const modal = document.createElement('div');
    modal.className = 'story-modal';
    modal.innerHTML = `
        <div class="story-modal-content">
            <div class="story-modal-header">
                <h3>📖 ${story.title || '故事全文'}</h3>
                <button class="story-modal-close" onclick="this.closest('.story-modal').remove()">✕</button>
            </div>
            <div class="story-modal-body">
                <pre class="story-full-text">${story.content || '(無內容)'}</pre>
            </div>
            <div class="story-modal-footer">
                <span>${(story.content?.length || 0).toLocaleString()} 字</span>
                <button onclick="copyStoryContent()">📋 複製全文</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}

// 编辑故事
function editStory() {
    const story = state.assets?.story;
    if (!story) return;
    
    // 创建编辑模态框
    const modal = document.createElement('div');
    modal.className = 'story-modal';
    modal.id = 'storyEditModal';
    modal.innerHTML = `
        <div class="story-modal-content story-edit-content">
            <div class="story-modal-header">
                <h3>✏️ 編輯故事</h3>
                <button class="story-modal-close" onclick="this.closest('.story-modal').remove()">✕</button>
            </div>
            <div class="story-modal-body">
                <input type="text" id="storyTitleEdit" class="story-title-input" value="${story.title || ''}" placeholder="故事標題">
                <textarea id="storyContentEdit" class="story-content-edit">${story.content || ''}</textarea>
            </div>
            <div class="story-modal-footer">
                <span id="storyCharCount">${(story.content?.length || 0).toLocaleString()} 字</span>
                <button class="story-save-btn" onclick="saveStoryEdit()">💾 保存</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    
    // 实时字数统计
    const textarea = document.getElementById('storyContentEdit');
    const counter = document.getElementById('storyCharCount');
    textarea.addEventListener('input', () => {
        counter.textContent = textarea.value.length.toLocaleString() + ' 字';
    });
}

// 保存故事编辑
function saveStoryEdit() {
    const title = document.getElementById('storyTitleEdit').value.trim();
    const content = document.getElementById('storyContentEdit').value;
    
    if (!state.assets.story) state.assets.story = {};
    state.assets.story.title = title || state.assets.story.title;
    state.assets.story.content = content;
    state.assets.story.type = state.assets.story.type || 'manual';
    
    saveProject(null, true);
    updateAssetsPanel();
    
    document.getElementById('storyEditModal')?.remove();
    addAIMessage(`✅ 故事已保存！(${content.length.toLocaleString()} 字)`);
}

// 复制故事内容
function copyStoryContent() {
    const story = state.assets?.story;
    if (story?.content) {
        navigator.clipboard.writeText(story.content).then(() => {
            addAIMessage('📋 故事全文已複製到剪貼板！');
        });
    }
}

// 创建新故事（我要写故事）
function startWriteStory() {
    addAIMessage(`✍️ **開始創作故事**

你可以選擇：
1. **自己寫** - 打開編輯器，從零開始創作
2. **AI輔助** - 告訴我故事概念，我幫你寫
3. **上傳現有故事** - 上傳txt/doc文件

請選擇或直接開始描述你的故事想法：`);
    
    showQuickReplies([
        { text: '✏️ 自己寫', action: () => openStoryEditor('manual') },
        { text: '🤖 AI幫我寫', action: () => startAIStoryWriting() },
        { text: '📄 上傳文件', action: () => document.getElementById('novelFile').click() }
    ]);
}

// 打开故事编辑器
function openStoryEditor(type = 'manual') {
    const modal = document.createElement('div');
    modal.className = 'story-modal';
    modal.id = 'storyEditModal';
    modal.innerHTML = `
        <div class="story-modal-content story-edit-content">
            <div class="story-modal-header">
                <h3>✍️ 創作故事</h3>
                <button class="story-modal-close" onclick="this.closest('.story-modal').remove()">✕</button>
            </div>
            <div class="story-modal-body">
                <input type="text" id="storyTitleEdit" class="story-title-input" placeholder="故事標題（必填）">
                <textarea id="storyContentEdit" class="story-content-edit" placeholder="開始寫你的故事..."></textarea>
            </div>
            <div class="story-modal-footer">
                <span id="storyCharCount">0 字</span>
                <button class="story-save-btn" onclick="saveNewStory('${type}')">💾 保存並開始分析</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    
    const textarea = document.getElementById('storyContentEdit');
    const counter = document.getElementById('storyCharCount');
    textarea.addEventListener('input', () => {
        counter.textContent = textarea.value.length.toLocaleString() + ' 字';
    });
    textarea.focus();
}

// 保存新故事
function saveNewStory(type) {
    const title = document.getElementById('storyTitleEdit').value.trim();
    const content = document.getElementById('storyContentEdit').value.trim();
    
    if (!title) {
        alert('請輸入故事標題');
        return;
    }
    if (content.length < 100) {
        alert('故事內容太短（至少100字）');
        return;
    }
    
    // 保存到资产
    state.assets.story = { title, content, type, createdAt: new Date().toISOString() };
    state.novel = content;
    state.novelTitle = title;
    
    document.getElementById('storyEditModal')?.remove();
    
    saveProject(title, true);
    updateAssetsPanel();
    
    addAIMessage(`✅ 故事「${title}」已保存！(${content.length.toLocaleString()} 字)

正在分析故事，生成高概念...`);
    
    // 自动开始分析
    runConceptAnalysis();
}

// AI辅助写故事
function startAIStoryWriting() {
    console.log('🎬 startAIStoryWriting called');
    
    addAIMessage(`🤖 **AI輔助創作**

請告訴我你的故事想法：
- 類型？（愛情/懸疑/科幻/奇幻...）
- 主角是誰？
- 發生什麼事？
- 你想傳達什麼？

例如："一個香港滑板女孩，發現弟弟出車禍不是意外，而是地下賭盤..."

直接打字描述吧！`);
    
    window.pendingAIStory = true;
    console.log('✅ pendingAIStory set to true');
}

// AI生成故事
async function generateAIStory(idea) {
    console.log('🎬 generateAIStory called with:', idea);
    
    addAIMessage(`🤖 收到你的想法！正在為你創作故事...

> "${idea}"`);
    
    showAgentStatus('✍️ 編劇', '正在創作故事...', 'screenwriter');
    startThinkingAnimation('screenwriter');
    
    try {
        const prompt = `你是一位專業的故事創作者。根據用戶的想法，創作一個完整的短篇故事。

用戶想法：${idea}

要求：
1. 故事長度：3000-5000字
2. 包含清晰的開頭、發展、高潮、結局
3. 人物形象鮮明
4. 對話生動自然
5. 情感真實感人

直接輸出故事正文，不要輸出任何解釋或標題（標題我會自動提取）。`;

        const result = await callAgent('screenwriter', prompt, { useReasoner: false });
        
        stopThinkingAnimation();
        
        // 提取或生成标题
        const lines = result.split('\n').filter(l => l.trim());
        let title = lines[0]?.replace(/^[#《「\[]+/, '').replace(/[》」\]]+$/, '').trim();
        if (!title || title.length > 30) {
            title = idea.substring(0, 20) + (idea.length > 20 ? '...' : '');
        }
        
        // 🔧 清空旧项目数据，开始新项目
        currentProjectId = null;
        state.assets = {
            concept: null,
            characters: [],
            chapters: [],
            costumes: null,
            scripts: {},
            storyboards: {}
        };
        state.concept = null;
        state.characters = null;
        state.storyboard = null;
        
        // 保存新故事到资产
        state.assets.story = {
            title,
            content: result,
            type: 'ai',
            idea,
            createdAt: new Date().toISOString()
        };
        state.novel = result;
        state.novelTitle = title;
        
        saveProject(title, true);
        updateAssetsPanel();
        
        addAIMessage(`✅ **故事創作完成！**

📖 **${title}**
📊 ${result.length.toLocaleString()} 字

${result.substring(0, 300)}...

───────────────────────
故事已保存到項目資產。接下來：`, [
            { text: '👁️ 查看全文', action: () => viewFullStory() },
            { text: '✏️ 編輯故事', action: () => editStory() },
            { text: '🔄 重新寫', action: () => startAIStoryWriting() },
            { text: '🎬 開始分析', action: () => runConceptStep() }
        ]);
        
    } catch (err) {
        stopThinkingAnimation();
        addAIMessage(`❌ 創作失敗：${err.message}

請重試或換個想法描述。`, [
            { text: '🔄 重試', action: () => startAIStoryWriting() }
        ]);
    }
}

// 切换服化道详情展开/收起
function toggleProductionDetail() {
    const detail = document.getElementById('productionDetail');
    const toggle = document.getElementById('productionToggle');
    if (detail.style.display === 'none') {
        detail.style.display = 'block';
        toggle.textContent = '▲';
    } else {
        detail.style.display = 'none';
        toggle.textContent = '▼';
    }
}

// 通用复制文本函数
function copyText(text) {
    navigator.clipboard.writeText(text).then(() => {
        const btn = event.target;
        const originalText = btn.textContent;
        btn.textContent = '✓';
        btn.style.background = '#4CAF50';
        setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
        }, 1500);
    });
}

// 切换章节内容展开/收起
function toggleChapterContent(num) {
    const panel = document.getElementById(`chapterPanel${num}`);
    const toggle = document.getElementById(`chapterToggle${num}`);
    if (panel.classList.contains('expanded')) {
        panel.classList.remove('expanded');
        toggle.textContent = '▼';
    } else {
        panel.classList.add('expanded');
        toggle.textContent = '▲';
        // 加载内容
        showChapterScript(num);
    }
}

// 显示剧本内容
function showChapterScript(num) {
    const script = state.assets.scripts?.[num];
    const content = document.getElementById(`chapterContent${num}`);
    const panel = document.getElementById(`chapterPanel${num}`);
    
    if (!script) {
        content.innerHTML = `<div style="color:#888;text-align:center;padding:20px;">
            尚未生成劇本<br>
            <button onclick="runScriptWriting(${num})" style="margin-top:10px;padding:6px 12px;background:var(--accent);border:none;color:white;border-radius:4px;cursor:pointer;">
                ✍️ 生成第${num}集劇本
            </button>
        </div>`;
    } else {
        content.innerHTML = `
            <div style="display:flex;justify-content:space-between;margin-bottom:8px;">
                <span style="color:var(--accent);font-weight:bold;">✍️ 第${num}集劇本</span>
                <button onclick="editChapterScript(${num})" style="padding:2px 8px;background:#333;border:1px solid #444;color:#ccc;border-radius:4px;cursor:pointer;font-size:10px;">✏️ 編輯</button>
            </div>
            <div style="white-space:pre-wrap;">${escapeHtml(script)}</div>
        `;
    }
    
    panel.classList.add('expanded');
    document.getElementById(`chapterToggle${num}`).textContent = '▲';
}

// 显示分镜内容
function showChapterStoryboard(num) {
    const storyboard = state.assets.storyboards?.[num];
    const content = document.getElementById(`chapterContent${num}`);
    const panel = document.getElementById(`chapterPanel${num}`);
    
    if (!storyboard || storyboard.length === 0) {
        content.innerHTML = `<div style="color:#888;text-align:center;padding:20px;">
            尚未生成分鏡<br>
            <button onclick="runStoryboardGeneration(${num})" style="margin-top:10px;padding:6px 12px;background:var(--accent);border:none;color:white;border-radius:4px;cursor:pointer;">
                🎬 生成第${num}集分鏡
            </button>
        </div>`;
    } else {
        let shotsHtml = storyboard.slice(0, 20).map((shot, i) => `
            <div style="padding:8px;margin:4px 0;background:#1a1a1a;border-radius:4px;border-left:2px solid var(--accent);">
                <div style="color:var(--accent);font-size:10px;margin-bottom:4px;">鏡頭 ${i+1}</div>
                <div style="font-size:11px;">${shot.scene || shot.description || ''}</div>
                ${shot.image_prompt ? `<div style="font-size:10px;color:#666;margin-top:4px;">🎨 ${shot.image_prompt.substring(0, 60)}...</div>` : ''}
            </div>
        `).join('');
        
        if (storyboard.length > 20) {
            shotsHtml += `<div style="text-align:center;color:#666;padding:8px;">...還有 ${storyboard.length - 20} 個鏡頭</div>`;
        }
        
        content.innerHTML = `
            <div style="display:flex;justify-content:space-between;margin-bottom:8px;">
                <span style="color:var(--accent);font-weight:bold;">🎬 第${num}集分鏡 (${storyboard.length}鏡)</span>
                <button onclick="exportChapterCSV(${num})" style="padding:2px 8px;background:#333;border:1px solid #444;color:#ccc;border-radius:4px;cursor:pointer;font-size:10px;">📊 導出CSV</button>
            </div>
            ${shotsHtml}
        `;
    }
    
    panel.classList.add('expanded');
    document.getElementById(`chapterToggle${num}`).textContent = '▲';
}

// 编辑剧本
function editChapterScript(num) {
    const script = state.assets.scripts?.[num] || '';
    const content = document.getElementById(`chapterContent${num}`);
    
    content.innerHTML = `
        <div style="margin-bottom:8px;">
            <span style="color:var(--accent);font-weight:bold;">✏️ 編輯第${num}集劇本</span>
        </div>
        <textarea id="editScript${num}" class="chapter-content-edit">${escapeHtml(script)}</textarea>
        <div style="display:flex;gap:8px;margin-top:8px;justify-content:flex-end;">
            <button onclick="showChapterScript(${num})" style="padding:4px 12px;background:#333;border:1px solid #444;color:#ccc;border-radius:4px;cursor:pointer;">取消</button>
            <button onclick="saveChapterScript(${num})" style="padding:4px 12px;background:var(--accent);border:none;color:white;border-radius:4px;cursor:pointer;">💾 保存</button>
        </div>
    `;
}

// 保存剧本
function saveChapterScript(num) {
    const textarea = document.getElementById(`editScript${num}`);
    if (textarea) {
        state.assets.scripts[num] = textarea.value;
        saveProject();
        showChapterScript(num);
        addAIMessage(`✅ 第${num}集劇本已保存！`);
    }
}

// 导出单集Excel
function exportChapterCSV(num) {
    const storyboard = state.assets.storyboards?.[num];
    if (!storyboard) return;
    
    const headers = ['鏡頭ID', '場景', '時間', '光線', '氛圍', '角色', '動作', '台詞', '機位', '運鏡', '景別', 'Image_Prompt', 'Video_Prompt'];
    
    // Excel XML格式
    let excelContent = `<?xml version="1.0" encoding="UTF-8"?>
<?mso-application progid="Excel.Sheet"?>
<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"
 xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet">
<Styles>
<Style ss:ID="header"><Font ss:Bold="1" ss:Color="#FFFFFF"/><Interior ss:Color="#E31B23" ss:Pattern="Solid"/></Style>
<Style ss:ID="cell"><Alignment ss:Vertical="Top" ss:WrapText="1"/></Style>
</Styles>
<Worksheet ss:Name="第${num}集分鏡">
<Table>
<Row>`;
    
    headers.forEach(h => {
        excelContent += `<Cell ss:StyleID="header"><Data ss:Type="String">${h}</Data></Cell>`;
    });
    excelContent += `</Row>`;
    
    storyboard.forEach((shot, i) => {
        excelContent += `<Row>`;
        const values = [
            `E${String(num).padStart(2,'0')}_S${String(i+1).padStart(3,'0')}`,
            shot.scene || '',
            shot.time || '',
            shot.lighting || '',
            shot.mood || '',
            shot.characters || shot.character || '',
            shot.action || '',
            shot.dialogue || '',
            shot.camera_position || '',
            shot.camera_movement || '',
            shot.shot_size || '',
            shot.image_prompt || shot.ai_prompt || '',
            shot.video_prompt || ''
        ];
        values.forEach(v => {
            excelContent += `<Cell ss:StyleID="cell"><Data ss:Type="String">${escapeHtml(String(v))}</Data></Cell>`;
        });
        excelContent += `</Row>`;
    });
    
    excelContent += `</Table></Worksheet></Workbook>`;
    
    const blob = new Blob([excelContent], { type: 'application/vnd.ms-excel' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `E${String(num).padStart(2,'0')}_分鏡表.xls`;
    a.click();
    URL.revokeObjectURL(url);
    
    addAIMessage(`📊 已導出第${num}集分鏡Excel！`);
}

// 导出单集到FizzDragon
function exportChapterToFizzDragon(chapterNum) {
    const a = state.assets || {};
    const chapter = a.chapters?.[chapterNum - 1];
    const script = a.scripts?.[chapterNum];
    const storyboard = a.storyboards?.[chapterNum];
    
    if (!storyboard) {
        addAIMessage(`⚠️ 第${chapterNum}集分鏡尚未生成`);
        return;
    }
    
    const data = {
        episode: chapterNum,
        title: chapter?.title || `第${chapterNum}集`,
        script: script,
        storyboard: storyboard,
        shotCount: storyboard.length
    };
    
    // 复制到剪贴板
    navigator.clipboard.writeText(JSON.stringify(data, null, 2)).then(() => {
        addAIMessage(`✅ **第${chapterNum}集已複製！**

• ${storyboard.length} 個分鏡
• 包含 Image_Prompt + Video_Prompt

前往 FizzDragon 平台粘貼導入即可。`, [
            { text: '🌐 打開FizzDragon', action: () => window.open('https://fizzdragon.com', '_blank') }
        ]);
    }).catch(() => {
        // 如果剪贴板失败，下载文件
        downloadFile(`E${String(chapterNum).padStart(2,'0')}_storyboard.json`, JSON.stringify(data, null, 2), 'application/json');
        addAIMessage(`📥 已下載第${chapterNum}集分鏡文件`);
    });
}

// Kimi风格底部工具栏切换
function switchMode(mode) {
    // 更新工具栏按钮状态
    document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
    const activeBtn = document.getElementById('toolbar' + mode.charAt(0).toUpperCase() + mode.slice(1));
    if (activeBtn) activeBtn.classList.add('active');
    
    // 根据模式执行动作
    switch(mode) {
        case 'story':
            // 故事分析模式 - 显示快捷选项
            addAIMessage('📖 故事模式已激活。您可以：\n• 導入小說文本進行分析\n• 使用AI生成故事概念\n• 創建角色和世界觀', [
                { text: '📄 導入小說', action: () => document.getElementById('fileInput').click() },
                { text: '✨ AI生成故事', action: () => startNewProject() }
            ]);
            break;
        case 'write':
            // 写作模式
            if (typeof switchToWriteMode === 'function') {
                switchToWriteMode();
            } else {
                addAIMessage('✍️ 寫作模式已激活。開始創作您的故事！');
            }
            break;
        case 'storyboard':
            // 分镜模式
            addAIMessage('🎬 分鏡模式已激活。將您的故事轉化為可視化分鏡。');
            break;
        case 'export':
            // 导出模式
            addAIMessage('📤 導出選項：', [
                { text: '📋 JSON格式', action: () => exportProject('json') },
                { text: '📊 Excel分鏡表', action: () => exportProject('excel') },
                { text: '🎨 Prompt包', action: () => exportProject('prompts') }
            ]);
            break;
    }
}

function renderProjectList() {
    // 使用模式过滤的渲染
    renderProjectListByMode();
}

function openProject(projectId) {
    currentProjectId = projectId;
    renderProjectList();
    loadProject(projectId);
    
    // 更新标题
    const projects = getProjects();
    const p = projects[projectId];
    if (p) {
        document.getElementById('headerTitle').textContent = p.name || 'FizzDragon AIGC番劇系統';
    }
    
    // 更新右侧资产面板
    updateAssetsPanel();
    
    // 移动端关闭侧边栏
    if (window.innerWidth <= 768) {
        toggleSidebar();
    }
}

function startNewProject() {
    console.log('🆕 startNewProject called, appMode:', appMode);
    
    // 清空当前状态
    currentProjectId = null;
    state.novel = null;
    state.novelTitle = '';
    state.step = 0;
    state.mode = null;
    writeState.idea = null;
    writeState.outline = null;
    writeState.chapters = [];
    writeState.currentQuestion = null;
    
    // 🔧 清空项目资产（这是漏掉的！）
    state.assets = {
        concept: null,
        characters: [],
        chapters: [],
        costumes: null,
        scripts: {},
        storyboards: {}
    };
    state.production = {
        episodes: 10,
        durationMin: 3,
        shotsPerMin: 10
    };
    
    // 清空广告状态
    adState.step = 0;
    adState.productImage = null;
    adState.actorImages = [];
    adState.requirement = '';
    adState.duration = 30;
    adState.style = '';
    adState.assets = { userProfile: null, creativeBrief: null, storyboard: [], previews: [], video: null };
    
    // 清空聊天
    document.getElementById('chatContainer').innerHTML = '';
    document.getElementById('headerTitle').textContent = appMode === 'ad' ? 'FizzDragon AI廣告分鏡' : 'FizzDragon AIGC番劇系統';
    
    // 根据模式显示欢迎
    if (appMode === 'ad') {
        showAdWelcome();
    } else {
        showStartOptions();
    }
    renderProjectList();
    
    // 🔧 更新右侧资产面板（清空显示）
    updateAssetsPanel();
    
    // 移动端关闭侧边栏
    if (window.innerWidth <= 768) {
        toggleSidebar();
    }
}

// ==================== 应用模式切换 ====================
function switchAppMode(mode) {
    appMode = mode;
    console.log('🔀 切换模式:', mode);
    
    // 🎨 切换配色主题
    document.body.classList.toggle('ad-mode', mode === 'ad');
    
    // 更新Tab样式
    document.querySelectorAll('.mode-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.mode === mode);
    });
    
    // 更新新建按钮文字和标题
    const newBtnText = document.getElementById('newBtnText');
    const projectListTitle = document.getElementById('projectListTitle');
    const headerTitle = document.getElementById('headerTitle');
    
    if (mode === 'ad') {
        newBtnText.textContent = '新建廣告項目';
        projectListTitle.textContent = '我的廣告項目';
        headerTitle.textContent = 'FizzDragon AI廣告分鏡';
    } else {
        newBtnText.textContent = '新建影視項目';
        projectListTitle.textContent = '我的影視項目';
        headerTitle.textContent = 'FizzDragon AIGC番劇系統';
    }
    
    // 过滤项目列表
    renderProjectListByMode();
    
    // 如果没有进行中的项目，显示对应欢迎页
    if (!currentProjectId) {
        document.getElementById('chatContainer').innerHTML = '';
        if (mode === 'ad') {
            showAdWelcome();
        } else {
            showStartOptions();
        }
    }
}

function renderProjectListByMode() {
    const projects = getProjects();
    const list = Object.values(projects)
        .filter(p => {
            // 广告模式：只显示type='ad'的项目
            // 影视模式：显示type不是'ad'的项目（包括没有type字段的旧项目）
            if (appMode === 'ad') {
                return p.type === 'ad';
            } else {
                return !p.type || p.type !== 'ad';  // 包含undefined/null/非ad
            }
        })
        .sort((a, b) => {
            if (a.order !== undefined && b.order !== undefined) {
                return a.order - b.order;
            }
            return new Date(b.timestamp) - new Date(a.timestamp);
        });
    const container = document.getElementById('projectList');
    
    if (list.length === 0) {
        container.innerHTML = `<div style="padding:12px;color:var(--text2);font-size:12px;">${t('noProjects')}</div>`;
        return;
    }
    
    const stepNameKeys = ['stepNotStarted', 'stepConcept', 'stepCharacter', 'stepChapter', 'stepProduction', 'stepScript', 'stepStoryboard'];
    
    container.innerHTML = list.map((p) => {
        const isSelected = p.id === currentProjectId;
        const assets = p.assets || {};
        const chapterCount = assets.chapters?.length || p.chapters?.length || 0;
        const charCount = assets.characters?.length || 0;
        const scriptCount = Object.keys(assets.scripts || {}).length;
        const sbCount = Object.keys(assets.storyboards || {}).length || p.adAssets?.storyboard?.length || 0;
        const stepName = stepNameKeys[p.step] ? t(stepNameKeys[p.step]) : '';
        const icon = p.type === 'ad' ? '📺' : (p.stage === 'write' ? '✍️' : '📄');
        
        // 计算项目状态（5种：待处理/对话处理中/Auto-Pilot/完成/错误）
        const hasConcept = !!assets.concept;
        const hasChars = (assets.characters?.length || 0) > 0;
        const hasChapters = chapterCount > 0;
        const hasScripts = scriptCount > 0;
        const hasSb = sbCount > 0;
        const isRunning = runningProjects && runningProjects[p.id]; // Auto-Pilot
        const isProcessing = activeProjects && activeProjects[p.id]; // 对话式处理
        const hasError = errorProjects && errorProjects[p.id]; // 有错误
        const isComplete = hasConcept && hasChars && hasChapters && hasScripts && hasSb;
        
        // 状态指示器：灰(待处理) / 蓝点(对话处理) / 转圈(Auto-Pilot) / 红(完成) / 闪电(错误)
        let statusIndicator = '';
        if (hasError) {
            statusIndicator = '<span class="proj-status proj-error" title="有問題"></span>';
        } else if (isRunning) {
            statusIndicator = '<span class="proj-status proj-running" title="Auto-Pilot 運行中"></span>';
        } else if (isProcessing) {
            statusIndicator = '<span class="proj-status proj-active" title="處理中"></span>';
        } else if (isComplete) {
            statusIndicator = '<span class="proj-status proj-complete" title="已完成"></span>';
        } else {
            statusIndicator = '<span class="proj-status proj-idle" title="待處理"></span>';
        }
        
        const displayName = String(p.name || t('unnamed') || '未命名');
        const safeName = displayName.replace(/'/g, "\\'").replace(/"/g, '&quot;');
        return `
            <div class="project-item ${isSelected ? 'active' : ''}" 
                 draggable="true"
                 data-project-id="${p.id}"
                 onclick="openProject('${p.id}')"
                 ondragstart="handleDragStart(event, '${p.id}')"
                 ondragend="handleDragEnd(event)"
                 ondragover="handleDragOver(event)"
                 ondragleave="handleDragLeave(event)"
                 ondrop="handleDrop(event, '${p.id}')">
                ${statusIndicator}
                <div class="icon">${icon}</div>
                <div class="info">
                    <div class="title">${displayName}</div>
                    <div class="meta-grid">
                        ${p.type === 'ad' ? `
                            <span>• ${p.duration || 30}秒</span>
                            <span>• ${sbCount} 鏡頭</span>
                        ` : `
                            <span>• ${chapterCount} 集</span>
                            <span>• ${charCount} 角色</span>
                            <span>• ${scriptCount} 劇本</span>
                            <span>• ${sbCount} 分鏡</span>
                        `}
                    </div>
                    ${stepName ? `<div class="meta-step">📍 ${stepName}</div>` : ''}
                </div>
                <div class="actions">
                    <button class="action-btn" onclick="event.stopPropagation(); renameProject('${p.id}', '${safeName}')" title="${t('rename')}">✏️</button>
                    <button class="action-btn" onclick="event.stopPropagation(); confirmDeleteProject('${p.id}', '${safeName}')" title="${t('delete')}">✕</button>
                </div>
            </div>
        `;
    }).join('');
}

// ==================== AI广告分镜系统 ====================
function showAdWelcome() {
    const welcomeTexts = {
        'en': `📺 **Welcome to FizzDragon AI Ad Storyboard**

We've studied **advertising master works**, including:
• David Ogilvy "Oerta" - Advertising Principles
• Luke Sullivan "Hey Whipple, Squeeze This" - Creative Ads
• "AIGC Animation Storyboard Design" - AI Visual Language
• "Hand-on AI Movie Making" - Practical Techniques

**Create professional ad storyboards with AI.**

Just provide: Product Image + One-line Requirement + Duration

───────────────────────
What would you like to create?`,
        'zh-CN': `📺 **欢迎来到 FizzDragon AI广告分镜**

我们学习了**广告大师著作**，包括：
• David Ogilvy《一个广告人的自白》
• Luke Sullivan《嘿，惠普尔，捏紧它》
• 《AIGC动画分镜设计》- AI视觉语言
• 《手把手教你做AI大片》- 实战技巧
• 《定位》《消费者行为学》- 策略基础

**让AI帮你生成专业广告分镜。**

只需提供：产品图 + 一句话需求 + 时长

───────────────────────
开始创作你的广告吧！`,
        'zh-TW': `📺 **歡迎來到 FizzDragon AI廣告分鏡**

我們學習了**廣告大師著作**，包括：
• David Ogilvy《一個廣告人的自白》
• Luke Sullivan《嘿，惠普爾，捏緊它》
• 《AIGC動畫分鏡設計》- AI視覺語言
• 《手把手教你做AI大片》- 實戰技巧
• 《定位》《消費者行為學》- 策略基礎

**讓AI幫你生成專業廣告分鏡。**

只需提供：產品圖 + 一句話需求 + 時長

───────────────────────
開始創作你的廣告吧！`
    };
    
    addAIMessage(welcomeTexts[currentLang] || welcomeTexts['zh-TW'], [
        { text: '🚀 開始創作廣告', action: () => startAdCreation() },
        { text: '📚 查看案例', action: () => showAdExamples() }
    ]);
}

function showAdExamples() {
    addAIMessage(`📚 **廣告案例參考**

**☕ 咖啡廣告 (15秒)**
產品：精品咖啡豆
需求：展現清晨醒腦的儀式感
風格：溫暖治愈
→ 6個鏡頭：晨光→咖啡豆特寫→沖泡→香氣→品嚐→Logo

**💄 美妝廣告 (30秒)**
產品：口紅
需求：職場女性的自信蛻變
風格：都市時尚
→ 10個鏡頭：辦公室→化妝→走路→會議→微笑→特寫

**🚗 汽車廣告 (60秒)**
產品：電動SUV
需求：週末家庭出遊的快樂時光
風格：溫馨自然
→ 18個鏡頭：出發→公路→風景→抵達→玩耍→回程

───────────────────────
想創作哪種風格？`, [
        { text: '☕ 類似咖啡廣告', action: () => { adState.style = '溫暖治愈'; startAdCreation(); } },
        { text: '💄 類似美妝廣告', action: () => { adState.style = '都市時尚'; startAdCreation(); } },
        { text: '🚗 類似汽車廣告', action: () => { adState.style = '溫馨自然'; startAdCreation(); } },
        { text: '🎨 自定義風格', action: () => startAdCreation() }
    ]);
}

// 第1轮：信息收集
function startAdCreation() {
    adState.step = 1;
    
    addAIMessage(`🎬 **第1步：告訴我你的廣告需求**

請提供以下信息：

**1️⃣ 產品/品牌**（必填）
上傳產品圖片，或描述你的產品

**2️⃣ 一句話需求**（必填）
例如：「咖啡廣告，展現清晨醒腦的儀式感」

**3️⃣ 廣告時長**
<div class="ad-duration-select" style="display:flex;gap:8px;margin:12px 0;">
    <button class="duration-btn ${adState.duration === 15 ? 'active' : ''}" onclick="selectAdDuration(15)">
        <div style="font-size:20px;margin-bottom:4px;">⚡</div>
        <div>15秒</div>
        <div style="font-size:10px;color:var(--text2);">6個鏡頭</div>
    </button>
    <button class="duration-btn ${adState.duration === 30 ? 'active' : ''}" onclick="selectAdDuration(30)">
        <div style="font-size:20px;margin-bottom:4px;">📱</div>
        <div>30秒</div>
        <div style="font-size:10px;color:var(--text2);">8-10鏡頭</div>
    </button>
    <button class="duration-btn ${adState.duration === 60 ? 'active' : ''}" onclick="selectAdDuration(60)">
        <div style="font-size:20px;margin-bottom:4px;">🎬</div>
        <div>60秒</div>
        <div style="font-size:10px;color:var(--text2);">12-18鏡頭</div>
    </button>
</div>

<style>
.duration-btn {
    flex:1; padding:12px; background:var(--surface); border:1px solid var(--border); border-radius:8px;
    color:var(--text); cursor:pointer; text-align:center; transition:all 0.2s;
}
.duration-btn:hover { border-color:var(--accent); }
.duration-btn.active { background:rgba(99,102,241,0.15); border-color:var(--accent); color:var(--accent); }
</style>

**4️⃣ 演員（可選）**
上傳演員照片，或讓AI設計虛擬角色

───────────────────────
請在下方輸入你的**一句話需求**，並上傳產品圖：`, [
        { text: '📷 上傳產品圖', action: () => uploadAdImage('product') },
        { text: '👤 上傳演員圖', action: () => uploadAdImage('actor') },
        { text: '🤖 AI設計演員', action: () => designAIActor() }
    ]);
    
    // 设置等待用户输入状态
    adState.waitingFor = 'requirement';
}

function selectAdDuration(duration) {
    adState.duration = duration;
    // 更新按钮状态
    document.querySelectorAll('.duration-btn').forEach(btn => {
        btn.classList.toggle('active', btn.textContent.includes(duration + '秒'));
    });
    
    addUserMessage(`選擇廣告時長：${duration}秒`);
    addAIMessage(`✅ 已選擇 **${duration}秒** 廣告
    
鏡頭數量：${duration === 15 ? '6個' : duration === 30 ? '8-10個' : '12-18個'}
平均每鏡：${duration === 15 ? '2.5秒' : duration === 30 ? '3-3.5秒' : '3-5秒'}

請繼續輸入你的一句話需求，或上傳產品圖。`);
}

function uploadAdImage(type) {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        // 读取并显示图片
        const reader = new FileReader();
        reader.onload = (e) => {
            const base64 = e.target.result;
            
            if (type === 'product') {
                adState.productImage = base64;
                addUserMessage(`📷 已上傳產品圖：${file.name}`);
                addAIMessage(`✅ 產品圖已收到！

<img src="${base64}" style="max-width:200px;border-radius:8px;margin:8px 0;">

現在請告訴我你的**一句話需求**，例如：
「咖啡廣告，展現清晨醒腦的儀式感，目標受眾是都市白領」`);
            } else {
                adState.actorImages.push({ name: file.name, data: base64 });
                addUserMessage(`👤 已上傳演員圖：${file.name}`);
                addAIMessage(`✅ 演員圖已收到！（共 ${adState.actorImages.length} 張）

<img src="${base64}" style="max-width:150px;border-radius:8px;margin:8px 0;">`, [
                    { text: '👤 繼續上傳演員', action: () => uploadAdImage('actor') },
                    { text: '✅ 演員上傳完成', action: () => {} }
                ]);
            }
        };
        reader.readAsDataURL(file);
    };
    input.click();
}

function designAIActor() {
    addAIMessage(`🤖 **AI演員設計**

請描述你想要的演員形象：

**年齡範圍**: 20-25 / 25-30 / 30-40 / 40+
**性別**: 男 / 女 / 不限
**風格**: 陽光活潑 / 都市精英 / 鄰家親切 / 時尚潮流
**特徵**: 如「短髮、戴眼鏡、微笑」

例如：「25-30歲都市女性，短髮，職業裝，自信微笑」

請在下方輸入演員描述：`);
    adState.waitingFor = 'actor_design';
}

// 处理广告模式下的用户输入
async function handleAdInput(text) {
    if (adState.waitingFor === 'actor_design') {
        adState.actorImages.push({ name: 'AI設計', description: text, type: 'ai_generated' });
        addAIMessage(`✅ 已記錄AI演員描述：

「${text}」

稍後會根據此描述生成演員形象。`, [
            { text: '👤 添加更多演員', action: () => designAIActor() },
            { text: '✅ 演員設定完成', action: () => checkAdReadyForStrategy() }
        ]);
        adState.waitingFor = 'requirement';
        return;
    }
    
    if (adState.waitingFor === 'requirement' || adState.step === 1) {
        adState.requirement = text;
        addAIMessage(`✅ 收到你的需求：

「${text}」

**當前設定**：
- 產品圖：${adState.productImage ? '✅ 已上傳' : '❌ 未上傳'}
- 演員：${adState.actorImages.length > 0 ? `✅ ${adState.actorImages.length} 個` : '❌ 未設定'}
- 時長：${adState.duration}秒
- 風格：${adState.style || '待AI推薦'}`, [
            { text: '🚀 開始生成分鏡', action: () => runAdStrategy() },
            { text: '📷 補充產品圖', action: () => uploadAdImage('product') },
            { text: '👤 補充演員', action: () => uploadAdImage('actor') }
        ]);
        return;
    }
    
    // 其他情况：可能是修改反馈
    if (adState.step === 5) {
        handleAdFeedback(text);
    }
}

function checkAdReadyForStrategy() {
    if (!adState.requirement) {
        addAIMessage(`請先輸入你的一句話需求！`);
        return;
    }
    
    addAIMessage(`✅ 信息收集完成！

**廣告概要**：
- 需求：${adState.requirement}
- 時長：${adState.duration}秒
- 產品圖：${adState.productImage ? '✅' : '❌ (可稍後補充)'}
- 演員：${adState.actorImages.length}個

準備好了嗎？`, [
        { text: '🚀 開始生成分鏡', action: () => runAdStrategy() },
        { text: '✏️ 修改設定', action: () => startAdCreation() }
    ]);
}

// 第2轮：策略分析
async function runAdStrategy() {
    adState.step = 2;
    
    // 显示Agent状态
    const persona = AD_AGENT_PERSONAS.ad_strategy;
    addAIMessage(`${persona.avatar} **${persona.name}** ${persona.phrases.start}

<div class="agent-progress">
    <div class="step active">1. 提煉產品賣點</div>
    <div class="step">2. 構建受眾畫像</div>
    <div class="step">3. 情緒關鍵詞</div>
    <div class="step">4. 敘事建議</div>
</div>

<style>
.agent-progress { display:flex; flex-direction:column; gap:6px; margin:12px 0; padding:12px; background:var(--surface); border-radius:8px; }
.agent-progress .step { font-size:12px; color:var(--text2); padding:4px 8px; }
.agent-progress .step.active { color:var(--accent); font-weight:500; }
.agent-progress .step.done { color:#4ade80; }
.agent-progress .step.done::before { content:'✓ '; }
</style>`);
    
    try {
        // 调用策略Agent
        const strategyPrompt = `作為廣告策略師，分析以下廣告需求：

需求：${adState.requirement}
時長：${adState.duration}秒
${adState.style ? `期望風格：${adState.style}` : ''}
${adState.actorImages.length > 0 ? `演員數量：${adState.actorImages.length}` : ''}

請輸出JSON格式的創意簡報：
{
    "product_insight": "產品核心賣點（3-5個）",
    "target_audience": {
        "age": "年齡範圍",
        "gender": "性別",
        "lifestyle": "生活方式",
        "pain_points": ["痛點1", "痛點2"]
    },
    "emotion_keywords": ["情緒1", "情緒2", "情緒3"],
    "narrative_suggestion": "敘事方向建議",
    "recommended_style": "推薦視覺風格",
    "main_slogan": "主Slogan建議"
}`;
        
        const result = await callAgent('ad_strategy', strategyPrompt, {});
        const brief = safeJSONParse(result, 'ad_strategy');
        adState.assets.creativeBrief = brief;
        
        // 显示策略结果
        addAIMessage(`${persona.avatar} **策略分析完成！**

**📦 產品賣點**
${brief.product_insight || '(分析中...)'}

**👥 目標受眾**
${brief.target_audience ? `
- 年齡：${brief.target_audience.age || '25-35歲'}
- 性別：${brief.target_audience.gender || '不限'}
- 生活方式：${brief.target_audience.lifestyle || '都市白領'}
- 痛點：${(brief.target_audience.pain_points || []).join('、')}
` : '(分析中...)'}

**💭 情緒關鍵詞**
${(brief.emotion_keywords || ['溫暖', '治愈', '儀式感']).join(' · ')}

**📝 敘事建議**
${brief.narrative_suggestion || '(生成中...)'}

**🎨 推薦風格**
${brief.recommended_style || adState.style || '溫暖治愈'}

**✨ 主Slogan**
「${brief.main_slogan || '(待生成)'}」

───────────────────────
策略方向確認後，將進入分鏡設計階段。`, [
            { text: '✅ 確認，開始設計分鏡', action: () => runAdStoryboard() },
            { text: '✏️ 調整策略方向', action: () => adjustAdStrategy() },
            { text: '🔄 重新生成', action: () => runAdStrategy() }
        ]);
        
    } catch (err) {
        console.error('策略分析失敗:', err);
        addAIMessage(`❌ 策略分析遇到問題，請重試。`, [
            { text: '🔄 重試', action: () => runAdStrategy() }
        ]);
    }
}

function adjustAdStrategy() {
    addAIMessage(`✏️ **調整策略方向**

請告訴我你想修改什麼：
- 目標受眾
- 情緒基調
- 敘事方向
- Slogan

或直接輸入你的想法：`);
    adState.waitingFor = 'strategy_adjust';
}

// 第3轮：分镜设计
async function runAdStoryboard() {
    adState.step = 3;
    
    const visualPersona = AD_AGENT_PERSONAS.ad_visual;
    const copyPersona = AD_AGENT_PERSONAS.ad_copywriter;
    
    // 计算镜头数
    const shotCount = adState.duration === 15 ? 6 : adState.duration === 30 ? 10 : 15;
    
    addAIMessage(`${visualPersona.avatar} **${visualPersona.name}** + ${copyPersona.avatar} **${copyPersona.name}** 協同創作中...

正在設計 **${shotCount}** 個鏡頭的分鏡腳本...

<div class="agent-progress">
    <div class="step active">1. 拆解鏡頭結構</div>
    <div class="step">2. 設計景別/角度/運鏡</div>
    <div class="step">3. 撰寫畫面描述</div>
    <div class="step">4. 配置文案/旁白</div>
</div>`);
    
    try {
        const brief = adState.assets.creativeBrief || {};
        
        const storyboardPrompt = `作為廣告分鏡師，為以下廣告設計專業分鏡表：

【廣告信息】
需求：${adState.requirement}
時長：${adState.duration}秒
鏡頭數：${shotCount}個
風格：${brief.recommended_style || adState.style || '溫暖治愈'}
Slogan：${brief.main_slogan || ''}

【創意簡報】
賣點：${brief.product_insight || ''}
受眾：${JSON.stringify(brief.target_audience || {})}
情緒：${(brief.emotion_keywords || []).join('、')}
敘事：${brief.narrative_suggestion || ''}

請輸出JSON數組，每個鏡頭包含11個字段：
[
    {
        "shot_id": "SC-01",
        "scene_type": "景別：特寫/近景/中景/全景/遠景",
        "angle": "角度：平視/仰視/俯視/斜角",
        "camera_move": "運鏡：固定/推/拉/搖/移/跟/升/降",
        "description": "詳細畫面描述（30-50字）",
        "product_show": "產品出現方式",
        "actor": "演員/角色動作表情",
        "props_scene": "道具和場景元素",
        "color_lighting": "色彩和光影",
        "copy": "文案/旁白/對話",
        "duration": 3
    }
]

嚴格輸出${shotCount}個鏡頭！`;

        const result = await callAgent('ad_director', storyboardPrompt, {});
        let storyboard = safeJSONParse(result, 'ad_storyboard');
        
        // 确保是数组
        if (!Array.isArray(storyboard)) {
            storyboard = storyboard.shots || storyboard.storyboard || [];
        }
        
        adState.assets.storyboard = storyboard;
        
        // 显示分镜结果
        let storyboardHtml = storyboard.map((shot, i) => `
<div class="ad-shot-card">
    <div class="shot-header">
        <span class="shot-num">${shot.shot_id || `SC-${String(i+1).padStart(2,'0')}`}</span>
        <span class="shot-duration">${shot.duration || 3}秒</span>
    </div>
    <div class="shot-body">
        <div class="shot-row"><b>景別</b> ${shot.scene_type || '-'}</div>
        <div class="shot-row"><b>角度</b> ${shot.angle || '-'}</div>
        <div class="shot-row"><b>運鏡</b> ${shot.camera_move || '-'}</div>
        <div class="shot-row"><b>畫面</b> ${shot.description || '-'}</div>
        <div class="shot-row"><b>產品</b> ${shot.product_show || '-'}</div>
        <div class="shot-row"><b>演員</b> ${shot.actor || '-'}</div>
        <div class="shot-row"><b>光影</b> ${shot.color_lighting || '-'}</div>
        <div class="shot-row"><b>文案</b> 「${shot.copy || '-'}」</div>
    </div>
</div>
        `).join('');
        
        addAIMessage(`${visualPersona.avatar}${copyPersona.avatar} **分鏡設計完成！**

共 **${storyboard.length}** 個鏡頭，總時長 **${adState.duration}秒**

<style>
.ad-shot-card { background:var(--surface); border:1px solid var(--border); border-radius:8px; margin:8px 0; overflow:hidden; }
.shot-header { display:flex; justify-content:space-between; padding:8px 12px; background:var(--surface2); border-bottom:1px solid var(--border); }
.shot-num { color:var(--accent); font-weight:600; }
.shot-duration { color:var(--text2); font-size:12px; }
.shot-body { padding:10px 12px; font-size:12px; }
.shot-row { margin:4px 0; }
.shot-row b { color:var(--text2); display:inline-block; width:40px; }
</style>

${storyboardHtml}

───────────────────────
分鏡確認後可以：
1. 生成預覽圖
2. 導出分鏡表
3. 進入FizzStudio製作`, [
            { text: '🖼️ 生成預覽圖', action: () => generateAdPreviews() },
            { text: '📊 導出Excel', action: () => exportAdStoryboard() },
            { text: '✏️ 修改某個鏡頭', action: () => editAdShot() },
            { text: '🚀 導入FizzStudio', action: () => importAdToFizzStudio() }
        ]);
        
        // 保存项目
        saveAdProject();
        
    } catch (err) {
        console.error('分鏡設計失敗:', err);
        addAIMessage(`❌ 分鏡設計遇到問題，請重試。`, [
            { text: '🔄 重試', action: () => runAdStoryboard() }
        ]);
    }
}

function editAdShot() {
    addAIMessage(`✏️ **修改鏡頭**

請輸入要修改的內容，格式：
「鏡頭X：修改要求」

例如：
- 「鏡頭3：把俯視改成平視」
- 「鏡頭5：文案改成'開啟美好一天'」
- 「鏡頭2：增加產品特寫」`);
    adState.waitingFor = 'shot_edit';
}

// 第4轮：生成预览
async function generateAdPreviews() {
    adState.step = 4;
    
    addAIMessage(`🖼️ **生成預覽圖**

正在為 ${adState.assets.storyboard.length} 個鏡頭生成預覽圖...

⚠️ 此功能需要連接圖像生成API（如DALL-E、Midjourney、Stable Diffusion）

當前為**預覽模式**，將輸出圖像生成Prompt供您在其他平台使用。`, [
        { text: '📋 輸出所有Prompt', action: () => outputAdPrompts() },
        { text: '📊 直接導出分鏡表', action: () => exportAdStoryboard() }
    ]);
}

function outputAdPrompts() {
    const storyboard = adState.assets.storyboard || [];
    const brief = adState.assets.creativeBrief || {};
    
    let promptsHtml = storyboard.map((shot, i) => {
        // 构建图像生成Prompt
        const imagePrompt = `${brief.recommended_style || 'cinematic'} advertisement shot, ${shot.scene_type || 'medium shot'}, ${shot.angle || 'eye level'}, ${shot.description || ''}, ${shot.color_lighting || 'soft natural lighting'}, professional commercial photography, 8k, high quality`;
        
        return `
<div class="prompt-card">
    <div class="prompt-header">
        <span>${shot.shot_id || `SC-${i+1}`}</span>
        <button class="copy-btn" onclick="copyText(this, \`${imagePrompt.replace(/`/g, "'")}\`)">📋 複製</button>
    </div>
    <div class="prompt-text">${imagePrompt}</div>
</div>
        `;
    }).join('');
    
    addAIMessage(`📋 **圖像生成Prompts**

以下Prompt可用於Midjourney、DALL-E、Stable Diffusion等平台：

<style>
.prompt-card { background:var(--surface); border:1px solid var(--border); border-radius:8px; margin:8px 0; overflow:hidden; }
.prompt-header { display:flex; justify-content:space-between; align-items:center; padding:8px 12px; background:var(--surface2); }
.prompt-text { padding:10px 12px; font-size:11px; color:var(--text2); line-height:1.5; font-family:monospace; }
.copy-btn { background:transparent; border:1px solid var(--border); color:var(--text2); padding:4px 8px; border-radius:4px; cursor:pointer; font-size:11px; }
.copy-btn:hover { border-color:var(--accent); color:var(--accent); }
</style>

${promptsHtml}`, [
        { text: '📊 導出Excel', action: () => exportAdStoryboard() },
        { text: '🚀 導入FizzStudio', action: () => importAdToFizzStudio() }
    ]);
}

// 第5轮：修改与导出
function handleAdFeedback(text) {
    // 解析用户的修改请求
    const shotMatch = text.match(/鏡頭(\d+)/i);
    if (shotMatch) {
        const shotNum = parseInt(shotMatch[1]) - 1;
        if (shotNum >= 0 && shotNum < adState.assets.storyboard.length) {
            addAIMessage(`✏️ 正在修改 **鏡頭${shotNum + 1}**...

原內容：
${JSON.stringify(adState.assets.storyboard[shotNum], null, 2)}

請稍候，AI正在根據您的要求修改...`);
            
            // TODO: 调用AI修改特定镜头
            return;
        }
    }
    
    addAIMessage(`請指定要修改的鏡頭編號，例如：「鏡頭3：把俯視改成平視」`);
}

// 导出广告分镜表
function exportAdStoryboard() {
    const storyboard = adState.assets.storyboard || [];
    if (storyboard.length === 0) {
        addAIMessage(`❌ 還沒有分鏡內容可導出！`);
        return;
    }
    
    // 构建CSV
    const headers = ['鏡號', '景別', '角度', '運鏡', '畫面描述', '產品出現', '演員動作', '道具場景', '色彩光影', '文案旁白', '時長'];
    const rows = storyboard.map(shot => [
        shot.shot_id || '',
        shot.scene_type || '',
        shot.angle || '',
        shot.camera_move || '',
        shot.description || '',
        shot.product_show || '',
        shot.actor || '',
        shot.props_scene || '',
        shot.color_lighting || '',
        shot.copy || '',
        shot.duration || 3
    ]);
    
    const csv = [headers, ...rows].map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')).join('\n');
    const BOM = '\uFEFF';
    const blob = new Blob([BOM + csv], { type: 'text/csv;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `廣告分鏡_${adState.duration}秒_${new Date().toISOString().slice(0,10)}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    
    addAIMessage(`✅ 分鏡表已導出！

文件：廣告分鏡_${adState.duration}秒_${new Date().toISOString().slice(0,10)}.csv
鏡頭數：${storyboard.length}
時長：${adState.duration}秒`, [
        { text: '🚀 導入FizzStudio', action: () => importAdToFizzStudio() },
        { text: '🆕 創建新廣告', action: () => startNewProject() }
    ]);
}

function importAdToFizzStudio() {
    addAIMessage(`🚀 **導入FizzStudio**

分鏡表已準備就緒！

FizzStudio將幫你：
1. 🖼️ 根據分鏡生成AI圖像
2. 🎬 生成動態視頻片段
3. 🎵 添加音樂和配音
4. ✂️ 自動剪輯合成

點擊下方按鈕前往FizzStudio：`, [
        { text: '🚀 打開FizzStudio', action: () => window.open('https://fizzdragon.com/studio', '_blank') },
        { text: '📥 先導出本地', action: () => exportAdStoryboard() }
    ]);
}

// 保存广告项目
function saveAdProject(name = null, silent = false) {
    const projects = getProjects();
    const projectName = name || `廣告_${adState.duration}秒_${Date.now()}`;
    const projectId = currentProjectId || 'ad_' + Date.now();
    currentProjectId = projectId;
    
    projects[projectId] = {
        id: projectId,
        name: projectName,
        type: 'ad',  // 标记为广告项目
        step: adState.step,
        timestamp: new Date().toISOString(),
        
        // 广告设定
        duration: adState.duration,
        style: adState.style,
        requirement: adState.requirement,
        productImage: adState.productImage,
        actorImages: adState.actorImages,
        
        // 广告资产
        adAssets: adState.assets
    };
    
    localStorage.setItem(getProjectsKey(), JSON.stringify(projects));
    renderProjectListByMode();
    
    if (!silent) {
        showSaveIndicator();
    }
    
    return projectId;
}

// ==================== 初始化 ====================
// 登出
function handleLogout() {
    const token = localStorage.getItem('fizzdragon_token');
    if (token) {
        fetch('/api/auth/logout', {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}` }
        }).catch(() => {});
    }
    localStorage.removeItem('fizzdragon_token');
    localStorage.removeItem('fizzdragon_user');
    // window.location.href = 'login.html'; // 内测模式：跳过登录
}

// 显示当前用户名
function showCurrentUser() {
    const user = JSON.parse(localStorage.getItem('fizzdragon_user') || 'null');
    if (user && user.username) {
        const el = document.getElementById('currentUsername');
        if (el) el.textContent = `👤 ${user.username}`;
    }
}

async function init() {
    console.log('🚀 init() 开始');
    showCurrentUser();
    
    // 初始化用户
    initUser();
    
    // 🔧 立即显示本地项目（不等云端）
    renderProjectList();
    
    // 🔧 先显示欢迎语，不等API检测
    showStartOptions();
    
    // 后台检测API（不阻塞）
    detectAPI().catch(err => console.warn('API检测失败:', err));
    
    // ☁️ 后台同步云端（完成后自动更新列表）
    syncProjectsFromBackend().catch(err => console.warn('云端恢复失败:', err));
    
    console.log('🚀 init() 完成');
}

function showStartOptions() {
    console.log('🏠 showStartOptions called, current state:', { mode: state.mode, step: state.step });
    
    // 🔧 修复Bug: 如果已经有进行中的工作，不要显示开始选项
    if (state.mode && state.step > 0) {
        console.log('⚠️ showStartOptions blocked: workflow already in progress');
        continueImportProject();
        return;
    }
    
    // 🔧 清空聊天容器，确保能显示欢迎消息
    const chatContainer = document.getElementById('chatContainer');
    chatContainer.innerHTML = '';
    
    // 使用多语言欢迎消息（包含按钮）
    showWelcome();
}

function showLearningResources() {
    addAIMessage(`📚 **FizzDragon 學習資源庫**

**敘事結構大師**
• Robert McKee《故事》- 價值轉換理論
• John Truby《The Anatomy of Story》- 22步結構
• Joseph Campbell《千面英雄》- 英雄之旅
• Christopher Vogler《作家之路》- 12階段旅程
• Blake Snyder《Save the Cat》- 15節拍表
• Syd Field《Screenplay》- 三幕劇結構

**角色設計理論**
• K.M. Weiland《Creating Character Arcs》
• Tom Bancroft《Creating Characters with Personality》
• 心理學動機理論 - 欲望/創傷/弧線

**視覺敘事**
• Steven D. Katz《Film Directing Shot by Shot》
• Gustavo Mercado《The Filmmaker's Eye》
• Francis Glebas《Directing the Story》

**大師訪談**
• Hitchcock/Truffaut 電影訪談錄
• Aaron Sorkin MasterClass
• 宮崎駿創作筆記

**文化風格**
• 中國電影美學 - 王家衛、李安、侯孝賢
• 日本動畫 - 宮崎駿、新海誠
• 好萊塢經典 - Spielberg、Nolan
• 歐洲藝術電影 - Fellini、Bergman

共 **100+** 本專業書籍融入系統。`, [
        { text: '🔙 返回', action: () => showStartOptions() }
    ]);
}

function resumeProgress(saved) {
    // 恢复状态
    writeState.idea = saved.idea;
    writeState.interview = saved.interview;
    writeState.outline = saved.outline;
    writeState.chapters = saved.chapters || [];
    writeState.storyboard = saved.storyboard;
    state.mode = 'write';
    
    const chs = saved.outline?.chapters || [];
    const completed = saved.chapters?.length || 0;
    
    if (completed >= chs.length) {
        addAIMessage(`✅ 小說已全部完成！

**《${saved.outline?.title}》** - ${completed} 章

接下來：`, [
            { text: '🎬 轉換分鏡', action: () => convertToStoryboard() },
            { text: '📥 導出小說', action: () => exportNovel() },
            { text: '📥 導出Excel', action: () => exportExcel() }
        ]);
    } else {
        writeState.currentChapter = completed;
        addAIMessage(`▶️ 繼續創作《${saved.outline?.title}》

**進度**: ${completed}/${chs.length} 章
**下一章**: 第${completed + 1}章 ${chs[completed]?.title || ''}`, [
            { text: `📝 繼續寫第${completed + 1}章`, action: () => writeNextChapter() },
            { text: '📖 查看大綱', action: () => showOutline() },
            { text: '📥 導出已完成', action: () => exportNovel() }
        ]);
    }
}

function showOutline() {
    const o = writeState.outline;
    const chs = o?.chapters || [];
    
    addAIMessage(`📝 **故事大綱**

**《${o?.title || '未命名'}》**
${o?.logline || ''}

---

${chs.map((c, i) => {
    const done = writeState.chapters[i] ? '✅' : '⬜';
    return `${done} 第${c.number}章 ${c.title}`;
}).join('\n')}`);
}

// ==================== API检测 ====================
async function detectAPI() {
    console.log('🔌 detectAPI() 开始检测...');
    setStatus('loading', '連接中...');
    
    for (const endpoint of API_ENDPOINTS) {
        console.log('🔌 尝试:', endpoint);
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000);
            const res = await fetch(`${endpoint}/health`, { 
                signal: controller.signal,
                mode: 'cors'
            });
            clearTimeout(timeoutId);
            
            if (res.ok) {
                const data = await res.json();
                API_BASE = endpoint;
                setStatus('online', t('connected'));
                console.log('✅ API连接成功:', endpoint, data.provider);
                return;
            }
        } catch (e) {
            console.log('❌ API失败:', endpoint, e.message);
        }
    }
    setStatus('offline', '連接失敗 - 請刷新重試');
    console.log('❌ 所有API端点都失败');
}

function setStatus(status, text) {
    const dot = document.getElementById('statusDot');
    const txt = document.getElementById('statusText');
    dot.className = 'status-dot ' + (status === 'online' ? '' : status === 'loading' ? 'loading' : 'offline');
    txt.textContent = text;
}

// ==================== 創作模式 ====================
// 写作访谈问题
const WRITE_QUESTIONS = [
    '這個故事想傳達什麼核心主題或情感？',
    '主角是什麼樣的人？有什麼特點和弱點？',
    '主角面臨的最大挑戰或衝突是什麼？',
    '故事發生在什麼時代和地點？有什麼獨特氛圍？',
    '你希望觀眾看完後有什麼感受？',
    '故事大概要多長？（短篇10章/中篇30章/長篇50-100章）',
    '有參考的作品風格嗎？（電影、劇集、小說）',
    '有特別想加入的場景或情節嗎？',
    '主要配角有哪些？和主角是什麼關係？',
    '故事有什麼獨特的世界觀設定嗎？'
];

function startWriteMode() {
    // 检查是否有进行中的工作
    if (hasActiveWork()) {
        confirmResetAndImport(() => {
            document.getElementById('chatContainer').innerHTML = '';
            doStartWriteMode();
        });
        return;
    }
    doStartWriteMode();
}

function doStartWriteMode() {
    state.mode = 'write';
    writeState.currentQuestion = -1;
    
    addAIMessage(`${t('writeMode')}

${t('writeModeDesc')}

${t('writeModePrompt')}`, [
        { text: t('randomGenerate'), action: () => randomIdea() },
        { text: t('seeExamples'), action: () => showExamples() }
    ]);
}

async function randomIdea() {
    addTypingIndicator();
    
    try {
        const result = await callAgent('concept', '請隨機生成一個有趣的短劇故事靈感，類型可以是靈異、愛情、懸疑、奇幻等，背景設定在香港。輸出JSON格式：{genre, setting, premise, hook}');
        removeTypingIndicator();
        
        const idea = safeJSONParse(result.replace(/```json\n?/g, '').replace(/```/g, ''), 'randomIdea');
        writeState.idea = idea;
        
        const genreLabel = currentLang === 'en' ? 'Genre' : '類型';
        const settingLabel = currentLang === 'en' ? 'Setting' : '背景';
        const storyLabel = currentLang === 'en' ? 'Story' : '故事';
        const hookLabel = currentLang === 'en' ? 'Hook' : '亮點';
        const likeItQ = currentLang === 'en' ? 'Like this direction?' : '喜歡這個方向嗎？';
        
        addAIMessage(`${t('randomIdea')}

**${genreLabel}**: ${idea.genre || 'TBD'}
**${settingLabel}**: ${idea.setting || 'TBD'}  
**${storyLabel}**: ${idea.premise || idea.logline || 'TBD'}
**${hookLabel}**: ${idea.hook || 'TBD'}

${likeItQ}`, [
            { text: t('likeThis'), action: () => startWriteInterview() },
            { text: t('tryAnother'), action: () => randomIdea() },
            { text: t('editIt'), action: () => {} }
        ]);
    } catch (err) {
        removeTypingIndicator();
        recordError(err, '隨機靈感');
        showFriendlyError(err, '隨機靈感', () => randomIdea());
    }
}

function showExamples() {
    addAIMessage(`${t('storyExamples')}

**${t('supernatural')}**
${t('supernaturalEx')}

**${t('romance')}**
${t('romanceEx')}

**${t('mystery')}**
${t('mysteryEx')}

**${t('fantasy')}**
${t('fantasyEx')}

${t('pickOrInput')}`, [
        { text: '🔮 ' + (currentLang === 'en' ? 'Diner' : '深夜食堂'), action: () => useExample(t('supernaturalEx').replace(/[「」""]/g, ''), t('supernatural')) },
        { text: '💕 ' + (currentLang === 'en' ? 'MTR Love' : '港鐵愛情'), action: () => useExample(t('romanceEx').replace(/[「」""]/g, ''), t('romance')) },
        { text: '🔍 ' + (currentLang === 'en' ? 'Mystery Floor' : '神秘樓層'), action: () => useExample(t('mysteryEx').replace(/[「」""]/g, ''), t('mystery')) }
    ]);
}

function useExample(premise, genre) {
    addUserMessage(premise);
    writeState.idea = { premise, genre };
    startWriteInterview();
}

// ==================== 写作访谈 ====================
function startWriteInterview() {
    writeState.currentQuestion = 0;
    writeState.interview = {};
    writeState.skipAll = false;  // 🔧 重置跳过标志
    
    addAIMessage(`好的！現在讓我了解更多細節，這會幫助我寫出更符合你想法的故事。

🎤 **創作訪談** (${WRITE_QUESTIONS.length} 個問題)`, [
        { text: '⏭️ 跳過所有訪談', action: () => { 
            writeState.skipAll = true;  // 🔧 设置跳过标志
            writeState.currentQuestion = WRITE_QUESTIONS.length; 
            finishWriteInterview(); 
        } }
    ]);
    
    setTimeout(() => askWriteQuestion(), 500);
}

function askWriteQuestion() {
    // 🔧 如果已跳过所有或问题已完成，直接返回
    if (writeState.skipAll || writeState.currentQuestion >= WRITE_QUESTIONS.length) {
        finishWriteInterview();
        return;
    }
    
    const q = WRITE_QUESTIONS[writeState.currentQuestion];
    const num = writeState.currentQuestion + 1;
    
    // 纯对话式：不显示按钮
    addAIMessage(`🎤 **創作訪談 (${num}/${WRITE_QUESTIONS.length})**

${q}`, [
        { text: '⏭️ 跳過這題', action: () => { handleUserInput('跳過'); } }
    ]);
}

async function finishWriteInterview() {
    // 🔧 先让用户设置制作规格
    showWriteProductionSettings();
}

// 🔧 创作模式的制作设置
function showWriteProductionSettings() {
    addAIMessage(`✅ 訪談完成！

在開始創作前，請設定你的**番劇規格**：

📺 **集數設定**
請輸入集數（例如：50）`, [
        { text: '10集（短篇）', action: () => setWriteEpisodes(10) },
        { text: '24集（標準番）', action: () => setWriteEpisodes(24) },
        { text: '50集（長篇）', action: () => setWriteEpisodes(50) }
    ]);
    
    writeState.productionStep = 0;
}

function setWriteEpisodes(num) {
    state.production.episodes = num;
    addUserMessage(`${num} 集`);
    
    addAIMessage(`✅ ${num} 集

⏱️ **每集時長**
請輸入每集時長（分鐘）`, [
        { text: '2分鐘（短視頻）', action: () => setWriteDuration(2) },
        { text: '5分鐘（標準番）', action: () => setWriteDuration(5) },
        { text: '10分鐘（劇情番）', action: () => setWriteDuration(10) }
    ]);
    
    writeState.productionStep = 1;
}

function setWriteDuration(min) {
    state.production.durationMin = min;
    addUserMessage(`${min} 分鐘/集`);
    
    addAIMessage(`✅ ${min} 分鐘/集

🎬 **鏡頭密度**
每分鐘多少個鏡頭？`, [
        { text: '8個/分鐘（慢節奏）', action: () => setWriteShots(8) },
        { text: '12個/分鐘（中等）', action: () => setWriteShots(12) },
        { text: '15個/分鐘（快節奏）', action: () => setWriteShots(15) }
    ]);
    
    writeState.productionStep = 2;
}

function setWriteShots(shots) {
    state.production.shotsPerMin = shots;
    addUserMessage(`${shots} 鏡頭/分鐘`);
    
    const totalMin = state.production.episodes * state.production.durationMin;
    const totalShots = totalMin * state.production.shotsPerMin;
    
    addAIMessage(`📊 **製作規格確認**

• 集數: ${state.production.episodes} 集
• 每集時長: ${state.production.durationMin} 分鐘
• 鏡頭密度: ${state.production.shotsPerMin} 個/分鐘
• **總時長**: ${totalMin} 分鐘
• **預計分鏡**: ${totalShots.toLocaleString()} 個

確認後開始創作！`, [
        { text: '✅ 確認，開始創作', action: () => startWriteCreation() },
        { text: '🔄 重新設定', action: () => showWriteProductionSettings() }
    ]);
    
    writeState.productionStep = 3;
}

async function startWriteCreation() {
    addAIMessage(`🚀 **開始創作！**

現在開始創作流程：
1️⃣ 生成高概念
2️⃣ 設計角色
3️⃣ 規劃章節（${state.production.episodes}集）
4️⃣ 設計服化道
5️⃣ 寫劇本

正在生成**高概念**...`);
    
    // 切换到导入模式的资产流程
    state.mode = 'write';
    state.step = 1;
    
    // 创建项目
    state.novelTitle = writeState.idea?.premise?.substring(0, 20) || '創作項目';
    currentProjectId = null;
    saveProject(state.novelTitle, true);
    
    // 用访谈内容生成高概念
    await generateWriteConcept();
}

// 写作模式 - 生成高概念
async function generateWriteConcept() {
    // 🔧 详细步骤显示
    const steps = [
        { text: '📡 連接概念生成器...', done: false, current: true },
        { text: '📚 載入narrative_complete Skill...', done: false },
        { text: '🤖 調用FizzDragon大模型...', done: false },
        { text: '📝 解析JSON結果...', done: false }
    ];
    showAgentStatus('💡 概念生成器', '正在初始化...', 'concept', steps);
    
    try {
        // 步骤1完成
        steps[0].done = true; steps[0].current = false;
        steps[1].current = true;
        showAgentStatus('💡 概念生成器', '載入敘事理論知識庫...', 'concept', steps);
        
        const prompt = `根據以下創作意圖，生成高概念分析：

故事靈感：${JSON.stringify(writeState.idea)}
創作者訪談：${JSON.stringify(writeState.interview)}

請輸出JSON：{genre, theme, tone, logline, hooks[], emotionalJourney}`;
        
        // 步骤2完成
        steps[1].done = true; steps[1].current = false;
        steps[2].current = true;
        showAgentStatus('💡 概念生成器', 'FizzDragon正在分析故事結構...', 'concept', steps);
        
        const result = await callAgent('concept', prompt);
        
        // 步骤3完成
        steps[2].done = true; steps[2].current = false;
        steps[3].current = true;
        showAgentStatus('💡 概念生成器', '解析高概念JSON...', 'concept', steps);
        
        const concept = safeJSONParse(result, 'concept');
        
        // 全部完成
        steps[3].done = true; steps[3].current = false;
        
        state.assets.concept = concept;
        state.novelTitle = concept.title || writeState.idea?.premise?.substring(0, 20) || '創作項目';
        state.step = 1;
        
        removeTypingIndicator();
        hideAgentStatus();
        
        addAIMessage(`💡 **高概念生成完成！**

**類型**: ${concept.genre || '-'}
**主題**: ${concept.theme || '-'}
**基調**: ${concept.tone || '-'}
**Logline**: ${concept.logline || '-'}

───────────────────────
✅ 已存入項目資產

接下來進行**角色設計**...`);
        
        saveProject(state.novelTitle, true);
        
        // 进入角色设计
        setTimeout(() => generateWriteCharacters(), 1000);
        
    } catch (err) {
        removeTypingIndicator();
        hideAgentStatus();
        showFriendlyError(err, '高概念生成', () => generateWriteConcept());
    }
}

// 写作模式 - 生成角色
async function generateWriteCharacters() {
    state.step = 2;
    
    // 🔧 详细步骤显示
    const steps = [
        { text: '📡 連接角色設計師...', done: false, current: true },
        { text: '📚 載入character_complete Skill...', done: false },
        { text: '🤖 調用FizzDragon大模型...', done: false },
        { text: '📝 解析角色JSON...', done: false }
    ];
    showAgentStatus('👤 角色設計師', '正在初始化...', 'character', steps);
    
    try {
        steps[0].done = true; steps[0].current = false;
        steps[1].current = true;
        showAgentStatus('👤 角色設計師', '載入角色設計方法論...', 'character', steps);
        
        const prompt = `根據以下高概念，設計主要角色：

高概念：${JSON.stringify(state.assets.concept)}
故事靈感：${JSON.stringify(writeState.idea)}
創作者訪談：${JSON.stringify(writeState.interview)}

請設計3-5個主要角色，輸出JSON：{characters: [{name, role, bio, appearance, prompt}]}`;
        
        steps[1].done = true; steps[1].current = false;
        steps[2].current = true;
        showAgentStatus('👤 角色設計師', 'FizzDragon正在設計角色...', 'character', steps);
        
        const result = await callAgent('character', prompt);
        
        steps[2].done = true; steps[2].current = false;
        steps[3].current = true;
        showAgentStatus('👤 角色設計師', '解析角色資料...', 'character', steps);
        
        const charData = safeJSONParse(result, 'characters');
        steps[3].done = true; steps[3].current = false;
        
        state.assets.characters = charData.characters || [];
        
        removeTypingIndicator();
        hideAgentStatus();
        
        const charList = state.assets.characters.map(c => `• **${c.name}** (${c.role})`).join('\n');
        
        addAIMessage(`👤 **角色設計完成！**

${charList}

───────────────────────
✅ 已存入項目資產

接下來進行**製作規格設定**...`);
        
        saveProject(null, true);
        
        // 进入制作规格设置（和导入模式共用）
        setTimeout(() => runProductionEvaluation(), 1000);
        
    } catch (err) {
        removeTypingIndicator();
        hideAgentStatus();
        showFriendlyError(err, '角色設計', () => generateWriteCharacters());
    }
}

// ==================== 生成大纲 ====================
async function generateOutline() {
    addProgressCard('生成故事大綱', 0);
    
    try {
        const context = {
            idea: writeState.idea,
            interview: writeState.interview
        };
        
        const prompt = `根據以下創作者訪談，生成一個完整的故事大綱。

故事靈感：${JSON.stringify(writeState.idea)}
創作者回答：${JSON.stringify(writeState.interview)}

請輸出JSON格式：
{
  "title": "故事標題",
  "logline": "一句話概括",
  "genre": "類型",
  "setting": "背景設定",
  "theme": "核心主題",
  "chapters": [
    {"number": 1, "title": "章節標題", "summary": "劇情概要（50字）", "hook": "章節亮點"}
  ]
}

要求：
- 根據故事複雜度，可以10-100章
- 每章有明確的劇情推進
- 每5-10章一個小高潮
- 結尾要有大高潮和收尾
- 如果是長篇，先規劃大綱結構（序幕/開端/發展/高潮/結局）`;
        
        updateProgress(30);
        const result = await callAgent('narrative', prompt, context);
        updateProgress(100);
        
        writeState.outline = safeJSONParse(result.replace(/```json\n?/g, '').replace(/```/g, ''), 'outline');
        
        removeProgressCard();
        
        const o = writeState.outline;
        const chs = o.chapters || [];
        
        addAIMessage(`📝 **故事大綱**

**《${o.title || '未命名'}》**
${o.logline || ''}

**類型**: ${o.genre || '待定'}
**背景**: ${o.setting || '待定'}
**主題**: ${o.theme || '待定'}

---

**章節規劃** (共${chs.length}章)：

${chs.slice(0, 5).map(c => `**第${c.number}章 ${c.title}**\n${c.summary}`).join('\n\n')}
${chs.length > 5 ? `\n\n...還有 ${chs.length - 5} 章` : ''}

---

確認大綱後，我會**逐章寫作**。`, [
            { text: '✅ 開始寫第1章', action: () => startWritingChapters() },
            { text: '📝 調整大綱', action: () => showAdjustWarning('outline', 3) },
            { text: '💾 保存大綱', action: () => saveProgress('outline') }
        ]);
        
    } catch (err) {
        removeProgressCard();
        recordError(err, '大綱生成');
        showFriendlyError(err, '大綱生成', () => generateOutline());
    }
}

// ==================== 逐章写作 ====================
async function startWritingChapters() {
    writeState.currentChapter = 0;
    writeState.chapters = [];
    await writeNextChapter();
}

async function writeNextChapter() {
    const outline = writeState.outline;
    const chs = outline.chapters || [];
    
    if (writeState.currentChapter >= chs.length) {
        finishWriting();
        return;
    }
    
    const ch = chs[writeState.currentChapter];
    const num = writeState.currentChapter + 1;
    const total = chs.length;
    
    addProgressCard(`寫作第${num}章：${ch.title}`, 0);
    
    try {
        // ========== 智能上下文构建 ==========
        
        // 1. 故事大纲（精简版）
        const outlineContext = `【故事大綱】
標題：${outline.title}
類型：${outline.genre || ''}
主題：${outline.theme || ''}
一句話：${outline.logline || ''}`;
        
        // 2. 人物小传（如果有）
        let characterContext = '';
        if (state.characters?.characters) {
            const mainChars = state.characters.characters.slice(0, 3);
            characterContext = `\n【主要人物】\n` + mainChars.map(c => 
                `${c.name}(${c.role || '角色'}): ${c.psychology?.want || ''} / ${c.psychology?.wound || ''}`
            ).join('\n');
        }
        
        // 3. 前文回顾（最近2-3章的结尾）
        let prevContext = '';
        if (writeState.chapters.length > 0) {
            const recentChapters = writeState.chapters.slice(-3);
            prevContext = `\n【前情回顧】\n` + recentChapters.map(c => {
                const ending = c.content.slice(-800);  // 取每章最后800字
                return `第${c.number}章《${c.title}》結尾：\n${ending}`;
            }).join('\n---\n');
        }
        
        // 4. 前后章节预览
        let surroundingContext = '\n【章節脈絡】\n';
        if (num > 1) {
            const prevCh = chs[num - 2];
            surroundingContext += `上一章(${num-1})：${prevCh.title} - ${prevCh.summary}\n`;
        }
        surroundingContext += `▶ 本章(${num})：${ch.title} - ${ch.summary}\n`;
        if (num < total) {
            const nextCh = chs[num];
            surroundingContext += `下一章(${num+1})：${nextCh.title} - ${nextCh.summary}\n`;
        }
        surroundingContext += `章節亮點：${ch.hook || '無'}`;
        
        // 5. 构建完整prompt
        const prompt = `你是專業小說作家。請撰寫第${num}章（共${total}章）。

${outlineContext}
${characterContext}
${surroundingContext}
${prevContext ? prevContext.substring(0, 2000) : ''}

【寫作要求】
- 字數：1500-2500字
- 包含場景描寫、對話、心理活動
- 保持人物性格一致
- 承接上文，鋪墊下文
- 章節結尾留懸念或情感高潮
- 直接輸出正文，不要標題和解釋`;

        updateProgress(50);
        const result = await callAgent('screenwriter', prompt);
        updateProgress(100);
        
        // 保存章节
        writeState.chapters.push({
            number: num,
            title: ch.title,
            content: result,
            timestamp: new Date().toISOString()
        });
        
        // ========== 自动保存 ==========
        autoSaveProject();
        
        removeProgressCard();
        
        const wordsWritten = result.length;
        const totalWords = writeState.chapters.reduce((sum, c) => sum + c.content.length, 0);
        
        addAIMessage(`✅ **第${num}章《${ch.title}》** 完成！

${result.substring(0, 400)}...

---
📊 本章 ${wordsWritten} 字 | 總計 ${totalWords.toLocaleString()} 字
📈 進度 ${num}/${total} 章 (${Math.round(num/total*100)}%)`, [
            { text: `▶️ 繼續第${num + 1}章`, action: () => { writeState.currentChapter++; writeNextChapter(); } },
            { text: '📖 閱讀全文', action: () => showChapterContent(num) },
            { text: '✏️ 修改本章', action: () => editChapter(num) },
            { text: '⏸️ 暫停', action: () => pauseWriting() }
        ]);
        
    } catch (err) {
        removeProgressCard();
        // 保存已有进度
        autoSaveProject();
        const info = friendlyError(err, '章節寫作');
        addAIMessage(`${info.title} - 第${num}章

**可能原因**: ${info.reason}

✅ **好消息**: 已自動保存前${num-1}章的進度！

**建議**:
${info.solutions.slice(0, 2).map(s => `• ${s}`).join('\n')}`, [
            { text: '🔄 重試本章', action: () => writeNextChapter() },
            { text: '📂 查看已保存項目', action: () => showProjectList() }
        ]);
    }
}

// 自动保存（静默）
function autoSaveProject() {
    const projects = getProjects();
    const projectName = writeState.outline?.title || `項目_${Date.now()}`;
    const projectId = projectName.replace(/\s+/g, '_').toLowerCase();
    
    projects[projectId] = {
        id: projectId,
        name: projectName,
        stage: 'write',
        timestamp: new Date().toISOString(),
        idea: writeState.idea,
        interview: writeState.interview,
        outline: writeState.outline,
        chapters: writeState.chapters,
        writeStoryboard: writeState.storyboard,
        novel: state.novel,
        novelTitle: state.novelTitle,
        concept: state.concept,
        characters: state.characters
    };
    
    localStorage.setItem(getProjectsKey(), JSON.stringify(projects));
    console.log(`💾 自動保存: ${projectName} (${writeState.chapters.length}章)`);
}

// 显示章节内容
function showChapterContent(num) {
    const ch = writeState.chapters.find(c => c.number === num);
    if (!ch) return;
    
    addAIMessage(`📖 **第${num}章《${ch.title}》**

${ch.content}

---
字數：${ch.content.length}`, [
        { text: '✏️ 修改', action: () => editChapter(num) },
        { text: '🔙 返回', action: () => {} }
    ]);
}

// 编辑章节
function editChapter(num) {
    const ch = writeState.chapters.find(c => c.number === num);
    if (!ch) return;
    
    addAIMessage(`✏️ **編輯第${num}章**

請直接輸入修改意見或新的內容：
- 輸入「重寫」- 重新生成整章
- 輸入修改意見 - AI幫你修改
- 直接貼上新內容 - 替換整章`, [
        { text: '🔄 重寫整章', action: () => rewriteChapter(num) },
        { text: '🔙 取消', action: () => {} }
    ]);
    
    // 设置编辑状态
    state.editingChapter = num;
}

async function rewriteChapter(num) {
    // 删除这章，重新写
    writeState.chapters = writeState.chapters.filter(c => c.number !== num);
    writeState.currentChapter = num - 1;
    await writeNextChapter();
}

function pauseWriting() {
    saveProgress('chapters');
    addAIMessage(`⏸️ 已暫停寫作

**進度**: ${writeState.chapters.length}/${writeState.outline?.chapters?.length || 0} 章已完成

隨時可以繼續：`, [
        { text: '▶️ 繼續寫作', action: () => { writeState.currentChapter++; writeNextChapter(); } },
        { text: '🎬 先生成分鏡', action: () => convertToStoryboard() },
        { text: '📥 導出已完成章節', action: () => exportNovel() }
    ]);
}

function finishWriting() {
    const totalWords = writeState.chapters.reduce((sum, c) => sum + c.content.length, 0);
    
    addAIMessage(`🎉 **小說寫作完成！**

**《${writeState.outline?.title || '未命名'}》**
- 共 ${writeState.chapters.length} 章
- 約 ${totalWords.toLocaleString()} 字

接下來可以：`, [
        { text: '🎬 轉換成分鏡', action: () => convertToStoryboard() },
        { text: '📥 導出小說', action: () => exportNovel() },
        { text: '💾 保存全部', action: () => saveProgress('complete') }
    ]);
}

// ==================== 转分镜 ====================
async function convertToStoryboard() {
    addProgressCard('轉換為分鏡表', 0);
    
    try {
        const novelText = writeState.chapters.map(c => `【第${c.number}章 ${c.title}】\n${c.content}`).join('\n\n');
        
        state.novel = novelText;
        state.novelTitle = writeState.outline?.title || '未命名';
        state.concept = writeState.outline;
        
        updateProgress(30);
        
        // 先生成角色
        const charResult = await callAgent('character', novelText.substring(0, 4000));
        state.characters = safeJSONParse(charResult.replace(/```json\n?/g, '').replace(/```/g, ''), 'characters');
        
        updateProgress(60);
        
        // 生成分镜
        const sbResult = await callAgent('storyboard', novelText.substring(0, 3000), {
            concept: state.concept,
            characters: state.characters
        });
        
        writeState.storyboard = sbResult;
        state.storyboard = sbResult;
        
        updateProgress(100);
        removeProgressCard();
        
        addAIMessage(`🎬 **分鏡表生成完成！**

角色：${(state.characters?.characters || []).length} 個
分鏡：已生成

全部資料準備就緒！`, [
            { text: '📥 導出Excel', action: () => exportExcel() },
            { text: '📥 導出JSON', action: () => exportAll() },
            { text: '💾 保存項目', action: () => saveProgress('complete') }
        ]);
        
    } catch (err) {
        removeProgressCard();
        recordError(err, '分鏡轉換');
        showFriendlyError(err, '分鏡轉換', () => convertToStoryboard());
    }
}

// ==================== 项目管理 ====================
// 用户级项目隔离 - 每个用户有独立的项目存储
function getProjectsKey() {
    // 使用固定key，确保项目持久化（内测阶段不做用户隔离）
    return 'fizzdragon_projects';
}

// 获取当前用户ID（用于后端存储）
function getCurrentUserId() {
    const user = JSON.parse(localStorage.getItem('fizzdragon_user') || 'null');
    return user?.id || user?.username || 'guest';
}

// 🔄 同步项目到后端
async function syncProjectToBackend(projectId, projectData) {
    try {
        const userId = getCurrentUserId();
        await fetch(`${API_BASE}/user-projects/${userId}/${projectId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(projectData)
        });
        console.log(`☁️ 已同步到云端: ${projectId}`);
    } catch (e) {
        console.warn('云端同步失败（本地已保存）:', e.message);
    }
}

// 🔄 从后端恢复所有项目（后台执行，完成后更新UI）
async function syncProjectsFromBackend(retries = 2) {
    for (let attempt = 1; attempt <= retries; attempt++) {
        try {
            const userId = getCurrentUserId();
            console.log(`☁️ 后台同步 (${attempt}/${retries})...`);
            
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 10000); // 10秒超时
            
            const response = await fetch(`${API_BASE}/user-projects/${userId}`, {
                signal: controller.signal
            });
            clearTimeout(timeout);
            
            if (!response.ok) continue;
            
            const backendProjects = await response.json();
            const localProjects = JSON.parse(localStorage.getItem(getProjectsKey()) || '{}');
            
            // 合并：后端优先（按timestamp判断）
            let merged = { ...localProjects };
            let syncCount = 0;
            
            for (const [id, proj] of Object.entries(backendProjects)) {
                if (!merged[id] || new Date(proj.timestamp) > new Date(merged[id].timestamp || 0)) {
                    merged[id] = proj;
                    syncCount++;
                }
            }
            
            localStorage.setItem(getProjectsKey(), JSON.stringify(merged));
            
            // 🔧 有新项目时更新UI
            if (syncCount > 0) {
                console.log(`☁️ 云端恢复 ${syncCount} 个项目`);
                renderProjectList(); // 更新侧边栏
            }
            
            return; // 成功
            
        } catch (e) {
            console.warn(`☁️ 同步失败 (${attempt}/${retries}):`, e.message);
            if (attempt < retries) {
                await new Promise(r => setTimeout(r, 2000));
            }
        }
    }
}

function getProjects() {
    try {
        const userKey = getProjectsKey();
        let projects = JSON.parse(localStorage.getItem(userKey) || '{}');
        
        // 🔧 迁移旧数据：检查旧的全局key是否有数据
        const oldKey = 'fizzdragon_projects';
        const oldData = localStorage.getItem(oldKey);
        if (oldData && Object.keys(projects).length === 0) {
            try {
                const oldProjects = JSON.parse(oldData);
                if (Object.keys(oldProjects).length > 0) {
                    console.log('📦 发现旧项目数据，正在迁移到用户空间...');
                    projects = oldProjects;
                    localStorage.setItem(userKey, JSON.stringify(projects));
                    // 迁移后删除旧key（可选，保留备份）
                    // localStorage.removeItem(oldKey);
                    console.log(`✅ 已迁移 ${Object.keys(projects).length} 个项目`);
                }
            } catch (e) {
                console.warn('迁移旧数据失败:', e);
            }
        }
        
        return projects;
    } catch {
        return {};
    }
}

function saveProject(name = null, silent = false) {
    const projects = getProjects();
    const projectName = name || state.novelTitle || writeState.outline?.title || `項目_${Date.now()}`;
    
    // 使用现有项目ID或创建新的
    const projectId = currentProjectId || projectName.replace(/\s+/g, '_').toLowerCase() + '_' + Date.now();
    currentProjectId = projectId;
    
    projects[projectId] = {
        id: projectId,
        name: projectName,
        stage: state.mode === 'write' ? 'write' : 'import',
        step: state.step,
        timestamp: new Date().toISOString(),
        
        // 项目资产（新结构）
        assets: state.assets,
        production: state.production,
        
        // 写作模式数据（兼容）
        idea: writeState.idea,
        interview: writeState.interview,
        outline: writeState.outline,
        chapters: writeState.chapters,
        writeStoryboard: writeState.storyboard,
        
        // 导入模式数据（兼容）
        novel: state.novel,
        novelTitle: state.novelTitle,
        concept: state.concept || state.assets?.concept,
        importInterview: state.interview,
        characters: state.characters || state.assets?.characters,
        storyboard: state.storyboard
    };
    
    localStorage.setItem(getProjectsKey(), JSON.stringify(projects));
    
    // 🔄 同步到后端（异步，不阻塞UI）
    syncProjectToBackend(projectId, projects[projectId]);
    
    // 更新左侧边栏
    renderProjectList();
    
    // 更新右侧资产面板
    updateAssetsPanel();
    
    // 更新标题
    document.getElementById('headerTitle').textContent = projectName;
    
    if (!silent) {
        console.log(`💾 項目已保存: ${projectName}`);
        // 显示保存提示（短暂）
        showSaveIndicator();
    }
    
    return projectId;
}

// ==================== 自动保存 ====================
let autoSaveTimer = null;
let lastSaveState = '';

function startAutoSave() {
    // 每30秒检查并自动保存
    if (autoSaveTimer) clearInterval(autoSaveTimer);
    autoSaveTimer = setInterval(() => {
        if (currentProjectId && state.novel) {
            const currentState = JSON.stringify({
                step: state.step,
                assets: state.assets,
                production: state.production
            });
            
            // 只有状态变化时才保存
            if (currentState !== lastSaveState) {
                saveProject(null, true);
                lastSaveState = currentState;
                console.log('🔄 自動保存');
            }
        }
    }, 30000);
}

function showSaveIndicator() {
    const indicator = document.createElement('div');
    indicator.style.cssText = 'position:fixed;top:20px;right:20px;background:#1a1a22;border:1px solid #2d2d3a;padding:8px 16px;border-radius:8px;color:#4ade80;font-size:12px;z-index:9999;animation:fadeInOut 2s forwards;';
    indicator.textContent = '💾 已保存';
    document.body.appendChild(indicator);
    setTimeout(() => indicator.remove(), 2000);
}

// 页面加载时启动自动保存
document.addEventListener('DOMContentLoaded', startAutoSave);

// 页面关闭前保存
window.addEventListener('beforeunload', () => {
    if (currentProjectId && state.novel) {
        saveProject(null, true);
    }
});

function showProjectList() {
    const projects = getProjects();
    const list = Object.values(projects);
    
    if (list.length === 0) {
        addAIMessage(`📂 **項目列表**

還沒有保存的項目。

開始創作後點擊「💾 保存」即可保存項目。`, [
            { text: '✍️ 創作小說', action: () => startWriteMode() },
            { text: '📄 導入小說', action: () => document.getElementById('fileInput').click() }
        ]);
        return;
    }
    
    const projectList = list
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
        .slice(0, 10)
        .map(p => {
            const date = new Date(p.timestamp).toLocaleDateString();
            const chapters = p.chapters?.length || 0;
            return `**${p.name}** (${date})\n   ${chapters}章 | ${p.stage === 'write' ? '創作' : '導入'}`;
        })
        .join('\n\n');
    
    addAIMessage(`📂 **項目列表** (${list.length}個)

${projectList}

選擇要打開的項目：`, list.slice(0, 5).map(p => ({
        text: `📖 ${p.name}`,
        action: () => loadProject(p.id)
    })).concat([
        { text: '🆕 新建項目', action: () => showStartOptions() },
        { text: '🗑️ 管理項目', action: () => manageProjects() }
    ]));
}

function loadProject(projectId) {
    const projects = getProjects();
    const p = projects[projectId];
    
    if (!p) {
        addAIMessage(`❌ 項目不存在`);
        return;
    }
    
    // 🔧 清空对话框，避免遗留
    document.getElementById('chatContainer').innerHTML = '';
    
    console.log('📂 loadProject:', projectId, { hasNovel: !!p.novel, novelLen: p.novel?.length });
    
    // 恢复写作模式状态
    writeState.idea = p.idea;
    writeState.interview = p.interview;
    writeState.outline = p.outline;
    writeState.chapters = p.chapters || [];
    writeState.storyboard = p.writeStoryboard;
    
    // 恢复导入模式状态
    state.novel = p.novel;
    console.log('📂 state.novel restored:', !!state.novel, state.novel?.length);
    state.novelTitle = p.novelTitle || p.name;
    state.concept = p.concept;
    state.interview = p.importInterview;
    state.characters = p.characters;
    state.storyboard = p.storyboard;
    state.mode = p.stage;
    state.step = p.step || 0;
    
    // 🔧 恢复项目资产（先清空再加载，确保不污染）
    state.assets = {
        concept: null,
        characters: [],
        chapters: [],
        costumes: null,
        scripts: {},
        storyboards: {}
    };
    
    if (p.assets) {
        state.assets = p.assets;
    }
    
    // 🔧 恢复生产规格（先清空再加载）
    state.production = {
        episodes: 10,
        durationMin: 3,
        shotsPerMin: 10
    };
    
    if (p.production) {
        state.production = p.production;
    }
    
    // 统计资产
    const assets = p.assets || {};
    const chapterCount = assets.chapters?.length || 0;
    const charCount = assets.characters?.length || 0;
    const scriptCount = Object.keys(assets.scripts || {}).length;
    const sbCount = Object.keys(assets.storyboards || {}).length;
    const stepNames = ['待開始', '高概念', '角色', '章節', '服化道', '劇本', '分鏡'];
    
    // 🔧 更新右侧资产面板
    updateAssetsPanel();
    
    // 更新标题
    document.getElementById('headerTitle').textContent = p.name;
    
    // 更新当前项目ID
    currentProjectId = projectId;
    
    // 智能体状态HTML - 与红色按钮对齐样式
    const agentHtml = `
<div class="quick-replies agent-row">
    <button class="quick-reply agent-btn ${assets.concept ? 'done' : ''}" onclick="triggerAgentWithCheck('concept')">💡 概念${assets.concept ? ' ✅' : ''}</button>
    <button class="quick-reply agent-btn ${charCount > 0 ? 'done' : ''}" onclick="triggerAgentWithCheck('character')">👤 人物${charCount > 0 ? ' ' + charCount : ''}</button>
    <button class="quick-reply agent-btn ${chapterCount > 0 ? 'done' : ''}" onclick="triggerAgentWithCheck('chapters')">📝 章節${chapterCount > 0 ? ' ' + chapterCount + '集' : ''}</button>
    <button class="quick-reply agent-btn ${scriptCount > 0 ? 'done' : ''}" onclick="triggerAgentWithCheck('script')">✍️ 編劇${scriptCount > 0 ? ' ' + scriptCount + '/' + chapterCount : ''}</button>
    <button class="quick-reply agent-btn ${sbCount > 0 ? 'done' : ''}" onclick="triggerAgentWithCheck('storyboard')">🎬 分鏡${sbCount > 0 ? ' ' + sbCount + '/' + chapterCount : ''}</button>
    <button class="quick-reply agent-btn auto" onclick="runAutoPilot()">🚀 自動</button>
</div>
<style>
.agent-row { display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; }
.agent-btn { padding:6px 10px !important; font-size:12px !important; }
.agent-btn.done { background:rgba(74,222,128,0.15) !important; color:#4ade80 !important; }
.agent-btn.auto { background:rgba(99,102,241,0.15) !important; color:#6366F1 !important; }
.agent-btn.auto:hover { background:rgba(99,102,241,0.25) !important; }
</style>`;
    
    addAIMessage(`📖 **已載入項目《${p.name}》**

點擊智能體可重新生成：
${agentHtml}`, [
        { text: '📊 查看項目資產', action: () => toggleAssetsPanel() },
        { text: '📤 導出Excel', action: () => exportToExcel() }
    ]);
}

// 生成下一章剧本
function runScriptStepForNextChapter() {
    const scriptCount = Object.keys(state.assets.scripts || {}).length;
    const nextChapter = scriptCount + 1;
    runScriptWriting(nextChapter);
}

// 生成下一章分镜
function runStoryboardStepForNextChapter() {
    const sbCount = Object.keys(state.assets.storyboards || {}).length;
    const nextChapter = sbCount + 1;
    generateChapterStoryboard(nextChapter);
}

function continueWriteProject() {
    const chs = writeState.outline?.chapters || [];
    const completed = writeState.chapters?.length || 0;
    const total = chs.length;
    const totalWords = writeState.chapters?.reduce((sum, c) => sum + (c.content?.length || 0), 0) || 0;
    
    // 🔧 防止空项目显示"已完成"
    if (total === 0) {
        addAIMessage(`⚠️ **還沒有內容**

請先：
1. 導入小說文本
2. 或開始新的創作

點擊下方按鈕開始：`, [
            { text: '📄 導入小說', action: () => document.getElementById('novelInput').click() },
            { text: '✍️ 新建創作', action: () => startNewProject() }
        ]);
        return;
    }
    
    if (completed >= total && totalWords > 0) {
        addAIMessage(`✅ **小說已完成！**

**《${writeState.outline?.title || '未命名'}》**
- 共 ${total} 章
- 約 ${totalWords.toLocaleString()} 字

可以轉換分鏡或導出：`, [
            { text: '🎬 轉換分鏡', action: () => convertToStoryboard() },
            { text: '📥 導出小說', action: () => exportNovel() },
            { text: '📊 導出Excel', action: () => exportExcel() }
        ]);
    } else {
        writeState.currentChapter = completed;
        const nextCh = chs[completed];
        
        addAIMessage(`▶️ **繼續寫作**

**《${writeState.outline?.title}》**

📊 進度：${completed}/${total} 章 (${Math.round(completed/total*100)}%)
📝 已寫：${totalWords.toLocaleString()} 字
📖 下一章：第${completed + 1}章《${nextCh?.title || ''}》

我會自動加載：
1. ✅ 故事大綱
2. ✅ 人物小傳
3. ✅ 前文回顧
4. ✅ 章節脈絡

準備好繼續了嗎？`, [
            { text: `▶️ 開始寫第${completed + 1}章`, action: () => writeNextChapter() },
            { text: '📖 查看大綱', action: () => showOutline() },
            { text: '📚 查看已寫章節', action: () => showWrittenChapters() }
        ]);
    }
}

function showWrittenChapters() {
    const chapters = writeState.chapters || [];
    
    if (chapters.length === 0) {
        addAIMessage(`還沒有寫任何章節。`);
        return;
    }
    
    const list = chapters.map(c => 
        `**第${c.number}章《${c.title}》** (${c.content?.length || 0}字)`
    ).join('\n');
    
    addAIMessage(`📚 **已完成章節**

${list}

點擊查看詳情：`, chapters.slice(-5).map(c => ({
        text: `📖 第${c.number}章`,
        action: () => showChapterContent(c.number)
    })));
}

function continueImportProject() {
    console.log('continueImportProject:', { step: state.step, novel: !!state.novel, concept: !!state.concept, chapters: !!state.chapters, characters: !!state.characters, storyboard: !!state.storyboard });
    
    // 保存当前进度
    saveProject();
    
    // 🔧 根据当前状态自动继续下一步
    if (state.storyboard && state.storyboard.shots?.length > 0) {
        const shotCount = state.storyboard.shots?.length || 0;
        addAIMessage(`✅ **分鏡表已完成！** 共 ${shotCount} 個鏡頭

可以導出或重新生成：`, [
            { text: '📥 導出Excel', action: () => exportExcel() },
            { text: '📥 導出JSON', action: () => exportAll() },
            { text: '🔄 重新生成分鏡', action: () => runStoryboardStep() }
        ]);
    } else if (state.characters?.characters?.length > 0) {
        const charCount = state.characters.characters.length;
        addAIMessage(`👤 已設計 ${charCount} 個角色，正在生成分鏡...`);
        setTimeout(() => runStoryboardStep(), 500);
    } else if (state.chapters?.chapters?.length > 0) {
        const chapterCount = state.chapters.chapters.length;
        addAIMessage(`📝 已規劃 ${chapterCount} 章，正在設計角色...`);
        setTimeout(() => runCharacterStep(), 500);
    } else if (state.concept?.genre || state.concept?.theme) {
        addAIMessage(`📖 概念分析完成，正在規劃章節...`);
        setTimeout(() => runChaptersStep(), 500);
    } else if (state.novel) {
        addAIMessage(`📄 小說已導入（${state.novel.length}字），正在分析概念...`);
        setTimeout(() => runConceptStep(), 500);
    } else {
        addAIMessage(`📝 請選擇開始方式：`, [
            { text: '📄 導入小說文件', action: () => document.getElementById('fileInput').click() },
            { text: '✍️ AI幫我寫小說', action: () => startWriteMode() },
            { text: '📝 直接輸入故事', action: () => addAIMessage('請直接輸入或粘貼你的故事內容（100字以上）') }
        ]);
    }
}

function manageProjects() {
    const projects = getProjects();
    const list = Object.values(projects);
    
    addAIMessage(`🗑️ **管理項目**

選擇要刪除的項目：`, list.map(p => ({
        text: `❌ 刪除 ${p.name}`,
        action: () => deleteProject(p.id)
    })).concat([
        { text: '🔙 返回列表', action: () => showProjectList() }
    ]));
}

function renameProject(projectId, currentName) {
    const newName = prompt('輸入新的項目名稱：', currentName);
    if (newName && newName.trim() && newName !== currentName) {
        const projects = getProjects();
        if (projects[projectId]) {
            projects[projectId].name = newName.trim();
            localStorage.setItem(getProjectsKey(), JSON.stringify(projects));
            renderProjectList();
            
            // 更新标题如果是当前项目
            if (projectId === currentProjectId) {
                document.getElementById('headerTitle').textContent = newName.trim();
                state.title = newName.trim();
            }
        }
    }
}

// ==================== 拖拽排序 ====================
let draggedProjectId = null;

function handleDragStart(e, projectId) {
    draggedProjectId = projectId;
    e.target.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
}

function handleDragEnd(e) {
    e.target.classList.remove('dragging');
    document.querySelectorAll('.project-item').forEach(el => el.classList.remove('drag-over'));
    draggedProjectId = null;
}

function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    const item = e.target.closest('.project-item');
    if (item && item.dataset.projectId !== draggedProjectId) {
        item.classList.add('drag-over');
    }
}

function handleDragLeave(e) {
    const item = e.target.closest('.project-item');
    if (item) item.classList.remove('drag-over');
}

function handleDrop(e, targetProjectId) {
    e.preventDefault();
    const item = e.target.closest('.project-item');
    if (item) item.classList.remove('drag-over');
    
    if (!draggedProjectId || draggedProjectId === targetProjectId) return;
    
    const projects = getProjects();
    const list = Object.values(projects).sort((a, b) => (a.order || 0) - (b.order || 0));
    
    // 找到拖拽项和目标项的索引
    const draggedIdx = list.findIndex(p => p.id === draggedProjectId);
    const targetIdx = list.findIndex(p => p.id === targetProjectId);
    
    if (draggedIdx === -1 || targetIdx === -1) return;
    
    // 移动项目
    const [dragged] = list.splice(draggedIdx, 1);
    list.splice(targetIdx, 0, dragged);
    
    // 更新order
    list.forEach((p, i) => {
        projects[p.id].order = i;
    });
    
    localStorage.setItem(getProjectsKey(), JSON.stringify(projects));
    renderProjectList();
}

// ==================== 聊天区域拖放文件 ====================
function handleChatDragOver(e) {
    e.preventDefault();
    e.stopPropagation();
    const overlay = document.getElementById('dropOverlay');
    if (overlay) overlay.classList.add('active');
}

function handleChatDragLeave(e) {
    e.preventDefault();
    e.stopPropagation();
    // 只有真正离开chat-area时才隐藏
    if (!e.currentTarget.contains(e.relatedTarget)) {
        const overlay = document.getElementById('dropOverlay');
        if (overlay) overlay.classList.remove('active');
    }
}

function handleChatDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    const overlay = document.getElementById('dropOverlay');
    if (overlay) overlay.classList.remove('active');
    
    const files = e.dataTransfer.files;
    if (files.length === 0) return;
    
    const file = files[0];
    const ext = file.name.split('.').pop().toLowerCase();
    
    if (!['txt', 'docx', 'pdf'].includes(ext)) {
        addAIMessage(`❌ 不支持的文件格式：.${ext}\n\n支持：.txt .docx .pdf`);
        return;
    }
    
    // 模拟文件选择器的change事件
    const fileInput = document.getElementById('fileInput');
    const dataTransfer = new DataTransfer();
    dataTransfer.items.add(file);
    fileInput.files = dataTransfer.files;
    fileInput.dispatchEvent(new Event('change', { bubbles: true }));
}

function confirmDeleteProject(projectId, name) {
    if (confirm(`確定要刪除項目「${name}」嗎？\n\n此操作無法撤銷！`)) {
        deleteProject(projectId);
    }
}

function deleteProject(projectId) {
    const projects = getProjects();
    const name = projects[projectId]?.name;
    delete projects[projectId];
    localStorage.setItem(getProjectsKey(), JSON.stringify(projects));
    
    // 如果删除的是当前项目，清空当前项目
    if (projectId === currentProjectId) {
        currentProjectId = null;
        state = { novel: '', title: '', step: 0, assets: {} };
        document.getElementById('headerTitle').textContent = 'FizzDragon AIGC番劇系統';
    }
    
    renderProjectList();
    addAIMessage(`🗑️ 已刪除項目「${name}」`);
}

function showExportOptions() {
    addAIMessage(`📥 **導出選項**`, [
        { text: '📄 導出小說 (TXT)', action: () => exportNovel() },
        { text: '📊 導出Excel', action: () => exportExcel() },
        { text: '📦 導出全部 (JSON)', action: () => exportAll() }
    ]);
}

// 兼容旧的保存函数
function saveProgress(stage) {
    saveProject();
}

function loadProgress() {
    // 兼容旧版本：检查单一保存
    const oldSave = localStorage.getItem('ai_drama_write_progress');
    if (oldSave) {
        try {
            const data = JSON.parse(oldSave);
            // 迁移到新系统
            if (data.outline) {
                const projects = getProjects();
                const id = (data.outline.title || 'migrated').replace(/\s+/g, '_').toLowerCase();
                projects[id] = {
                    id,
                    name: data.outline?.title || '遷移項目',
                    ...data
                };
                localStorage.setItem(getProjectsKey(), JSON.stringify(projects));
                localStorage.removeItem('ai_drama_write_progress');
                return projects[id];
            }
        } catch {}
    }
    
    // 返回最近的项目
    const projects = getProjects();
    const list = Object.values(projects);
    if (list.length > 0) {
        return list.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];
    }
    return null;
}

function exportNovel() {
    // 🔧 验证有内容才能导出
    if (!writeState.chapters || writeState.chapters.length === 0) {
        addAIMessage(`⚠️ **沒有內容可導出**

請先完成小說寫作再導出。`);
        return;
    }
    
    const content = writeState.chapters.map(c => 
        `# 第${c.number}章 ${c.title}\n\n${c.content}`
    ).join('\n\n---\n\n');
    
    const blob = new Blob([`# ${writeState.outline?.title || '未命名'}\n\n${content}`], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${writeState.outline?.title || '小說'}.txt`;
    a.click();
    
    addAIMessage(`📥 已導出小說：${writeState.outline?.title || '小說'}.txt`);
}

function exportExcel() {
    // 🔧 验证有内容才能导出
    const hasChapters = writeState.outline?.chapters?.length > 0;
    const hasCharacters = state.characters?.characters?.length > 0;
    
    if (!hasChapters && !hasCharacters) {
        addAIMessage(`⚠️ **沒有內容可導出**

請先完成分析或寫作再導出。`);
        return;
    }
    
    // 准备数据
    const rows = [];
    
    // 添加章节信息
    rows.push(['章節', '標題', '概要']);
    (writeState.outline?.chapters || []).forEach(ch => {
        rows.push([`第${ch.number}章`, ch.title, ch.summary]);
    });
    
    rows.push([]);
    rows.push(['角色', '類型', '描述', 'AI Prompt']);
    (state.characters?.characters || []).forEach(c => {
        rows.push([c.name, c.role || '', c.psychology?.want || '', c.ai_prompt || '']);
    });
    
    // 使用SheetJS导出
    if (typeof XLSX !== 'undefined') {
        const ws = XLSX.utils.aoa_to_sheet(rows);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, '故事資料');
        XLSX.writeFile(wb, `${writeState.outline?.title || '故事'}_分鏡表.xlsx`);
        addAIMessage(`📥 已導出Excel：${writeState.outline?.title || '故事'}_分鏡表.xlsx`);
    } else {
        // 降级为CSV
        const csv = rows.map(r => r.join(',')).join('\n');
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${writeState.outline?.title || '故事'}_分鏡表.csv`;
        a.click();
        addAIMessage(`📥 已導出CSV：${writeState.outline?.title || '故事'}_分鏡表.csv`);
    }
}

// ==================== 消息UI ====================
function addUserMessage(text) {
    const container = document.getElementById('chatContainer');
    const msg = document.createElement('div');
    msg.className = 'message user';
    msg.innerHTML = `<div class="role">你</div><div class="content">${escapeHtml(text)}</div>`;
    container.appendChild(msg);
    scrollToBottom();
}

function addAIMessage(text, quickReplies = []) {
    const container = document.getElementById('chatContainer');
    const msg = document.createElement('div');
    msg.className = 'message ai';
    
    let html = `<div class="role">🎬 AIGC番劇助手</div><div class="content">${formatMessage(text)}</div>`;
    
    if (quickReplies.length > 0) {
        html += '<div class="quick-replies">';
        quickReplies.forEach((r, i) => {
            html += `<button class="quick-reply" onclick="handleQuickReply(${i})">${r.text}</button>`;
        });
        html += '</div>';
        window._quickReplies = quickReplies;
    }
    
    msg.innerHTML = html;
    container.appendChild(msg);
    scrollToBottom();
    return msg;
}

function addTypingIndicator() {
    const container = document.getElementById('chatContainer');
    const msg = document.createElement('div');
    msg.className = 'message ai';
    msg.id = 'typingIndicator';
    msg.innerHTML = `<div class="role">🎬 AIGC番劇助手</div><div class="typing"><span></span><span></span><span></span></div>`;
    container.appendChild(msg);
    scrollToBottom();
}

function removeTypingIndicator() {
    const el = document.getElementById('typingIndicator');
    if (el) el.remove();
}

function addProgressCard(title, progress = 0) {
    const container = document.getElementById('chatContainer');
    const card = document.createElement('div');
    card.className = 'message ai';
    card.id = 'progressCard';
    card.innerHTML = `
        <div class="role">🎬 AIGC番劇助手</div>
        <div class="progress-card">
            <div class="progress-header">
                <span>${title}</span>
                <span id="progressPercent">${progress}%</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: ${progress}%"></div>
            </div>
        </div>
    `;
    container.appendChild(card);
    scrollToBottom();
}

function updateProgress(progress) {
    const fill = document.getElementById('progressFill');
    const percent = document.getElementById('progressPercent');
    if (fill) fill.style.width = progress + '%';
    if (percent) percent.textContent = progress + '%';
}

function removeProgressCard() {
    const el = document.getElementById('progressCard');
    if (el) el.remove();
}

function formatMessage(text) {
    // 简单的markdown支持
    return text
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\n/g, '<br>');
}

// 格式化人物小傳 - 分行顯示各個元素
function formatBio(bio) {
    if (!bio) return '';
    // 在關鍵詞前加換行
    return bio
        .replace(/Ghost[：:]/gi, '\n🔮 Ghost：')
        .replace(/Wound[：:]/gi, '\n💔 Wound：')
        .replace(/Lie[：:]/gi, '\n🎭 Lie：')
        .replace(/Want[：:]/gi, '\n🎯 Want：')
        .replace(/Need[：:]/gi, '\n💡 Need：')
        .replace(/Truth[：:]/gi, '\n✨ Truth：')
        .replace(/背景[：:]/gi, '\n📚 背景：')
        .replace(/性格[：:]/gi, '\n🧠 性格：')
        .replace(/弧[线線][：:]/gi, '\n📈 弧線：')
        .trim();
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// ==================== 可编辑确认框 ====================
let pendingEditData = null;  // 暂存待确认的数据

function showEditableResult(type, data, onConfirm, onRegenerate) {
    pendingEditData = { type, data, onConfirm, onRegenerate };
    
    const container = document.getElementById('chatContainer');
    const card = document.createElement('div');
    card.className = 'message ai';
    card.id = 'editableResultCard';
    
    // 根据类型配置
    const typeConfig = {
        concept: { num: '01', title: '高概念分析', tag: '可編輯', icon: '💡' },
        characters: { num: '02', title: '角色設計', tag: '可編輯', icon: '👤' },
        chapters: { num: '03', title: '章節規劃', tag: '可編輯', icon: '📝' },
        production: { num: '04', title: '服化道設計', tag: '可編輯', icon: '👗' }
    };
    const config = typeConfig[type] || { num: '00', title: '生成結果', tag: '可編輯', icon: '📋' };
    
    // 根据类型格式化显示
    let displayText = '';
    
    if (type === 'concept') {
        const hooks = Array.isArray(data.hooks) ? data.hooks.join('；') : (data.hooks || '');
        displayText = `類型: ${data.genre || '(待填寫)'}\n主題: ${data.theme || '(待填寫)'}\n基調: ${data.tone || '(待填寫)'}\nLogline: ${data.logline || '(待填寫)'}\n時代背景: ${data.era || data.setting || '(待填寫)'}\n故事賣點: ${hooks || data.conflict || '(待填寫)'}\n目標觀眾: ${data.audience || '(待填寫)'}\n對標作品: ${data.comparable || '(待填寫)'}\n情感旅程: ${data.emotionalJourney || '(待填寫)'}`;
    } else if (type === 'characters') {
        displayText = (data || []).map(c => 
            `【${c.name}】(${c.role || '角色'})\n\n📖 人物小傳:\n${c.bio || '(待填寫 - 描述角色背景、性格、動機)'}\n\n👤 外貌特徵:\n${c.appearance || '(待填寫 - 描述年齡、身高、髮型、服裝等)'}\n\n🎨 AI形象Prompt:\n${c.prompt || c.ai_prompt || '(待填寫 - 英文描述，用於AI生圖)'}`
        ).join('\n\n════════════════════════════\n\n');
    } else if (type === 'chapters') {
        displayText = (data || []).map((ch, i) => {
            let text = `【${ch.phase || ''}】第${ch.number || i+1}集「${ch.title || ch.name || ''}」`;
            if (ch.summary || ch.description) text += `\n📖 ${ch.summary || ch.description}`;
            if (ch.highlight) text += `\n🌟 亮點: ${ch.highlight}`;
            if (ch.conflict) text += `\n⚔️ 衝突: ${ch.conflict}`;
            if (ch.hook) text += `\n🎣 懸念: ${ch.hook}`;
            return text;
        }).join('\n\n════════════════════════════\n\n');
    } else if (type === 'production') {
        // 服化道格式
        let text = '══════ 👔 服裝設計 ══════\n\n';
        text += (data.costumes || []).map(c => 
            `【${c.character || c.name || '角色'}】(${c.occasion || '場合'})\n服裝: ${c.outfit || c.description || '(待填寫)'}\n風格: ${c.style || '(待填寫)'}\n🎨 Prompt: ${c.ai_prompt || c.prompt || '(待填寫)'}`
        ).join('\n\n────────────────\n\n');
        
        text += '\n\n══════ 🏠 場景設計 ══════\n\n';
        text += (data.sets || []).map(s => 
            `【${s.name || s.location || '場景'}】(${s.time || '時間'})\n氛圍: ${s.atmosphere || s.description || '(待填寫)'}\n🎨 Prompt: ${s.ai_prompt || s.prompt || '(待填寫)'}`
        ).join('\n\n────────────────\n\n');
        
        text += '\n\n══════ 🎭 道具設計 ══════\n\n';
        text += (data.props || []).map(p => 
            `【${p.name || '道具'}】\n用途: ${p.usage || p.description || '(待填寫)'}\n🎨 Prompt: ${p.ai_prompt || p.prompt || '(待填寫)'}`
        ).join('\n\n────────────────\n\n');
        
        displayText = text;
    } else {
        displayText = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
    }
    
    card.innerHTML = `
        <div class="role">${config.icon} ${config.title}</div>
        <div class="content" style="padding:0;">
            <div class="editable-result">
                <div class="result-header">
                    <span class="result-number">${config.num}</span>
                    <span class="result-title">${config.title}</span>
                    <span class="result-tag">${config.tag}</span>
                </div>
                <textarea id="editableTextarea">${escapeHtml(displayText)}</textarea>
                <div class="actions">
                    <button class="btn-regenerate" onclick="regenerateResult()">✏️ 不滿意，我要改</button>
                    <button class="btn-confirm" onclick="confirmResult()">✅ 確認存入資產庫</button>
                </div>
            </div>
        </div>
    `;
    
    container.appendChild(card);
    
    // 🔧 自动调整textarea高度适应内容
    const textarea = document.getElementById('editableTextarea');
    if (textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 500) + 'px';
    }
    
    scrollToBottom();
}

function confirmResult() {
    console.log('🔔 confirmResult called, pendingEditData:', pendingEditData);
    
    if (!pendingEditData) {
        console.log('❌ No pendingEditData!');
        return;
    }
    
    const textarea = document.getElementById('editableTextarea');
    const editedText = textarea?.value || '';
    console.log('📝 editedText length:', editedText.length);
    
    // 解析编辑后的内容
    let finalData = pendingEditData.data;
    
    if (pendingEditData.type === 'concept') {
        // 尝试解析编辑后的概念
        const lines = editedText.split('\n');
        finalData = { ...pendingEditData.data };
        lines.forEach(line => {
            if (line.startsWith('類型:')) finalData.genre = line.replace('類型:', '').trim();
            if (line.startsWith('主題:')) finalData.theme = line.replace('主題:', '').trim();
            if (line.startsWith('基調:')) finalData.tone = line.replace('基調:', '').trim();
            if (line.startsWith('Logline:')) finalData.logline = line.replace('Logline:', '').trim();
            if (line.startsWith('時代背景:')) finalData.era = line.replace('時代背景:', '').trim();
            if (line.startsWith('故事賣點:')) finalData.hooks = line.replace('故事賣點:', '').trim().split('；');
            if (line.startsWith('目標觀眾:')) finalData.audience = line.replace('目標觀眾:', '').trim();
            if (line.startsWith('對標作品:')) finalData.comparable = line.replace('對標作品:', '').trim();
            if (line.startsWith('情感旅程:')) finalData.emotionalJourney = line.replace('情感旅程:', '').trim();
        });
    } else if (pendingEditData.type === 'characters') {
        // 解析编辑后的角色
        const charBlocks = editedText.split('════════════════════════════').filter(b => b.trim());
        console.log('📝 Parsing', charBlocks.length, 'character blocks');
        finalData = charBlocks.map((block, idx) => {
            const char = {};
            // 解析角色名和类型
            const nameMatch = block.match(/【(.+?)】\((.+?)\)/);
            if (nameMatch) {
                char.name = nameMatch[1].trim();
                char.role = nameMatch[2].trim();
            }
            // 解析人物小传
            const bioMatch = block.match(/📖 人物小傳:\n([\s\S]*?)(?=\n\n👤|$)/);
            if (bioMatch) char.bio = bioMatch[1].trim();
            // 解析外貌
            const appearMatch = block.match(/👤 外貌特徵:\n([\s\S]*?)(?=\n\n🎨|$)/);
            if (appearMatch) char.appearance = appearMatch[1].trim();
            // 解析Prompt
            const promptMatch = block.match(/🎨 AI形象Prompt:\n([\s\S]*?)$/);
            if (promptMatch) char.prompt = promptMatch[1].trim();
            console.log(`📝 Char ${idx}:`, char.name, '| prompt:', char.prompt?.substring(0, 30));
            return char;
        }).filter(c => c.name);
        console.log('📝 Final characters:', finalData.length);
    } else if (pendingEditData.type === 'chapters') {
        // 解析编辑后的章节
        const chapterBlocks = editedText.split('════════════════════════════').filter(b => b.trim());
        finalData = chapterBlocks.map((block, i) => {
            const chapter = { ...pendingEditData.data[i] };
            // 解析章节信息
            const titleMatch = block.match(/【(.+?)】第(\d+)集「(.+?)」/);
            if (titleMatch) {
                chapter.phase = titleMatch[1].trim();
                chapter.number = parseInt(titleMatch[2]);
                chapter.title = titleMatch[3].trim();
            }
            // 解析各字段
            const summaryMatch = block.match(/📖\s*(.+?)(?=\n🌟|\n⚔️|\n🎣|$)/s);
            if (summaryMatch) chapter.summary = summaryMatch[1].trim();
            const highlightMatch = block.match(/🌟 亮點:\s*(.+?)(?=\n⚔️|\n🎣|$)/s);
            if (highlightMatch) chapter.highlight = highlightMatch[1].trim();
            const conflictMatch = block.match(/⚔️ 衝突:\s*(.+?)(?=\n🎣|$)/s);
            if (conflictMatch) chapter.conflict = conflictMatch[1].trim();
            const hookMatch = block.match(/🎣 懸念:\s*(.+?)$/s);
            if (hookMatch) chapter.hook = hookMatch[1].trim();
            return chapter;
        }).filter(c => c.title || c.number);
    } else if (pendingEditData.type === 'production') {
        // 解析编辑后的服化道（简化处理，直接返回原数据，让用户编辑后的文本作为参考）
        // 复杂解析可以后续完善
        finalData = pendingEditData.data;
    }
    
    // 移除编辑卡片
    const card = document.getElementById('editableResultCard');
    if (card) card.remove();
    
    // 调用确认回调
    console.log('🔔 Calling onConfirm with finalData:', finalData);
    if (pendingEditData.onConfirm) {
        try {
            pendingEditData.onConfirm(finalData);
            console.log('✅ onConfirm executed');
        } catch (err) {
            console.error('❌ onConfirm error:', err);
        }
    } else {
        console.log('❌ No onConfirm callback!');
    }
    
    pendingEditData = null;
}

function regenerateResult() {
    // 不直接重新生成，先問用戶想改什麼
    askForRevisionFeedback();
}

// 🆕 詢問修改意見
function askForRevisionFeedback() {
    const card = document.getElementById('editableResultCard');
    if (card) card.remove();
    
    const type = pendingEditData?.type || 'content';
    const typeNames = {
        concept: '高概念',
        characters: '角色設計', 
        chapters: '章節規劃',
        production: '服化道'
    };
    const typeName = typeNames[type] || '內容';
    
    addAIMessage(`✏️ **想怎麼修改${typeName}？**

請告訴我你的修改意見，例如：
- 「主題太悲觀了，改成更正面的」
- 「角色年齡改大一點」
- 「風格改成更現代的」
- 「增加一個反派角色」

或輸入「重寫」完全重新生成。`);
    
    // 保存当前状态，等待用户输入
    window.pendingRevision = {
        type: type,
        originalData: pendingEditData?.data,
        onConfirm: pendingEditData?.onConfirm,
        onRegenerate: pendingEditData?.onRegenerate
    };
    
    showQuickReplies([
        { text: '🔄 完全重寫', action: () => forceRegenerate() },
        { text: '❌ 取消', action: () => cancelRevision() }
    ]);
}

// 处理用户的修改意见
async function handleRevisionFeedback(feedback) {
    if (!window.pendingRevision) return false;
    
    const { type, originalData, onConfirm } = window.pendingRevision;
    
    // 如果用户说"重写"，直接重新生成
    if (feedback.includes('重寫') || feedback.includes('重写') || feedback.toLowerCase().includes('rewrite')) {
        forceRegenerate();
        return true;
    }
    
    const typeNames = {
        concept: '高概念',
        characters: '角色設計',
        chapters: '章節規劃', 
        production: '服化道'
    };
    const typeName = typeNames[type] || '內容';
    const agentIcons = {
        concept: '💡',
        characters: '👤',
        chapters: '📝',
        production: '👗'
    };
    
    // 🔧 详细步骤显示
    const steps = [
        { text: `📡 連接${typeName}智能體...`, done: false, current: true },
        { text: '📚 載入相關Skills...', done: false },
        { text: '🤖 調用FizzDragon大模型...', done: false },
        { text: '📝 解析並驗證結果...', done: false }
    ];
    
    showAgentStatus(`${agentIcons[type] || '🔄'} ${typeName}修改器`, `正在處理修改意見...`, type, steps);
    
    addAIMessage(`🔄 正在根據你的意見修改**${typeName}**...

> "${feedback}"`);
    
    try {
        // 步骤1完成，步骤2开始
        steps[0].done = true; steps[0].current = false;
        steps[1].current = true;
        showAgentStatus(`${agentIcons[type] || '🔄'} ${typeName}修改器`, `載入narrative_complete等Skills...`, type, steps);
        
        // 构建修改提示
        const revisionPrompt = `
這是之前生成的${typeName}：
${JSON.stringify(originalData, null, 2)}

用戶的修改意見：
${feedback}

請根據用戶意見，修改並輸出完整的新版本。保持JSON格式。
`;
        
        // 步骤2完成，步骤3开始
        steps[1].done = true; steps[1].current = false;
        steps[2].current = true;
        showAgentStatus(`${agentIcons[type] || '🔄'} ${typeName}修改器`, `FizzDragon正在思考...`, type, steps);
        
        const result = await callAgent(type, revisionPrompt, { revision: true });
        
        // 步骤3完成，步骤4开始
        steps[2].done = true; steps[2].current = false;
        steps[3].current = true;
        showAgentStatus(`${agentIcons[type] || '🔄'} ${typeName}修改器`, `解析JSON結果...`, type, steps);
        
        const revisedData = safeJSONParse(result, type);
        
        // 全部完成
        steps[3].done = true; steps[3].current = false;
        
        hideAgentStatus();
        
        // 显示修改后的结果
        showEditableResult(type, revisedData, onConfirm, () => {
            askForRevisionFeedback();
        });
        
        addAIMessage(`✅ 已根據你的意見修改！

請檢查上方結果，可以繼續編輯或確認。`);
        
    } catch (err) {
        hideAgentStatus();
        addAIMessage(`❌ 修改失敗：${err.message}

請重試或選擇「完全重寫」。`);
        
        showQuickReplies([
            { text: '🔄 完全重寫', action: () => forceRegenerate() },
            { text: '❌ 取消', action: () => cancelRevision() }
        ]);
    }
    
    window.pendingRevision = null;
    return true;
}

// 强制完全重新生成（不问意见）
function forceRegenerate() {
    const pending = window.pendingRevision || pendingEditData;
    window.pendingRevision = null;
    pendingEditData = null;
    
    if (pending?.onRegenerate) {
        addAIMessage('🔄 好的，完全重新生成...');
        pending.onRegenerate();
    }
}

// 取消修改
function cancelRevision() {
    const pending = window.pendingRevision;
    window.pendingRevision = null;
    
    if (pending?.originalData && pending?.onConfirm) {
        // 重新显示原来的编辑框
        showEditableResult(pending.type, pending.originalData, pending.onConfirm, () => {
            askForRevisionFeedback();
        });
    }
}

// 友好的错误提示（告诉用户原因和解决方法）
function friendlyError(err, step) {
    const msg = err.message || String(err);
    
    // 分析错误类型
    if (msg.includes('timeout') || msg.includes('Timeout') || msg.includes('超時')) {
        return {
            title: '⏱️ 處理時間較長',
            reason: 'AI正在深度思考，但花了比預期更長的時間',
            solutions: [
                '稍等片刻後重試',
                '如果內容較長，可以嘗試縮短輸入',
                '網絡可能較慢，換個時間試試'
            ]
        };
    }
    
    if (msg.includes('JSON') || msg.includes('parse') || msg.includes('Unexpected')) {
        return {
            title: '📋 格式解析問題',
            reason: 'AI回覆的格式不太標準，系統正在學習處理',
            solutions: [
                '直接重試通常就能解決',
                '這是AI偶爾的小脾氣，不影響後續'
            ]
        };
    }
    
    if (msg.includes('network') || msg.includes('fetch') || msg.includes('連接')) {
        return {
            title: '🌐 網絡連接問題',
            reason: '與AI服務的連接暫時中斷',
            solutions: [
                '檢查網絡連接',
                '稍後重試',
                '如持續失敗，可能是服務維護中'
            ]
        };
    }
    
    if (msg.includes('API') || msg.includes('401') || msg.includes('403')) {
        return {
            title: '🔑 服務驗證問題',
            reason: 'API密鑰可能需要更新',
            solutions: [
                '聯繫管理員檢查配置',
                '稍後重試'
            ]
        };
    }
    
    if (msg.includes('500') || msg.includes('502') || msg.includes('503')) {
        return {
            title: '🔧 服務暫時繁忙',
            reason: 'AI服務正在處理大量請求',
            solutions: [
                '等待1-2分鐘後重試',
                '高峰期可能需要多試幾次'
            ]
        };
    }
    
    // 默认错误
    return {
        title: '⚠️ 遇到了小問題',
        reason: msg.length > 100 ? msg.substring(0, 100) + '...' : msg,
        solutions: [
            '重試一次通常能解決',
            '如果持續失敗，嘗試簡化輸入內容',
            '或者先保存進度，稍後繼續'
        ]
    };
}

function showFriendlyError(err, step, retryAction) {
    const info = friendlyError(err, step);
    
    addAIMessage(`${info.title}

**可能原因**: ${info.reason}

**建議**:
${info.solutions.map(s => `• ${s}`).join('\n')}`, [
        { text: '🔄 重試', action: retryAction },
        { text: '💾 保存進度', action: () => saveProject() },
        { text: '🆘 求助小助手', action: () => callHelpAgent() }
    ]);
}

// ==================== 用户助手智能体 ====================
let lastError = null;  // 记录最后的错误

// 记录错误（在各个catch块中调用）
function recordError(err, context) {
    lastError = {
        message: err.message || String(err),
        context: context,
        timestamp: new Date().toISOString(),
        state: {
            mode: state.mode,
            step: state.step,
            hasNovel: !!state.novel,
            hasConcept: !!state.concept,
            hasChapters: !!state.chapters,
            hasCharacters: !!state.characters,
            writeChapters: writeState.chapters?.length || 0
        }
    };
}

// 用户助手智能体
async function callHelpAgent() {
    const helpBtn = document.querySelector('.help-fab');
    helpBtn.classList.add('loading');
    helpBtn.textContent = '🔍';
    
    addAIMessage(`🆘 **用戶助手來幫忙了！**

正在診斷系統狀態...`);
    
    // 收集诊断信息
    const diagnosis = {
        // 当前状态
        mode: state.mode || '未開始',
        step: state.step || 0,
        
        // 数据状态
        hasNovel: !!state.novel,
        novelLength: state.novel?.length || 0,
        hasConcept: !!state.concept,
        hasChapters: !!state.chapters || !!writeState.outline,
        chapterCount: (state.chapters?.chapters || state.chapters?.episodes || writeState.outline?.chapters || []).length,
        hasCharacters: !!state.characters,
        characterCount: (state.characters?.characters || []).length,
        writtenChapters: writeState.chapters?.length || 0,
        hasStoryboard: !!state.storyboard,
        
        // API状态
        apiConnected: API_BASE !== null,
        apiEndpoint: API_BASE,
        
        // 最近错误
        lastError: lastError
    };
    
    // 分析问题并提供解决方案
    const issues = [];
    const fixes = [];
    
    // 检查API连接
    if (!diagnosis.apiConnected) {
        issues.push('❌ API未連接');
        fixes.push({ text: '🔄 重新連接API', action: async () => {
            await detectAPI();
            addAIMessage(API_BASE ? '✅ API已重新連接！可以繼續了。' : '❌ 連接失敗，請檢查網絡');
        }});
    }
    
    // 检查数据完整性
    if (diagnosis.mode === 'write' && diagnosis.hasNovel === false && !writeState.idea) {
        issues.push('⚠️ 還沒有開始創作');
        fixes.push({ text: '✍️ 開始創作', action: () => doStartWriteMode() });
    }
    
    if (diagnosis.mode === 'import' && diagnosis.hasNovel && !diagnosis.hasConcept) {
        issues.push('⚠️ 小說已導入但未分析');
        fixes.push({ text: '📖 重新分析小說', action: () => runConceptStep() });
    }
    
    if (diagnosis.hasConcept && !diagnosis.hasChapters && diagnosis.step >= 2) {
        issues.push('⚠️ 章節規劃未完成');
        fixes.push({ text: '📝 生成章節規劃', action: () => state.mode === 'write' ? generateOutline() : runChaptersStep() });
    }
    
    if (diagnosis.hasChapters && !diagnosis.hasCharacters && diagnosis.step >= 4) {
        issues.push('⚠️ 角色設計未完成');
        fixes.push({ text: '👤 生成角色設計', action: () => runCharacterStep() });
    }
    
    // 检查最近错误
    if (lastError) {
        issues.push(`⚠️ 最近錯誤: ${lastError.context}`);
        
        if (lastError.message.includes('timeout') || lastError.message.includes('Timeout')) {
            fixes.push({ text: '⏱️ 延長超時重試', action: () => {
                addAIMessage('已調整超時設置，請重試上一步操作。');
            }});
        }
        
        if (lastError.message.includes('JSON') || lastError.message.includes('parse')) {
            fixes.push({ text: '🔄 清除緩存重試', action: () => {
                lastError = null;
                addAIMessage('已清除錯誤記錄，請重試上一步操作。');
            }});
        }
    }
    
    // 生成诊断报告
    helpBtn.classList.remove('loading');
    helpBtn.textContent = '🆘';
    
    if (issues.length === 0) {
        // 没有发现问题
        addAIMessage(`✅ **診斷完成 - 系統正常！**

**當前狀態**:
• 模式: ${diagnosis.mode === 'write' ? '創作模式' : diagnosis.mode === 'import' ? '導入模式' : '未開始'}
• 步驟: ${diagnosis.step}/5
${diagnosis.hasNovel ? `• 小說: ${diagnosis.novelLength.toLocaleString()} 字` : ''}
${diagnosis.chapterCount > 0 ? `• 章節: ${diagnosis.chapterCount} 章` : ''}
${diagnosis.characterCount > 0 ? `• 角色: ${diagnosis.characterCount} 個` : ''}
${diagnosis.writtenChapters > 0 ? `• 已寫: ${diagnosis.writtenChapters} 章` : ''}
• API: ${diagnosis.apiConnected ? '已連接 ✅' : '未連接 ❌'}

**沒有發現問題！** 如果遇到困難，請描述具體情況。`, [
            { text: '▶️ 繼續創作', action: () => state.mode === 'write' ? continueWriteProject() : continueImportProject() },
            { text: '🏠 返回主頁', action: () => showStartOptions() }
        ]);
    } else {
        // 发现问题，提供修复选项
        addAIMessage(`🔍 **診斷完成 - 發現 ${issues.length} 個問題**

**問題列表**:
${issues.map(i => `${i}`).join('\n')}

**當前狀態**:
• 模式: ${diagnosis.mode === 'write' ? '創作模式' : diagnosis.mode === 'import' ? '導入模式' : '未開始'}
• 進度: ${diagnosis.step}/5
• API: ${diagnosis.apiConnected ? '已連接 ✅' : '未連接 ❌'}

點擊下方按鈕自動修復：`, fixes.concat([
            { text: '🏠 返回主頁重新開始', action: () => {
                resetWorkflowFromStep(0);
                document.getElementById('chatContainer').innerHTML = '';
                showStartOptions();
            }}
        ]));
    }
}

// 用户是否正在往上滚动（查看历史）
let userScrolledUp = false;
let lastScrollTime = 0;
let scrollLockUntil = 0; // 锁定自动滚动直到这个时间

function scrollToBottom(force = false) {
    const container = document.getElementById('chatContainer');
    if (!container) return;
    
    // 如果用户手动滚动过且还在锁定期内，完全不自动滚动
    if (userScrolledUp && Date.now() < scrollLockUntil) {
        return;
    }
    
    // 检查用户是否滚动到接近底部（距底部200px内）
    const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 200;
    
    // 只有在用户接近底部 或 强制滚动时才自动滚动
    if (isNearBottom || force) {
        setTimeout(() => {
            if (!userScrolledUp || force) {
                container.scrollTop = container.scrollHeight;
            }
        }, 100);
    }
}

// 监听用户滚动
document.addEventListener('DOMContentLoaded', () => {
    const container = document.getElementById('chatContainer');
    if (container) {
        let scrollTimeout;
        container.addEventListener('scroll', () => {
            const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 200;
            
            if (!isNearBottom) {
                userScrolledUp = true;
                lastScrollTime = Date.now();
                scrollLockUntil = Date.now() + 30000; // 锁定30秒
                
                // 清除之前的超时，重新计时
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    // 30秒后如果用户没有继续滚动，解除锁定
                    if (Date.now() - lastScrollTime > 30000) {
                        userScrolledUp = false;
                    }
                }, 30000);
            } else {
                // 滚到底部了，解除锁定
                userScrolledUp = false;
                scrollLockUntil = 0;
            }
        });
    }
});

// ==================== 快捷回复 ====================
function handleQuickReply(index) {
    if (window._quickReplies && window._quickReplies[index]) {
        const reply = window._quickReplies[index];
        if (reply.action) {
            reply.action();
        } else if (reply.text) {
            document.getElementById('userInput').value = reply.text;
            sendMessage();
        }
    }
}

// ==================== 工作流重置 (DeepSeek风格) ====================
// 检查是否有进行中的工作
function hasActiveWork() {
    // 检查对象是否有实际内容
    const hasContent = (obj) => obj && Object.keys(obj).length > 0;
    
    const result = !!(
        state.novel || 
        state.concept || 
        hasContent(state.interview) ||  // 检查是否有实际回答
        state.chapters || 
        state.characters || 
        state.storyboard ||
        writeState.idea ||
        writeState.outline ||
        hasContent(writeState.interview) ||  // 检查是否有实际回答
        (writeState.chapters && writeState.chapters.length > 0)
    );
    
    console.log('hasActiveWork:', result, { 
        novel: !!state.novel, 
        concept: !!state.concept, 
        interview: hasContent(state.interview),
        chapters: !!state.chapters,
        idea: !!writeState.idea,
        outline: !!writeState.outline
    });
    
    return result;
}

// 重置工作流到指定步骤（清除该步骤及之后的所有数据）
function resetWorkflowFromStep(stepNumber) {
    console.log('resetWorkflowFromStep:', stepNumber);
    // 步骤定义:
    // 0: 初始状态（清空一切）
    // 1: 导入/创意 完成，清除 concept 及之后
    // 2: concept 完成，清除 interview 及之后  
    // 3: interview 完成，清除 chapters 及之后
    // 4: chapters 完成，清除 characters 及之后
    // 5: characters 完成，清除 storyboard 及之后
    
    if (stepNumber <= 0) {
        // 完全重置
        state.novel = null;
        state.novelTitle = '';
        state.mode = null;
        state.step = 0;
        writeState.idea = null;
        writeState.currentQuestion = null;
        
        // 🔧 重置项目资产
        state.assets = {
            concept: null,
            characters: [],
            chapters: [],
            costumes: null,
            scripts: {},
            storyboards: {}
        };
        currentProjectId = null;
        
        // 🔧 更新右侧资产面板
        updateAssetsPanel();
    }
    if (stepNumber <= 1) {
        state.concept = null;
        writeState.interview = {};
    }
    if (stepNumber <= 2) {
        state.interview = {};
        state.interviewQuestions = [];
        state.currentQuestion = 0;
    }
    if (stepNumber <= 3) {
        state.chapters = null;
        writeState.outline = null;
    }
    if (stepNumber <= 4) {
        state.characters = null;
        writeState.chapters = [];
        writeState.currentChapter = 0;
    }
    if (stepNumber <= 5) {
        state.storyboard = null;
        writeState.storyboard = null;
    }
    
    state.step = stepNumber;
    console.log(`工作流重置到步骤 ${stepNumber}`);
}

// 确认重置对话框
function confirmResetAndImport(callback) {
    if (!hasActiveWork()) {
        callback();
        return;
    }
    
    // 🔧 自动保存当前项目，不再提示
    saveProject(true);  // 静默保存
    
    // 清空并继续
    resetWorkflowFromStep(0);
    document.getElementById('chatContainer').innerHTML = '';
    callback();
}

// 显示调整警告（修改前面的步骤会清空后续）
function showAdjustWarning(stepName, stepNumber) {
    const stepNames = {
        'outline': '大綱',
        'chapters': '章節規劃', 
        'characters': '角色設計',
        'interview': '訪談'
    };
    
    const affectedSteps = [];
    if (stepNumber <= 3) affectedSteps.push('章節規劃');
    if (stepNumber <= 4) {
        affectedSteps.push('角色設計');
        if (writeState.chapters?.length > 0) {
            affectedSteps.push(`已寫的 ${writeState.chapters.length} 章內容`);
        }
    }
    if (stepNumber <= 5) affectedSteps.push('分鏡表');
    
    addAIMessage(`⚠️ **調整${stepNames[stepName] || stepName}**

修改此步驟會**清空後續所有內容**：
${affectedSteps.map(s => `• ${s}`).join('\n')}

確定要調整嗎？`, [
        { text: `✏️ 確定調整${stepNames[stepName] || stepName}`, action: () => {
            resetWorkflowFromStep(stepNumber);
            // 根据步骤类型，显示相应的调整界面
            if (stepName === 'outline') {
                addAIMessage(`📝 請描述你想如何調整大綱：
- 整體結構
- 章節數量
- 故事走向
- 其他要求`);
            } else if (stepName === 'chapters') {
                runChaptersStep();
            } else if (stepName === 'characters') {
                runCharacterStep();
            }
        }},
        { text: '❌ 取消', action: () => showCurrentProgress() }
    ]);
}

// 显示当前进度
function showCurrentProgress() {
    const title = state.novelTitle || writeState.outline?.title || '未命名';
    const mode = state.mode === 'write' ? '創作模式' : '導入模式';
    const chaptersCount = writeState.chapters?.length || 0;
    
    let progress = [];
    if (state.novel || writeState.idea) progress.push('✅ 故事靈感');
    if (state.concept) progress.push('✅ 概念分析');
    if (Object.keys(state.interview || {}).length > 0 || Object.keys(writeState.interview || {}).length > 0) progress.push('✅ 訪談');
    if (state.chapters || writeState.outline) progress.push('✅ 章節規劃');
    if (state.characters) progress.push('✅ 角色設計');
    if (chaptersCount > 0) progress.push(`✅ 已寫 ${chaptersCount} 章`);
    if (state.storyboard) progress.push('✅ 分鏡表');
    
    addAIMessage(`📊 **當前進度**

**《${title}》** - ${mode}

${progress.join('\n') || '剛開始'}

繼續當前工作：`, [
        { text: '▶️ 繼續', action: () => state.mode === 'write' ? continueWriteProject() : continueImportProject() },
        { text: '💾 保存項目', action: () => saveProject() }
    ]);
}

// ==================== 文件导入 ====================
document.getElementById('fileInput').addEventListener('change', async (e) => {
    console.log('📁 文件选择触发');
    const file = e.target.files[0];
    if (!file) {
        console.log('📁 没有选择文件');
        return;
    }
    console.log('📁 文件:', file.name, file.size, 'bytes');
    
    // 🔧 保存文件引用（因为后面要清空input）
    const selectedFile = file;
    e.target.value = ''; // 清空文件输入，允许选择同一文件
    
    // 检查是否有进行中的工作 - 自动保存后继续
    if (hasActiveWork()) {
        saveProject(null, true); // 静默保存当前项目
        // 清空状态
        currentProjectId = null;
        state.assets = { concept: null, characters: [], chapters: [], costumes: null, scripts: {}, storyboards: {} };
        state.production = { episodes: 10, durationMin: 3, shotsPerMin: 10 };
        updateAssetsPanel();
    }
    
    // 🔧 使用保存的文件引用继续处理
    const fileToProcess = selectedFile;
    
    addUserMessage(`📄 導入文件: ${fileToProcess.name}`);
    addTypingIndicator();
    
    try {
        let text = '';
        const ext = fileToProcess.name.split('.').pop().toLowerCase();
        
        if (ext === 'txt') {
            text = await fileToProcess.text();
        } else if (ext === 'docx') {
            const arrayBuffer = await fileToProcess.arrayBuffer();
            const result = await mammoth.extractRawText({ arrayBuffer });
            text = result.value;
        } else if (ext === 'pdf') {
            const arrayBuffer = await fileToProcess.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const content = await page.getTextContent();
                text += content.items.map(item => item.str).join(' ') + '\n';
            }
        }
        
        state.novel = text;
        
        // 🔧 Bug #5 fix: 从文本内容提取标题，而不是用文件名
        const extractedTitle = extractTitleFromText(text);
        state.novelTitle = extractedTitle || fileToProcess.name.replace(/\.[^/.]+$/, '');
        
        // 📖 保存到故事资产
        state.assets.story = {
            title: state.novelTitle,
            content: text,
            type: 'upload',
            filename: fileToProcess.name,
            uploadedAt: new Date().toISOString()
        };
        
        state.step = 1;
        state.mode = 'import';
        
        // 🔧 自动创建项目
        currentProjectId = null;  // 重置，让saveProject创建新ID
        saveProject(state.novelTitle, true);  // 静默保存
        
        console.log('📁 状态已设置:', { mode: state.mode, step: state.step, title: state.novelTitle, novelLen: text.length, projectId: currentProjectId });
        
        removeTypingIndicator();
        
        // 保留换行的预览
        const previewText = text.substring(0, 300).replace(/\n/g, '\n');
        const preview = previewText + (text.length > 300 ? '...' : '');
        
        // 🚀 检查是否启用 Auto-Pilot
        if (state.autoPilotEnabled) {
            state.autoPilotEnabled = false; // 重置
            addAIMessage(`✅ 成功導入《${state.novelTitle}》（${text.length.toLocaleString()} 字）

🚀 **Auto-Pilot 模式已啟動！**
正在自動執行所有步驟...`);
            setTimeout(() => runAutoPilot(), 500);
            return;
        }
        
        addAIMessage(`✅ 成功導入《${state.novelTitle}》

**字數**: ${text.length.toLocaleString()} 字

**預覽**:
<div style="background:var(--surface);padding:12px;border-radius:8px;white-space:pre-wrap;font-size:13px;max-height:200px;overflow-y:auto;border-left:3px solid var(--accent);">${escapeHtml(preview)}</div>

───────────────────────
請選擇分析方式：`, [
            { text: '🎤 深度訪談（更精準）', action: () => startImportInterview() },
            { text: '⚡ 直接分析（更快速）', action: () => runConceptStep() },
            { text: '🚀 Auto-Pilot 全自動', action: () => runAutoPilot() }
        ]);
        
    } catch (err) {
        removeTypingIndicator();
        addAIMessage(`📄 **文件讀取遇到問題**

**可能原因**:
• 文件格式不支持（目前支持 .txt, .docx, .pdf）
• 文件可能已損壞或加密
• 文件太大（建議 < 5MB）

**建議**:
• 嘗試另存為 .txt 格式後重新導入
• 確認文件可以正常打開

錯誤詳情: ${err.message}`, [
            { text: '📄 重新選擇文件', action: () => document.getElementById('fileInput').click() },
            { text: '✍️ 我要寫故事', action: () => startWriteStory() }
        ]);
    }
});

// ==================== 快速生成（跳过访谈）====================
async function quickGenerate() {
    addAIMessage(`⚡ **快速生成模式**

正在自動完成所有步驟...`);
    
    addProgressCard('快速生成分鏡', 0);
    
    try {
        // 步骤1: 章节规划
        updateProgress(20);
        showAgentStatus('📝 章節規劃師', '規劃故事結構...', 'narrative');
        const chaptersResult = await callAgent('narrative', state.novel.substring(0, 5000), { concept: state.concept });
        state.chapters = safeJSONParse(chaptersResult, 'chapters');
        state.step = 4;
        
        // 步骤2: 角色设计
        updateProgress(50);
        showAgentStatus('👤 角色設計師', '設計角色...');
        const charactersResult = await callAgent('character', state.novel.substring(0, 4000), { concept: state.concept, chapters: state.chapters });
        state.characters = safeJSONParse(charactersResult, 'characters');
        state.step = 5;
        
        // 步骤3: 分镜生成
        updateProgress(80);
        showAgentStatus('🎬 分鏡導演', '生成分鏡表...', 'storyboard');
        const storyboardResult = await callAgent('storyboard', state.novel.substring(0, 3000), { concept: state.concept, chapters: state.chapters, characters: state.characters });
        state.storyboard = storyboardResult;
        
        updateProgress(100);
        removeProgressCard();
        hideAgentStatus();
        
        const eps = state.chapters?.chapters || state.chapters?.episodes || [];
        const chars = state.characters?.characters || [];
        
        addAIMessage(`✅ **快速生成完成！**

📊 **生成結果**：
• 章節：${eps.length} 集
• 角色：${chars.length} 個
• 分鏡：已生成

接下來：`, [
            { text: '📥 導出Excel', action: () => exportExcel() },
            { text: '📥 導出JSON', action: () => exportAll() },
            { text: '👀 查看詳情', action: () => showGeneratedDetails() }
        ]);
        
    } catch (err) {
        removeProgressCard();
        hideAgentStatus();
        recordError(err, '快速生成');
        showFriendlyError(err, '快速生成', () => quickGenerate());
    }
}

function showGeneratedDetails() {
    const eps = state.chapters?.chapters || state.chapters?.episodes || [];
    const chars = state.characters?.characters || [];
    
    let details = `📋 **生成詳情**\n\n**章節列表**：\n`;
    eps.slice(0, 5).forEach((ep, i) => {
        details += `• 第${i+1}集：${ep.title || ep.name || '未命名'}\n`;
    });
    if (eps.length > 5) details += `• ...還有 ${eps.length - 5} 集\n`;
    
    details += `\n**角色列表**：\n`;
    chars.slice(0, 5).forEach(c => {
        details += `• ${c.name}（${c.role || '角色'}）\n`;
    });
    if (chars.length > 5) details += `• ...還有 ${chars.length - 5} 個角色\n`;
    
    addAIMessage(details, [
        { text: '📥 導出', action: () => exportAll() },
        { text: '🔄 重新生成', action: () => quickGenerate() }
    ]);
}

// ==================== 检查小说内容 ====================
function checkNovelExists() {
    if (!state.novel || state.novel.length < 10) {
        addAIMessage(`⚠️ **還沒有導入小說內容**

請先選擇一種方式開始：`, [
            { text: '📄 導入現有故事', action: () => document.getElementById('fileInput').click() },
            { text: '✍️ 我要寫故事', action: () => startWriteStory() },
            { text: '🤖 AI幫我寫', action: () => startAIStoryWriting() }
        ]);
        return false;
    }
    return true;
}

// ==================== 步骤执行 ====================
async function runConceptStep() {
    if (!checkNovelExists()) return;
    
    // 标记对话式处理中
    if (currentProjectId) {
        activeProjects[currentProjectId] = true;
        delete errorProjects[currentProjectId];
        renderProjectList();
    }
    
    addTypingIndicator();
    
    // 详细步骤显示
    const steps = [
        { text: '📖 讀取小說全文...', done: false, current: true },
        { text: '📚 載入 Robert McKee《故事》方法論', done: false },
        { text: '🎯 提取核心戲劇衝突', done: false },
        { text: '🎭 分析類型/主題/基調', done: false },
        { text: '💡 生成高概念Logline', done: false }
    ];
    showAgentStatus('💡 高概念分析師', '「讓我來理解這個故事...」', 'concept', steps);
    
    try {
        // 步骤1: 读取
        await new Promise(r => setTimeout(r, 500));
        steps[0].done = true; steps[0].current = false;
        steps[1].current = true;
        showAgentStatus('💡 高概念分析師', '「載入McKee價值轉換理論...」', 'concept', steps);
        
        // 步骤2: 载入方法论
        await new Promise(r => setTimeout(r, 800));
        steps[1].done = true; steps[1].current = false;
        steps[2].current = true;
        showAgentStatus('💡 高概念分析師', '「正在提取核心戲劇衝突...」', 'concept', steps);
        
        // 步骤3: 调用AI
        await new Promise(r => setTimeout(r, 500));
        steps[2].done = true; steps[2].current = false;
        steps[3].current = true;
        showAgentStatus('💡 高概念分析師', '「FizzDragon分析中...類型/主題/基調」', 'concept', steps);
        
        const result = await callAgent('concept', state.novel.substring(0, 4000));
        
        // 步骤4完成
        steps[3].done = true; steps[3].current = false;
        steps[4].current = true;
        showAgentStatus('💡 高概念分析師', '「整理分析結果...」', 'concept', steps);
        await new Promise(r => setTimeout(r, 300));
        
        steps.forEach(s => { s.done = true; s.current = false; });
        const conceptData = safeJSONParse(result, 'concept');
        
        removeTypingIndicator();
        hideAgentStatus();
        
        // Auto-Pilot 模式：自动确认并继续
        if (state.autoPilotMode) {
            state.concept = conceptData;
            state.assets.concept = conceptData;
            state.step = 1;
            
            addAIMessage(`🚀 **高概念已自動確認**

**類型**: ${conceptData.genre || '-'}
**主題**: ${conceptData.theme || '-'}
**Logline**: ${conceptData.logline || '-'}

───────────────────────
Auto-Pilot: 進入角色設計...`);
            
            clearActiveStatus();
            saveProject();
            updateAssetsPanel();
            setTimeout(() => runCharacterAnalysis(), 1000);
            return;
        }
        
        // 对话模式：显示可编辑确认框
        showEditableResult('concept', conceptData, 
            // 确认回调
            (finalData) => {
                state.concept = finalData;
                state.assets.concept = finalData;
                state.step = 1;
                
                addAIMessage(`✅ **高概念已確認！**

**類型**: ${finalData.genre || '-'}
**主題**: ${finalData.theme || '-'}
**基調**: ${finalData.tone || '-'}

───────────────────────
已存入項目資產，接下來進行**角色分析**...`);
                
                clearActiveStatus();
                saveProject();
                updateAssetsPanel();
                setTimeout(() => runCharacterAnalysis(), 1000);
            },
            // 重新生成回调
            () => {
                addAIMessage('🔄 好的，正在重新生成高概念...');
                runConceptStep();
            }
        );
        
    } catch (err) {
        // 标记错误状态
        if (currentProjectId) {
            delete activeProjects[currentProjectId];
            errorProjects[currentProjectId] = true;
            renderProjectList();
        }
        removeTypingIndicator();
        recordError(err, '概念分析');
        showFriendlyError(err, '概念分析', () => runConceptStep());
    }
}

// 清除处理状态的辅助函数
function clearActiveStatus() {
    if (currentProjectId) {
        delete activeProjects[currentProjectId];
        delete errorProjects[currentProjectId];
        renderProjectList();
    }
}

// ==================== 角色分析（步骤2）====================
async function runCharacterAnalysis() {
    if (!checkNovelExists()) return;
    
    state.step = 2;
    addTypingIndicator();
    
    // 详细步骤显示
    const steps = [
        { text: '📖 讀取小說文本...', done: false, current: true },
        { text: '📚 載入 Bancroft《角色塑造》方法論', done: false },
        { text: '🔍 NLP識別主要角色', done: false },
        { text: '🧠 分析角色心理動機', done: false },
        { text: '🎨 生成角色視覺設計', done: false },
        { text: '✨ 輸出AI繪圖Prompt', done: false }
    ];
    showAgentStatus('👤 角色設計師', '「讓我來認識每一個角色...」', 'character', steps);
    
    try {
        // 步骤1: 读取
        await new Promise(r => setTimeout(r, 400));
        steps[0].done = true; steps[0].current = false;
        steps[1].current = true;
        showAgentStatus('👤 角色設計師', '「載入Tom Bancroft角色設計理論...」', 'character', steps);
        
        // 步骤2: 载入方法论
        await new Promise(r => setTimeout(r, 600));
        steps[1].done = true; steps[1].current = false;
        steps[2].current = true;
        showAgentStatus('👤 角色設計師', '「正在識別主角/配角/反派...」', 'character', steps);
        
        // 步骤3: NLP识别
        await new Promise(r => setTimeout(r, 500));
        steps[2].done = true; steps[2].current = false;
        steps[3].current = true;
        showAgentStatus('👤 角色設計師', '「分析角色慾望、恐懼、內心衝突...」', 'character', steps);
        
        const result = await callAgent('character', state.novel.substring(0, 4000), {
            concept: state.assets.concept
        });
        
        // 步骤4完成
        steps[3].done = true; steps[3].current = false;
        steps[4].current = true;
        showAgentStatus('👤 角色設計師', '「生成角色外貌描述...」', 'character', steps);
        await new Promise(r => setTimeout(r, 400));
        
        // 步骤5完成
        steps[4].done = true; steps[4].current = false;
        steps[5].current = true;
        showAgentStatus('👤 角色設計師', '「轉換為AI繪圖Prompt...」', 'character', steps);
        await new Promise(r => setTimeout(r, 300));
        
        steps.forEach(s => { s.done = true; s.current = false; });
        
        console.log('🔍 角色API返回:', result);
        console.log('🔍 角色API返回类型:', typeof result);
        
        // 如果result已经是对象，直接使用；否则解析
        let charData;
        if (typeof result === 'object' && result !== null) {
            charData = result;
        } else {
            charData = safeJSONParse(result, 'characters');
        }
        console.log('🔍 角色解析后:', charData);
        console.log('🔍 charData keys:', Object.keys(charData || {}));
        
        // 多种格式兼容（增强版）
        let chars = charData.characters 
            || charData.protagonists?.concat(charData.antagonists || [], charData.supporting || []) 
            || charData.character_list
            || charData.roles
            || charData.cast
            || [];
        
        // 如果还是空的，尝试直接用charData作为数组
        if ((!chars || chars.length === 0) && Array.isArray(charData)) {
            chars = charData;
        }
        
        // 如果charData有name属性，可能整个对象就是单个角色
        if ((!chars || chars.length === 0) && charData.name) {
            chars = [charData];
            console.log('🔍 单个角色对象，包装为数组');
        }
        
        // 尝试遍历charData找到任何数组类型的属性
        if (!chars || chars.length === 0) {
            for (const key in charData) {
                if (Array.isArray(charData[key]) && charData[key].length > 0 && charData[key][0]?.name) {
                    chars = charData[key];
                    console.log('🔍 找到角色数组在属性:', key);
                    break;
                }
            }
        }
        
        // 如果解析出来是空的，给一个提示
        if (!chars || chars.length === 0) {
            removeTypingIndicator();
            hideAgentStatus();
            console.error('❌ 角色解析失败，原始数据:', result);
            console.error('❌ 解析后数据:', charData);
            addAIMessage(`⚠️ **角色分析未返回結果**

AI返回的內容格式可能有問題。請重試。

<details><summary>調試信息</summary>
類型: ${typeof result}
Keys: ${Object.keys(charData || {}).join(', ') || '無'}
</details>`, [
                { text: '🔄 重新生成角色', action: () => runCharacterAnalysis() },
                { text: '⏭️ 跳過角色分析', action: () => runProductionEvaluation() }
            ]);
            return;
        }
        
        // 格式化角色数据（兼容多种AI输出格式）
        const formattedChars = chars.map(c => {
            // 提取心理层面
            const psychology = c.psychology || c['動機系統'] || {};
            const gwlt = c['G.W.L.T.框架'] || c.GWLT || {};
            const personality = c['性格特徵'] || c.personality || {};
            const arc = c['角色弧線'] || c.arc || {};
            
            // 构建完整bio
            let bioText = c.bio || c['人物小傳'] || c.biography || c.backstory || c.description || '';
            if (!bioText && (Object.keys(psychology).length > 0 || Object.keys(gwlt).length > 0)) {
                const parts = [];
                if (gwlt.ghost) parts.push(`【過去創傷】${gwlt.ghost}`);
                if (gwlt.wound) parts.push(`【心理傷口】${gwlt.wound}`);
                if (gwlt.lie) parts.push(`【錯誤信念】${gwlt.lie}`);
                if (gwlt.truth) parts.push(`【需要領悟】${gwlt.truth}`);
                if (psychology.want) parts.push(`【表面慾望】${psychology.want}`);
                if (psychology.need) parts.push(`【深層需求】${psychology.need}`);
                if (psychology.conflict) parts.push(`【內在衝突】${psychology.conflict}`);
                if (personality['正面']) parts.push(`【正面特質】${Array.isArray(personality['正面']) ? personality['正面'].join('、') : personality['正面']}`);
                if (personality['負面']) parts.push(`【負面特質】${Array.isArray(personality['負面']) ? personality['負面'].join('、') : personality['負面']}`);
                if (arc.type) parts.push(`【角色弧線】${arc.type}: ${arc['起點'] || ''} → ${arc['終點'] || ''}`);
                bioText = parts.join('\n');
            }
            
            // 提取视觉层面
            const visual = c.visual || c['視覺設計'] || c.visualDesign || {};
            let appearanceText = c.appearance || c['外貌特徵'] || c.physical || '';
            if (!appearanceText && Object.keys(visual).length > 0) {
                const vParts = [];
                if (visual.age) vParts.push(`${visual.age}歲`);
                if (visual.gender) vParts.push(visual.gender);
                if (visual.height) vParts.push(`身高${visual.height}`);
                if (visual.build) vParts.push(visual.build);
                if (visual.hair) vParts.push(`髮型：${visual.hair}`);
                if (visual.face) vParts.push(`臉部：${visual.face}`);
                if (visual['服裝風格']) vParts.push(`服裝：${visual['服裝風格']}`);
                if (visual['視覺符號']) vParts.push(`符號：${visual['視覺符號']}`);
                appearanceText = vParts.join('，');
            }
            
            const promptValue = c.prompt || c.ai_prompt || c.image_prompt || c['AI Prompt'] || '';
            console.log(`🔍 角色 ${c.name}: prompt=${c.prompt?.substring(0,30)}, ai_prompt=${c.ai_prompt?.substring(0,30)}, final=${promptValue?.substring(0,30)}`);
            
            return {
                name: c.name || '未命名',
                role: c.role || c.type || '角色',
                bio: bioText || '(需補充人物小傳)',
                appearance: appearanceText || '(需補充外貌描述)',
                prompt: promptValue
            };
        });
        
        console.log('✅ 格式化角色:', formattedChars);
        
        removeTypingIndicator();
        hideAgentStatus();
        
        // Auto-Pilot 模式：自动确认并继续
        if (state.autoPilotMode) {
            state.assets.characters = formattedChars;
            
            addAIMessage(`🚀 **角色已自動確認**

共 **${formattedChars.length}** 個角色：
${formattedChars.map(c => `• ${c.name} (${c.role})`).join('\n')}

───────────────────────
Auto-Pilot: 進入製作設置...`);
            
            saveProject();
            updateAssetsPanel();
            setTimeout(() => runProductionEvaluation(), 1000);
            return;
        }
        
        // 对话模式：显示可编辑确认框
        showEditableResult('characters', formattedChars,
            // 确认回调
            (finalData) => {
                // 🔧 使用编辑后的数据（包含完整的bio/appearance/prompt）
                state.assets.characters = finalData;
                
                // 详细角色列表
                const charDetails = finalData.map(c => {
                    const bio = c.bio ? `\n   📖 ${c.bio.substring(0, 80)}${c.bio.length > 80 ? '...' : ''}` : '';
                    const prompt = c.prompt ? `\n   🎨 ${c.prompt.substring(0, 60)}...` : '';
                    return `• **${c.name}** (${c.role})${bio}${prompt}`;
                }).join('\n\n');
                
                addAIMessage(`✅ **角色已確認！**

${charDetails}

───────────────────────
共 **${finalData.length}** 個角色已存入資產
接下來設置**製作參數**...`);
                
                saveProject();
                updateAssetsPanel();
                setTimeout(() => runProductionEvaluation(), 1000);
            },
            // 重新生成回调
            () => {
                addAIMessage('🔄 好的，正在重新分析角色...');
                runCharacterAnalysis();
            }
        );
        
    } catch (err) {
        removeTypingIndicator();
        hideAgentStatus();
        showFriendlyError(err, '角色分析', () => runCharacterAnalysis());
    }
}

// ==================== 智能评估建议 ====================
async function runProductionEvaluation() {
    if (!state.novel) {
        askProductionSettings();
        return;
    }
    
    addTypingIndicator();
    showAgentStatus('🎯 製作評估師', '「正在分析作品規模...」', 'concept');
    
    try {
        // 基础数据分析
        const novelLength = state.novel.length;
        const charCount = state.assets?.characters?.length || 0;
        const conceptGenre = state.assets?.concept?.genre || '劇情';
        const conceptTone = state.assets?.concept?.tone || '中性';
        
        // 智能评估算法
        let suggestedEpisodes, suggestedDuration, suggestedDensity, reasoning;
        
        // 根据字数估算（中文约500字/分钟叙事）
        const estimatedMinutes = Math.round(novelLength / 400);
        
        if (novelLength < 10000) {
            // 短篇 < 1万字
            suggestedEpisodes = Math.max(3, Math.min(8, Math.ceil(estimatedMinutes / 3)));
            suggestedDuration = 3;
            suggestedDensity = 12;
            reasoning = `📚 **短篇作品**（${novelLength.toLocaleString()}字）\n適合製作精品短劇，節奏緊湊`;
        } else if (novelLength < 50000) {
            // 中篇 1-5万字
            suggestedEpisodes = Math.max(10, Math.min(24, Math.ceil(estimatedMinutes / 4)));
            suggestedDuration = 5;
            suggestedDensity = 10;
            reasoning = `📖 **中篇作品**（${novelLength.toLocaleString()}字）\n適合製作標準番劇，情節完整`;
        } else if (novelLength < 150000) {
            // 长篇 5-15万字
            suggestedEpisodes = Math.max(20, Math.min(40, Math.ceil(estimatedMinutes / 5)));
            suggestedDuration = 5;
            suggestedDensity = 10;
            reasoning = `📕 **長篇作品**（${novelLength.toLocaleString()}字）\n建議分季製作，每季12-24集`;
        } else {
            // 超长篇 > 15万字
            suggestedEpisodes = 30;
            suggestedDuration = 8;
            suggestedDensity = 10;
            reasoning = `📚 **超長篇作品**（${novelLength.toLocaleString()}字）\n建議先製作第一季（30集），後續分季`;
        }
        
        // 根据类型微调
        if (conceptGenre.includes('動作') || conceptGenre.includes('懸疑')) {
            suggestedDensity = Math.min(15, suggestedDensity + 3);
        } else if (conceptGenre.includes('文藝') || conceptGenre.includes('愛情')) {
            suggestedDensity = Math.max(8, suggestedDensity - 2);
        }
        
        // 计算总镜头
        const totalShots = suggestedEpisodes * suggestedDuration * suggestedDensity;
        const totalMinutes = suggestedEpisodes * suggestedDuration;
        
        // 节奏描述
        let paceIcon = '⚖️';
        let paceDesc = '中等節奏';
        if (suggestedDensity >= 13) { paceIcon = '🚀'; paceDesc = '快節奏動作戲'; }
        else if (suggestedDensity <= 9) { paceIcon = '🎭'; paceDesc = '慢節奏文藝片'; }
        
        removeTypingIndicator();
        hideAgentStatus();
        
        // 保存建议值
        const suggestion = { 
            episodes: suggestedEpisodes, 
            duration: suggestedDuration, 
            density: suggestedDensity,
            totalShots,
            totalMinutes
        };
        
        // Auto-Pilot 模式：自动采用建议
        if (state.autoPilotMode) {
            addAIMessage(`🚀 **Auto-Pilot 自動採用建議**

📊 ${suggestedEpisodes}集 × ${suggestedDuration}分鐘 × ${suggestedDensity}鏡/分
📈 總分鏡: **${totalShots.toLocaleString()}** 個

───────────────────────
Auto-Pilot: 進入章節規劃...`);
            
            applyProductionSuggestion(suggestion);
            return;
        }
        
        // 对话模式：显示选项
        addAIMessage(`🎯 **智能製作評估**

${reasoning}

───────────────────────
📊 **AI 建議規格**：
• 集數：**${suggestedEpisodes}** 集
• 時長：**${suggestedDuration}** 分鐘/集
• 鏡頭密度：**${suggestedDensity}** 個/分鐘
• ${paceIcon} ${paceDesc}

📈 **產出預估**：
• 總時長：${totalMinutes} 分鐘
• 總分鏡：**${totalShots.toLocaleString()}** 個

───────────────────────
💡 這是基於作品規模的智能建議，你可以：`, [
            { text: `✅ 採用建議 (${suggestedEpisodes}集×${suggestedDuration}分)`, action: () => applyProductionSuggestion(suggestion) },
            { text: '✏️ 自己設定', action: () => askProductionSettings() }
        ]);
        
    } catch (err) {
        removeTypingIndicator();
        hideAgentStatus();
        console.error('評估失敗:', err);
        // 出错时直接进入手动设置
        askProductionSettings();
    }
}

// 应用AI建议的规格
function applyProductionSuggestion(suggestion) {
    state.production.episodes = suggestion.episodes;
    state.production.durationMin = suggestion.duration;
    state.production.shotsPerMin = suggestion.density;
    state.production.totalShots = suggestion.totalShots;
    
    addAIMessage(`✅ **已採用AI建議規格**

📊 **製作規格**:
• ${suggestion.episodes} 集 × ${suggestion.duration} 分鐘
• 鏡頭密度: ${suggestion.density} 個/分鐘
• 預計分鏡: **${suggestion.totalShots.toLocaleString()}** 個

───────────────────────
正在生成**章節規劃**...`);
    
    saveProject();
    setTimeout(() => runChapterPlanning(), 1000);
}

// ==================== 制作设置问答（纯对话式）====================
let productionStep = 0;  // 0=集数, 1=时长, 2=密度, 3=完成

function askProductionSettings() {
    productionStep = 0;
    state.step = 1.5;  // 制作设置阶段
    
    addAIMessage(`🎬 **製作規格設定 (1/3)**

你希望這部作品分成多少集？

───────────────────────
💡 直接輸入數字，例如：10、20、30
建議：短篇5-10集，中篇15-25集，長篇30+集`);
}

function handleProductionInput(text) {
    const num = parseInt(text.trim());
    
    if (productionStep === 0) {
        // 集数
        if (isNaN(num) || num < 1 || num > 100) {
            addAIMessage(`❌ 請輸入有效的集數（1-100之間的數字）`);
            return;
        }
        state.production.episodes = num;
        productionStep = 1;
        
        addAIMessage(`✅ 已設定 **${num}** 集

🎬 **製作規格設定 (2/3)**

每集大約多少分鐘？

───────────────────────
💡 直接輸入數字，例如：3、5、10
AI番劇建議：2-10分鐘/集`);
        
    } else if (productionStep === 1) {
        // 时长
        if (isNaN(num) || num < 1 || num > 30) {
            addAIMessage(`❌ 請輸入有效的時長（1-30分鐘之間的數字）`);
            return;
        }
        state.production.durationMin = num;
        productionStep = 2;
        
        addAIMessage(`✅ 已設定每集 **${num}** 分鐘

🎬 **製作規格設定 (3/3)**

選擇鏡頭節奏：

**🐢 低密度 (6-10鏡/分鐘)**
適合：文藝片、情感劇、對話戲
特點：長鏡頭、慢節奏、注重氛圍營造
參考：《花樣年華》《東京物語》

**⚖️ 中密度 (10-14鏡/分鐘)**
適合：劇情片、家庭劇、日常番
特點：節奏適中、敘事流暢、情節緊湊
參考：《霸王別姬》《千與千尋》

**🚀 高密度 (15-20鏡/分鐘)**
適合：動作片、懸疑劇、快節奏敘事
特點：快速剪輯、視覺衝擊、緊張刺激
參考：《諜影重重》《瘋狂的麥克斯》`, [
            { text: '🐢 低 (6-10/分)', action: () => setShotDensity(8, '低') },
            { text: '⚖️ 中 (10-14/分)', action: () => setShotDensity(12, '中') },
            { text: '🚀 高 (15-20/分)', action: () => setShotDensity(17, '高') }
        ]);
        
    } else if (productionStep === 2) {
        // 镜头密度 - 也支持直接输入数字
        if (isNaN(num) || num < 5 || num > 30) {
            addAIMessage(`❌ 請選擇上方按鈕，或輸入有效數字（5-30）`);
            return;
        }
        finalizeShotDensity(num);
    }
}

function setShotDensity(density, level) {
    addUserMessage(`鏡頭節奏: ${level}`);
    finalizeShotDensity(density);
}

function finalizeShotDensity(num) {
    state.production.shotsPerMin = num;
    state.production.totalShots = state.production.episodes * state.production.durationMin * num;
    productionStep = 3;
    state.step = 3;  // 章节规划阶段
    
    // 根据密度给出节奏描述
    let paceDesc = '';
    if (num <= 10) paceDesc = '🐢 慢節奏 - 適合文藝片、對話戲';
    else if (num <= 14) paceDesc = '⚖️ 中等節奏 - 適合劇情片、日常番';
    else paceDesc = '🚀 快節奏 - 適合動作戲、懸疑劇';
    
    addAIMessage(`✅ **製作規格確認**

📊 **你的番劇規格**:
• 集數: ${state.production.episodes} 集
• 每集時長: ${state.production.durationMin} 分鐘
• 鏡頭密度: ${state.production.shotsPerMin} 個/分鐘
• 總時長: ${state.production.episodes * state.production.durationMin} 分鐘
• 預計分鏡: **${state.production.totalShots}** 個

${paceDesc}

───────────────────────
正在生成**章節規劃**...`);
    
    // 生成章节规划
    saveProject();
    setTimeout(() => runChapterPlanning(), 1000);
}

// ==================== 章节规划（步骤3）====================
async function runChapterPlanning() {
    if (!checkNovelExists()) return;
    
    addTypingIndicator();
    
    // 详细步骤
    const steps = [
        { text: '📊 分析故事架構...', done: false, current: true },
        { text: '📚 載入 Blake Snyder《Save the Cat》15節拍', done: false },
        { text: '🎭 套用三幕劇結構模型', done: false },
        { text: '📝 設計各集情節要點', done: false },
        { text: '⏱️ 計算時長與節奏分配', done: false }
    ];
    showAgentStatus('📝 章節規劃師', '「正在規劃故事節奏...」', 'narrative', steps);
    
    try {
        // 步骤1: 分析
        await new Promise(r => setTimeout(r, 400));
        steps[0].done = true; steps[0].current = false;
        steps[1].current = true;
        showAgentStatus('📝 章節規劃師', '「載入Blake Snyder 15節拍表...」', 'narrative', steps);
        
        // 步骤2: 方法论
        await new Promise(r => setTimeout(r, 600));
        steps[1].done = true; steps[1].current = false;
        steps[2].current = true;
        showAgentStatus('📝 章節規劃師', '「劃分起/承/轉/合關鍵節點...」', 'narrative', steps);
        
        // 步骤3: 三幕剧
        await new Promise(r => setTimeout(r, 500));
        steps[2].done = true; steps[2].current = false;
        steps[3].current = true;
        showAgentStatus('📝 章節規劃師', '「FizzDragon規劃各集情節...」', 'narrative', steps);
        
        // 🔧 明确告诉AI需要生成多少集
        const episodeCount = state.production.episodes || 10;
        const novelWithInstructions = `【重要指令】請規劃 ${episodeCount} 集的章節大綱，必須輸出 ${episodeCount} 個章節，不能多也不能少！

---以下是小說內容---
${state.novel.substring(0, 5000)}`;
        
        const result = await callAgent('narrative', novelWithInstructions, {
            concept: state.assets.concept,
            characters: state.assets.characters,
            targetEpisodes: episodeCount,
            durationPerEp: state.production.durationMin,
            instruction: `必須生成恰好 ${episodeCount} 個章節！`
        });
        
        steps[1].done = true; steps[1].current = false;
        steps[2].done = true; steps[3].done = true;
        
        const chapData = safeJSONParse(result, 'chapters');
        const chapters = chapData.chapters || chapData.episodes || [];
        
        // 🔧 检查章节数量是否符合要求
        const targetCount = state.production.episodes || 10;
        if (chapters.length < targetCount) {
            console.warn(`⚠️ 章節數量不足: 需要${targetCount}集，只生成了${chapters.length}集`);
        }
        
        // 存入项目资产（包含完整信息）
        state.assets.chapters = chapters.map((c, i) => ({
            number: c.number || i + 1,
            title: c.title || `第${i+1}集`,
            phase: c.phase || '',           // 起/承/转/合
            duration: c.duration || state.production.durationMin,
            summary: c.summary || c.description || '',
            highlight: c.highlight || '',    // 亮点
            conflict: c.conflict || '',      // 冲突
            emotion: c.emotion || '',        // 情感走向
            hook: c.hook || ''               // 悬念钩子
        }));
        
        removeTypingIndicator();
        hideAgentStatus();
        
        // 计算起承转合结构
        const total = state.assets.chapters.length;
        const structure = {
            起: Math.ceil(total * 0.1),  // 10% 开篇
            承: Math.ceil(total * 0.3),  // 30% 发展
            转: Math.ceil(total * 0.4),  // 40% 高潮
            合: total - Math.ceil(total * 0.1) - Math.ceil(total * 0.3) - Math.ceil(total * 0.4)  // 剩余 结局
        };
        
        // 显示全部章节列表（详细信息）
        const chapterList = state.assets.chapters.map((c, i) => {
            // 优先使用API返回的phase，否则根据位置计算
            let phase = c.phase || '';
            if (!phase) {
                if (i < structure.起) phase = '起';
                else if (i < structure.起 + structure.承) phase = '承';
                else if (i < structure.起 + structure.承 + structure.转) phase = '转';
                else phase = '合';
            }
            
            let details = `**【${phase}】第${c.number}集 ${c.title}**`;
            if (c.summary) details += `\n   📖 ${c.summary.substring(0, 60)}${c.summary.length > 60 ? '...' : ''}`;
            if (c.highlight) details += `\n   🌟 亮點: ${c.highlight}`;
            if (c.conflict) details += `\n   ⚔️ 衝突: ${c.conflict}`;
            if (c.hook) details += `\n   🎣 懸念: ${c.hook}`;
            return details;
        }).join('\n\n');
        
        // 检查是否达到目标集数 (复用上面的targetCount)
        const actualCount = state.assets.chapters.length;
        const isShort = actualCount < targetCount;
        
        const warningMsg = isShort 
            ? `\n\n⚠️ **注意：您要求${targetCount}集，實際生成了${actualCount}集**\n如果不滿意，可以點擊重新生成。`
            : '';
        
        // 🔧 使用可编辑确认框，让用户可以修改
        showEditableResult('chapters', state.assets.chapters,
            // 确认回调
            (finalData) => {
                state.assets.chapters = finalData;
                state.step = 4;
                
                // 🔧 调试：确认保存前的资产状态
                console.log('✅ 分章确认，保存前资产:', {
                    concept: !!state.assets.concept,
                    characters: state.assets.characters?.length || 0,
                    chapters: finalData.length
                });
                
                addAIMessage(`✅ **章節規劃已確認！** (${finalData.length}集)

📊 **故事結構**
${finalData.slice(0, 3).map(c => `• 第${c.number}集「${c.title}」`).join('\n')}
${finalData.length > 3 ? `...還有 ${finalData.length - 3} 集` : ''}

───────────────────────
已存入項目資產，接下來進行**服化道設計**...`);
                
                saveProject();
                updateAssetsPanel();
                setTimeout(() => runProductionDesign(), 1000);
            },
            // 重新生成回调
            () => {
                addAIMessage('🔄 好的，正在重新規劃章節...');
                runChapterPlanning();
            }
        );
        
    } catch (err) {
        removeTypingIndicator();
        hideAgentStatus();
        showFriendlyError(err, '章節規劃', () => runChapterPlanning());
    }
}

// ==================== 服化道设计（步骤4）====================
async function runProductionDesign() {
    if (!checkNovelExists()) return;
    
    addTypingIndicator();
    
    // 详细步骤
    const steps = [
        { text: '🏛️ 調用時代背景資料庫...', done: false, current: true },
        { text: '👔 啟動服裝設計模組', done: false },
        { text: '🏠 生成場景佈景方案', done: false },
        { text: '🔧 列出關鍵道具清單', done: false }
    ];
    showAgentStatus('👗 服化道設計師', '「正在研究時代風格...」', 'production_design', steps);
    
    try {
        steps[0].done = true; steps[0].current = false;
        steps[1].current = true;
        showAgentStatus('👗 服化道設計師', '「為每個角色設計專屬造型...」', 'production_design', steps);
        
        const result = await callAgent('production_design', state.novel.substring(0, 3000), {
            concept: state.assets.concept,
            characters: state.assets.characters,
            chapters: state.assets.chapters
        });
        
        console.log('🔍 production_design 原始返回:', result);
        console.log('🔍 production_design 返回类型:', typeof result);
        
        steps.forEach(s => { s.done = true; s.current = false; });
        
        // 如果result已经是对象，直接使用
        let designData;
        if (typeof result === 'object' && result !== null) {
            designData = result;
        } else {
            designData = safeJSONParse(result, 'production_design');
        }
        
        console.log('🔍 production_design 解析后:', designData);
        
        // 准备服化道数据
        const costumes = designData.costumes || [];
        const sets = designData.sets || designData.scenes || designData.locations || [];
        const props = designData.props || [];
        
        removeTypingIndicator();
        hideAgentStatus();
        
        // 格式化为可编辑文本
        const productionData = { costumes, sets, props };
        
        // 显示可编辑确认框
        showEditableResult('production', productionData,
            // 确认回调
            (finalData) => {
                state.assets.costumes = finalData.costumes || [];
                state.assets.sets = finalData.sets || [];
                state.assets.props = finalData.props || [];
                
                const costumeCount = state.assets.costumes.length;
                const setCount = state.assets.sets.length;
                const propCount = state.assets.props.length;
                
                addAIMessage(`✅ **服化道已確認！**

• 👔 服裝: ${costumeCount} 套
• 🏠 場景: ${setCount} 個
• 🎭 道具: ${propCount} 件

───────────────────────
已存入項目資產，接下來開始**寫劇本**（第1集）...`);
                
                state.step = 5;
                state.currentChapter = 1;
                saveProject();
                updateAssetsPanel();
                setTimeout(() => runScriptWriting(1), 1000);
            },
            // 重新生成回调
            () => {
                addAIMessage('🔄 好的，正在重新設計服化道...');
                runProductionDesign();
            }
        );
        
    } catch (err) {
        removeTypingIndicator();
        hideAgentStatus();
        showFriendlyError(err, '服化道設計', () => runProductionDesign());
    }
}

// ==================== 剧本写作（步骤5，分章）====================
async function runScriptWriting(chapterNum) {
    if (!checkNovelExists()) return;
    
    const chapter = state.assets.chapters?.[chapterNum - 1];
    if (!chapter) {
        addAIMessage(`⚠️ **第${chapterNum}集不存在**

${state.assets.chapters?.length > 0 
    ? `目前有 ${state.assets.chapters.length} 集，請輸入「生成第1集劇本」到「生成第${state.assets.chapters.length}集劇本」`
    : '請先生成章節規劃，輸入「生成章節」'}`, [
            { text: '📝 生成章節規劃', action: () => runChapterPlanning() }
        ]);
        return;
    }
    
    addTypingIndicator();
    
    // 详细步骤
    const steps = [
        { text: '📋 正在讀取章節大綱...', done: false, current: true },
        { text: '🔗 載入前集劇情上下文', done: false },
        { text: '🎬 調用場景結構模板', done: false },
        { text: '💬 生成角色對話台詞', done: false },
        { text: '🎭 添加表演動作描述', done: false }
    ];
    showAgentStatus('✍️ 編劇', `「第${chapterNum}集，讓我構思一下...」`, 'screenwriter', steps);
    
    try {
        // 获取前面章节作为上下文
        steps[0].done = true; steps[0].current = false;
        steps[1].current = true;
        showAgentStatus('✍️ 編劇', '「回顧一下前面的劇情...」', 'screenwriter', steps);
        
        const prevScripts = [];
        for (let i = Math.max(1, chapterNum - 2); i < chapterNum; i++) {
            if (state.assets.scripts[i]) {
                prevScripts.push(`【第${i}集摘要】${state.assets.scripts[i].substring(0, 500)}...`);
            }
        }
        
        steps[1].done = true; steps[1].current = false;
        steps[2].current = true;
        showAgentStatus('✍️ 編劇', '「靈感來了，正在撰寫...」', 'screenwriter', steps);
        
        // 计算目标字数（1分钟约300-400字对白+动作描写）
        const durationMin = state.production?.durationMin || 3;
        const targetWords = durationMin * 400;  // 每分钟400字
        
        const context = {
            concept: state.assets.concept,
            characters: state.assets.characters,
            chapter: chapter,
            previousScripts: prevScripts.join('\n'),
            costumes: state.assets.costumes,
            production: state.production,
            duration: durationMin,
            targetWords: targetWords,
            instruction: `【重要】本集時長 ${durationMin} 分鐘，劇本必須達到 ${targetWords} 字以上！不要寫太短！`
        };
        
        // 在小说内容前加明确的字数要求
        const novelWithInstructions = `【編劇指令】請為第${chapterNum}集寫完整劇本
- 時長要求：${durationMin} 分鐘
- 字數要求：至少 ${targetWords} 字（約 ${Math.ceil(targetWords/100)} 段場景）
- 必須包含：場景描寫、動作指示、完整對白
- 格式：【場景N：地點 - 時間】

---以下是原著參考---
${state.novel.substring(0, 2000)}`;
        
        // 🔧 使用流式API避免Cloudflare超时
        let result = await callAgentStream('screenwriter', novelWithInstructions, context, 
            (chunk, fullText) => {
                // 实时更新显示
                updateAgentStatus('✍️ 編劇', `生成中... ${fullText.length}字`);
            }
        );
        
        // 🔧 清理Markdown标记（剧本不需要**粗体**）
        result = cleanScriptMarkdown(result);
        
        // 标记全部完成
        steps.forEach(s => { s.done = true; s.current = false; });
        
        // 存入项目资产
        state.assets.scripts[chapterNum] = result;
        state.currentChapter = chapterNum;
        
        removeTypingIndicator();
        hideAgentStatus();
        
        addAIMessage(`✍️ **第${chapterNum}集劇本完成！**

📄 **${chapter.title}**
${result.substring(0, 300)}...

───────────────────────
✅ 已存入項目資產

${chapterNum < state.assets.chapters.length ? `繼續寫第${chapterNum + 1}集...` : '全部劇本完成！'}`);
        
        saveProject();
        
        if (chapterNum < state.assets.chapters.length) {
            // 继续下一集
            setTimeout(() => runScriptWriting(chapterNum + 1), 1500);
        } else {
            // 全部完成，自动开始生成分镜
            state.step = 6;
            addAIMessage(`🎬 **劇本全部完成！共 ${state.assets.chapters.length} 集**

現在自動開始生成分鏡...`, [
                { text: '📥 導出劇本(Word)', action: () => exportScripts() }
            ]);
            
            // 自动开始第1集分镜
            setTimeout(() => runStoryboardGeneration(1), 1500);
        }
        
    } catch (err) {
        removeTypingIndicator();
        hideAgentStatus();
        showFriendlyError(err, `第${chapterNum}集劇本`, () => runScriptWriting(chapterNum));
    }
}

// ==================== 导入模式访谈 ====================
async function startImportInterview() {
    addAIMessage(`🎤 **深度訪談模式**

首先讓我分析一下故事概念，然後設計針對性問題...`);
    
    // 先做概念分析
    addTypingIndicator();
    try {
        const result = await callAgent('concept', state.novel.substring(0, 4000));
        state.concept = safeJSONParse(result, 'concept');
        state.assets.concept = state.concept;
        removeTypingIndicator();
        
        addAIMessage(`📖 **概念分析完成**

**類型**: ${state.concept.genre || '-'}
**主題**: ${state.concept.theme || '-'}

現在根據故事內容設計訪談問題...`);
        
        // 然后开始访谈
        state.step = 2;  // 访谈阶段
        await startInterview();
        
    } catch (err) {
        removeTypingIndicator();
        addAIMessage(`⚠️ 概念分析失敗，直接進入通用訪談...`);
        state.step = 2;
        await startInterview();
    }
}

async function startInterview() {
    // 生成访谈问题 - 调用访谈智能体
    addTypingIndicator();
    showAgentStatus('🎤 訪談師', '分析故事，設計問題...', 'interview');
    
    try {
        // 传入更多小说内容（6000字符）让AI能提取具体人物和情节
        const result = await callAgent('interview', state.novel.substring(0, 6000), {
            concept: state.concept,
            novel: state.novel.substring(0, 6000)  // 额外传 novel 字段确保后端能识别
        });
        
        console.log('訪談Agent返回:', result?.substring(0, 200));
        
        // 解析问题
        const questions = extractQuestions(result);
        console.log('提取到問題:', questions);
        
        if (questions.length > 0) {
            state.interviewQuestions = questions;
            state.currentQuestion = 0;
            
            removeTypingIndicator();
            hideAgentStatus();
            
            addAIMessage(`🎤 **訪談師** 根據你的故事設計了 ${questions.length} 個針對性問題：`);
            
            // 问第一个问题
            setTimeout(() => askNextQuestion(), 500);
        } else {
            throw new Error('未能提取到問題');
        }
        
    } catch (err) {
        console.error('訪談生成失敗:', err);
        removeTypingIndicator();
        hideAgentStatus();
        
        // 使用默认问题
        state.interviewQuestions = [
            '你創作這個故事的初衷是什麼？想傳達什麼核心信息？',
            '故事中哪個角色最打動你？為什麼？',
            '你希望觀眾看完後有什麼感受？',
            '有參考過其他作品的風格嗎？',
            '對視覺呈現有什麼想法？'
        ];
        state.currentQuestion = 0;
        
        addAIMessage(`⚠️ 訪談師暫時離線，使用通用問題：

我會問你 5 個問題，幫助我更好地理解你的創作意圖。`);
        
        setTimeout(() => askNextQuestion(), 500);
    }
}

function extractQuestions(text) {
    // 提取问题列表 - 支持多种格式
    const questions = [];
    
    // 方法1: 优先提取「」引号内的问题
    const quoted = text.match(/「([^」]+[？?])」/g);
    if (quoted) {
        quoted.forEach(q => {
            const clean = q.replace(/[「」]/g, '').trim();
            if (clean.length > 5 && !questions.includes(clean)) {
                questions.push(clean);
            }
        });
    }
    
    // 如果已经提取到足够的问题，直接返回
    if (questions.length >= 5) {
        return questions.slice(0, 5);
    }
    
    // 方法2: 提取其他包含问号的句子（去重）
    const lines = text.split('\n');
    for (const line of lines) {
        if ((line.includes('?') || line.includes('？')) && line.length > 10) {
            // 清理格式
            let clean = line.replace(/^[\d\.\)、\-\*\s]+/, '').trim();
            clean = clean.replace(/^\*\*[^*]+\*\*\s*/, ''); // 移除**标题**
            clean = clean.replace(/^「|」$/g, '').trim();
            
            if (clean.length > 10 && clean.length < 150) {
                // 检查是否已存在类似问题
                const isDuplicate = questions.some(q => 
                    q.includes(clean.substring(0, 15)) || clean.includes(q.substring(0, 15))
                );
                if (!isDuplicate) {
                    questions.push(clean);
                }
            }
        }
    }
    
    // 返回前5个问题，如果没有提取到则用默认问题
    return questions.length > 0 ? questions.slice(0, 5) : [
        '你創作這個故事的初衷是什麼？想傳達什麼核心信息？',
        '故事中哪個角色最打動你？為什麼？',
        '你希望觀眾看完後有什麼感受？',
        '有沒有參考過其他作品的風格？',
        '對視覺風格有什麼想法？（比如色調、氛圍）'
    ];
}

function askNextQuestion() {
    if (state.currentQuestion >= state.interviewQuestions.length) {
        // 访谈结束
        finishInterview();
        return;
    }
    
    const q = state.interviewQuestions[state.currentQuestion];
    const num = state.currentQuestion + 1;
    const total = state.interviewQuestions.length;
    
    // 纯对话式：不显示按钮，用户直接在输入框回答
    addAIMessage(`🎤 **創意訪談 (${num}/${total})**

${q}`, [
        { text: '⏭️ 跳過這題', action: () => skipQuestion() }
    ]);
}

function skipQuestion() {
    state.interview[state.currentQuestion] = '(跳過)';
    state.currentQuestion++;
    askNextQuestion();
}

async function finishInterview() {
    addAIMessage(`✅ 訪談完成！感謝你的分享。

你的想法會融入到角色設計和章節規劃中。

接下來進行**角色分析**...`);
    
    // 继续角色分析流程
    saveProject();
    setTimeout(() => runCharacterAnalysis(), 1000);
}

async function runChaptersStep() {
    addProgressCard('生成章節規劃', 0);
    
    try {
        const context = {
            concept: state.concept,
            interview: state.interview
        };
        
        // 🔧 修复Bug#3: 防止null.substring()错误
        const novelText = state.novel || writeState.idea?.premise || writeState.outline?.synopsis || '';
        
        updateProgress(30);
        const result = await callAgent('narrative', novelText.substring(0, 5000), context);
        updateProgress(100);
        
        state.chapters = safeJSONParse(result, 'chapters');
        state.step = 3;  // 标记章节规划完成
        
        removeProgressCard();
        
        const eps = state.chapters.chapters || state.chapters.episodes || [];
        addAIMessage(`📝 **章節規劃完成！** 共 ${eps.length} 集

${eps.slice(0, 3).map((ep, i) => `• 第${i+1}集: ${ep.title || ep.name || '未命名'}`).join('\n')}
${eps.length > 3 ? `• ...還有 ${eps.length - 3} 集` : ''}

⏳ 正在設計角色...`);
        
        // 🔧 自动继续下一步
        saveProject();
        setTimeout(() => runCharacterStep(), 1000);
        
    } catch (err) {
        removeProgressCard();
        recordError(err, '章節規劃');
        showFriendlyError(err, '章節規劃', () => runChaptersStep());
    }
}

async function runCharacterStep() {
    addProgressCard('生成角色設計', 0);
    
    try {
        const context = {
            concept: state.concept,
            chapters: state.chapters
        };
        
        // 🔧 修复Bug#3: 防止null.substring()错误
        const novelText = state.novel || writeState.outline?.synopsis || JSON.stringify(state.chapters) || '';
        
        updateProgress(30);
        const result = await callAgent('character', novelText.substring(0, 4000), context);
        updateProgress(100);
        
        state.characters = safeJSONParse(result, 'characters');
        state.step = 4;  // 标记角色设计完成
        
        removeProgressCard();
        
        const chars = state.characters.characters || [];
        addAIMessage(`👤 **角色設計完成！** 共 ${chars.length} 個角色

${chars.slice(0, 3).map(c => `• **${c.name}** (${c.role || '角色'})`).join('\n')}

⏳ 正在生成分鏡表...`);
        
        // 🔧 自动继续下一步
        saveProject();
        setTimeout(() => runStoryboardStep(), 1000);
        
    } catch (err) {
        removeProgressCard();
        recordError(err, '角色設計');
        showFriendlyError(err, '角色設計', () => runCharacterStep());
    }
}

async function runStoryboardStep() {
    const targetShots = state.production?.totalShots || 100;
    const episodes = state.production?.episodes || 10;
    const shotsPerEp = Math.ceil(targetShots / episodes);
    
    addProgressCard(`生成分鏡表 (目標: ${targetShots} 個鏡頭)`, 0);
    
    try {
        // 包含制作设置
        const context = {
            concept: state.concept,
            chapters: state.chapters,
            characters: state.characters,
            production: state.production,  // 传递制作设置
            targetShots: targetShots,
            shotsPerEpisode: shotsPerEp
        };
        
        // 🔧 修复Bug#3: 防止null.substring()错误
        const novelText = state.novel || writeState.outline?.synopsis || JSON.stringify(state.chapters) || '';
        
        // 添加制作要求到内容
        const contentWithSpecs = `${novelText.substring(0, 2500)}

【製作規格要求】
- 總集數: ${episodes} 集
- 每集時長: ${state.production?.durationMin || 3} 分鐘
- 每集鏡頭: ${shotsPerEp} 個
- 總鏡頭數: ${targetShots} 個
請按照以上規格生成完整的分鏡表。`;
        
        updateProgress(30);
        const result = await callAgent('storyboard', contentWithSpecs, context);
        updateProgress(100);
        
        // 解析分镜结果
        const storyboardData = safeJSONParse(result, 'storyboard');
        state.storyboard = storyboardData;
        state.step = 5;  // 标记分镜完成
        
        removeProgressCard();
        saveProject();
        
        // 统计分镜数量
        const shots = storyboardData?.shots || storyboardData?.storyboard || [];
        const shotCount = Array.isArray(shots) ? shots.length : 0;
        const epCount = (state.chapters?.chapters || state.chapters?.episodes || []).length;
        const charCount = (state.characters?.characters || []).length;
        
        // 检查是否达到目标
        const completion = Math.round((shotCount / targetShots) * 100);
        const status = shotCount >= targetShots * 0.8 ? '✅ 達標' : `⚠️ ${completion}%`;
        
        addAIMessage(`🎬 **分鏡表生成完成！**

📊 **製作資料統計**:
• 故事概念: ✅
• 章節規劃: ${epCount} 集
• 角色設計: ${charCount} 個
• 分鏡鏡頭: ${shotCount} / ${targetShots} 個 ${status}

🎉 你的AI番劇製作資料已完成！

───────────────────────
導出你的作品：`, [
            { text: '📥 導出Excel', action: () => exportExcel() },
            { text: '📥 導出JSON', action: () => exportAll() }
        ]);
        
    } catch (err) {
        removeProgressCard();
        recordError(err, '分鏡生成');
        showFriendlyError(err, '分鏡生成', () => runStoryboardStep());
    }
}

// ==================== 智能体名称映射 ====================
const AGENT_NAMES = {
    concept: '💡 概念生成器',
    interview: '🎤 訪談師',
    narrative: '📝 章節規劃師',
    character: '👤 角色設計師',
    storyboard: '🎬 分鏡導演',
    artstyle: '🎨 美術指導',
    screenwriter: '✍️ 編劇'
};

// ==================== API调用（带状态显示 + 自动重试）====================
async function callAgent(agentId, content, context = {}, retryCount = 0) {
    const MAX_RETRIES = 3;
    const agentName = AGENT_NAMES[agentId] || agentId;
    
    // 显示调用状态
    const retryText = retryCount > 0 ? ` (重試 ${retryCount}/${MAX_RETRIES})` : '';
    showAgentStatus(agentName, `準備中...${retryText}`);
    
    // 🔄 開始隊列狀態輪詢
    startQueuePolling();
    
    // 先檢查隊列狀態
    const queueStatus = await checkQueueStatus();
    if (queueStatus && queueStatus.activeRequests >= queueStatus.maxConcurrent) {
        const pos = queueStatus.queueLength + 1;
        showAgentStatus(agentName, `🔄 排隊中 (第${pos}位)，正在等待...`);
    }
    
    // 🧠 启动思考动画
    if (retryCount === 0) startThinkingAnimation(agentId);
    
    // 🔧 某些agent使用快速模型（章節規劃、訪談等需要快速響應的）
    const fastAgents = ['narrative', 'interview', 'concept'];
    const useReasoner = fastAgents.includes(agentId) ? false : (context.useReasoner !== false);
    
    // 🔧 添加超时控制（3分钟）
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 180000);
    
    try {
        const response = await fetch(`${API_BASE}/agent/${agentId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content, ...context, useReasoner }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            throw new Error(`API錯誤: ${response.status}`);
        }
        
        const data = await response.json();
        
        // 🧠 停止思考动画
        stopThinkingAnimation();
        
        // 显示token消耗
        if (data.tokens) {
            updateAgentStatus(agentName, `完成 ✅ (${data.tokens.input + data.tokens.output} tokens)`);
        }
        
        // 如果有思考过程（reasoner），显示出来
        if (data.reasoning || data.thinking) {
            showThinkingProcess(data.reasoning || data.thinking);
        }
        
        // 🔄 停止隊列輪詢
        stopQueuePolling();
        
        setTimeout(hideAgentStatus, 2000);
        return data.result;
        
    } catch (err) {
        clearTimeout(timeoutId);
        stopQueuePolling();  // 錯誤時也停止
        
        // 🔄 自动重试机制
        const isRetryable = err.name === 'AbortError' || 
                           err.message.includes('fetch') || 
                           err.message.includes('network') ||
                           err.message.includes('Failed') ||
                           err.message.includes('502') ||
                           err.message.includes('503') ||
                           err.message.includes('504');
        
        if (isRetryable && retryCount < MAX_RETRIES) {
            console.log(`🔄 重試 ${retryCount + 1}/${MAX_RETRIES}: ${agentId}`);
            showAgentStatus(agentName, `連接中斷，${3}秒後重試... (${retryCount + 1}/${MAX_RETRIES})`);
            await new Promise(r => setTimeout(r, 3000 * (retryCount + 1)));  // 指数退避
            return callAgent(agentId, content, context, retryCount + 1);
        }
        
        stopThinkingAnimation();
        hideAgentStatus();
        
        // 🔧 处理超时错误
        if (err.name === 'AbortError') {
            throw new Error('請求超時，AI正在忙碌中，請稍後重試');
        }
        throw err;
    }
}

// ==================== 流式调用Agent（解决超时）====================
async function callAgentStream(agentId, content, context = {}, onChunk = null) {
    const agentName = AGENT_NAMES[agentId] || agentId;
    const persona = AGENT_PERSONAS[agentId];
    const avatar = persona?.avatar || '🤖';
    
    showAgentStatus(agentName, '準備中...');
    
    // 创建实时预览区域
    let streamPreview = document.getElementById('streamPreview');
    if (!streamPreview) {
        streamPreview = document.createElement('div');
        streamPreview.id = 'streamPreview';
        streamPreview.className = 'message ai stream-preview';
        streamPreview.innerHTML = `
            <div class="role">${avatar} ${agentName}</div>
            <div class="content stream-content" id="streamContent">
                <span class="typing-cursor">▌</span>
            </div>
        `;
        document.getElementById('chatContainer').appendChild(streamPreview);
        scrollToBottom();
    }
    
    return new Promise((resolve, reject) => {
        let fullText = '';
        const streamContent = document.getElementById('streamContent');
        
        fetch(`${API_BASE}/agent-stream/${agentId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content, ...context })
        }).then(response => {
            if (!response.ok) {
                hideAgentStatus();
                if (streamPreview) streamPreview.remove();
                reject(new Error(`API錯誤: ${response.status}`));
                return;
            }
            
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            
            function read() {
                reader.read().then(({ done, value }) => {
                    if (done) {
                        hideAgentStatus();
                        // 移除预览区域
                        if (streamPreview) streamPreview.remove();
                        resolve(fullText);
                        return;
                    }
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n').filter(line => line.startsWith('data: '));
                    
                    for (const line of lines) {
                        try {
                            const data = JSON.parse(line.slice(6));
                            if (data.chunk) {
                                fullText += data.chunk;
                                if (onChunk) onChunk(data.chunk, fullText);
                                
                                // 实时更新预览内容（显示最后500字符）
                                if (streamContent) {
                                    const displayText = fullText.length > 500 
                                        ? '...' + fullText.slice(-500) 
                                        : fullText;
                                    streamContent.innerHTML = `<pre style="white-space:pre-wrap;font-family:inherit;margin:0;">${displayText}</pre><span class="typing-cursor">▌</span>`;
                                    scrollToBottom();
                                }
                                
                                updateAgentStatus(agentName, `生成中... ${fullText.length}字`);
                            }
                            if (data.done) {
                                fullText = data.fullText || fullText;
                            }
                            if (data.error) {
                                if (streamPreview) streamPreview.remove();
                                reject(new Error(data.error));
                                return;
                            }
                        } catch (e) {
                            // 忽略解析错误
                        }
                    }
                    
                    read();
                }).catch(err => {
                    hideAgentStatus();
                    if (streamPreview) streamPreview.remove();
                    reject(err);
                });
            }
            
            read();
        }).catch(err => {
            hideAgentStatus();
            if (streamPreview) streamPreview.remove();
            reject(err);
        });
    });
}

// ==================== 分镜生成（步骤6，分章）====================
async function runStoryboardGeneration(chapterNum) {
    if (!checkNovelExists()) return;
    
    const chapter = state.assets.chapters?.[chapterNum - 1];
    const script = state.assets.scripts?.[chapterNum];
    
    if (!chapter) {
        const totalChapters = state.assets.chapters?.length || 0;
        const buttons = totalChapters > 0 
            ? [
                { text: '🎬 生成第1集分鏡', action: () => runStoryboardGeneration(1) },
                { text: `🎬 生成第${totalChapters}集分鏡`, action: () => runStoryboardGeneration(totalChapters) }
            ]
            : [{ text: '📝 生成章節規劃', action: () => runChapterPlanning() }];
        
        addAIMessage(`⚠️ **第${chapterNum}集不存在**

${totalChapters > 0 
    ? `目前有 ${totalChapters} 集，請選擇要生成的分鏡：`
    : '請先生成章節規劃'}`, buttons);
        return;
    }
    
    if (!script) {
        addAIMessage(`⚠️ **第${chapterNum}集劇本尚未完成**

請先生成劇本`, [
            { text: `✍️ 生成第${chapterNum}集劇本`, action: () => runScriptWriting(chapterNum) }
        ]);
        return;
    }
    
    const targetShots = Math.ceil(chapter.duration * state.production.shotsPerMin);
    
    addTypingIndicator();
    
    // 详细步骤
    const steps = [
        { text: '📜 正在讀取劇本內容...', done: false, current: true },
        { text: '🎥 調用場景分析引擎', done: false },
        { text: '📐 啟動構圖設計模組', done: false },
        { text: '🎞️ 計算運鏡節奏曲線', done: false },
        { text: '✨ 生成Midjourney/SD提示詞', done: false },
        { text: `📊 輸出${targetShots}個專業分鏡`, done: false }
    ];
    showAgentStatus('🎬 分鏡導演', `「第${chapterNum}集，讓我來分鏡...」`, 'storyboard', steps);
    
    try {
        // 更新步骤进度
        steps[0].done = true; steps[0].current = false;
        steps[1].current = true;
        showAgentStatus('🎬 分鏡導演', '「分析場景切換節點...」', 'storyboard', steps);
        
        const context = {
            concept: state.assets.concept,
            characters: state.assets.characters,
            chapter: chapter,
            script: script.substring(0, 3000),
            costumes: state.assets.costumes,
            targetShots: targetShots,
            production: state.production,
            useReasoner: true,  // 🔧 使用DeepSeek Reasoner获得更高质量分镜
            outputFormat: `每個鏡頭必須包含以下字段:
- scene: 場景描述
- time: 時間(日/夜/黃昏等)
- lighting: 光線(high-key/low-key/自然光等)
- mood: 氛圍情緒
- characters: 出場角色
- action: 動作描述
- expression: 表情
- costume: 服裝
- dialogue: 台詞(如有)
- camera_position: 機位(eye-level/high-angle/low-angle)
- camera_movement: 運鏡(pan/tilt/dolly/crane/steadicam/static)
- shot_size: 景別(ECU/CU/MCU/MS/MLS/LS/ELS)
- narrative_function: 敘事功能
- image_prompt: AI圖片Prompt (英文, 包含 8K, --ar 16:9, cinematic)
- video_prompt: AI視頻Prompt (英文, 4 seconds, cinematic motion)`
        };
        
        const result = await callAgent('storyboard', script.substring(0, 2500), context);
        
        // 更新步骤为全部完成
        steps.forEach(s => { s.done = true; s.current = false; });
        showAgentStatus('🎬 分鏡導演', '「整理分鏡數據，馬上完成...」', 'storyboard', steps);
        
        const sbData = safeJSONParse(result, 'storyboard');
        const shots = sbData.shots || sbData.storyboard || [];
        
        // 存入项目资产
        state.assets.storyboards[chapterNum] = shots;
        
        removeTypingIndicator();
        hideAgentStatus();
        
        const totalChapters = state.assets.chapters.length;
        const isLastChapter = chapterNum >= totalChapters;
        
        addAIMessage(`🎬 **第${chapterNum}集分鏡完成！**

📊 **分鏡統計**:
• 目標鏡頭: ${targetShots} 個
• 實際生成: ${shots.length} 個
• 完成率: ${Math.round(shots.length / targetShots * 100)}%

${shots.slice(0, 3).map((s, i) => `**鏡頭${i+1}**: ${s.scene || s.description || ''}`).join('\n')}
${shots.length > 3 ? `\n... 共 ${shots.length} 個鏡頭` : ''}

───────────────────────
✅ 已存入項目資產 (${chapterNum}/${totalChapters})

${isLastChapter ? '🎉 全部分鏡完成！' : `繼續生成第${chapterNum + 1}集...`}`);
        
        saveProject();
        updateAssetsPanel();
        
        if (!isLastChapter) {
            // 自动继续下一集
            setTimeout(() => runStoryboardGeneration(chapterNum + 1), 1500);
        } else {
            // 全部完成
            addAIMessage(`🎉 **全部分鏡生成完成！**

📊 **總計**:
• ${totalChapters} 集
• ${Object.values(state.assets.storyboards).reduce((sum, s) => sum + (s?.length || 0), 0)} 個鏡頭

現在可以導出了：`, [
                { text: '📄 導出劇本(Word)', action: () => exportScripts() },
                { text: '📊 導出分鏡(Excel)', action: () => exportStoryboards() },
                { text: '🚀 輸入FizzStudio', action: () => importToFizzDragon() }
            ]);
        }
        
    } catch (err) {
        removeTypingIndicator();
        hideAgentStatus();
        showFriendlyError(err, `第${chapterNum}集分鏡`, () => runStoryboardGeneration(chapterNum));
    }
}

// ==================== 继续当前步骤 ====================
function continueCurrentStep() {
    const step = state.step || 0;
    
    switch(step) {
        case 0:
            addAIMessage(`請先導入小說開始項目`);
            break;
        case 1:
            runConceptStep();
            break;
        case 2:
            runCharacterAnalysis();
            break;
        case 3:
            runChapterPlanning();
            break;
        case 4:
            runProductionDesign();
            break;
        case 5:
            const nextChapter = (state.currentChapter || 0) + 1;
            if (nextChapter <= (state.assets.chapters?.length || 0)) {
                runScriptWriting(nextChapter);
            } else {
                addAIMessage(`✅ 劇本已全部完成！`, [
                    { text: '🎬 生成第1集分鏡', action: () => runStoryboardGeneration(1) },
                    { text: '📥 導出劇本', action: () => exportScripts() }
                ]);
            }
            break;
        case 6:
            addAIMessage(`🎬 分鏡階段。輸入「生成第X集分鏡」生成指定集的分鏡`);
            break;
        default:
            if (state.mode === 'import') {
                continueImportProject();
            } else {
                continueWriteProject();
            }
    }
}

// ==================== 项目资产查看 ====================
function showProjectAssets() {
    const a = state.assets || {};
    const p = state.production || {};
    
    // 构建完整资产页面
    let html = `📦 **項目資產**《${state.novelTitle || '未命名'}》

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

`;

    // 1. 高概念
    html += `**1️⃣ 高概念**\n`;
    if (a.concept) {
        html += `• 類型: ${a.concept.genre || '-'}\n`;
        html += `• 主題: ${a.concept.theme || '-'}\n`;
        html += `• 基調: ${a.concept.tone || '-'}\n`;
        html += `• Logline: ${a.concept.logline || '-'}\n`;
    } else {
        html += `❌ 未生成\n`;
    }
    
    // 2. 人物小传
    html += `\n**2️⃣ 人物小傳** (${a.characters?.length || 0}個)\n`;
    if (a.characters?.length > 0) {
        a.characters.slice(0, 5).forEach(c => {
            html += `• **${c.name}** (${c.role}): ${(c.bio || '').substring(0, 50)}...\n`;
        });
        if (a.characters.length > 5) html += `  ... 共${a.characters.length}個角色\n`;
    } else {
        html += `❌ 未生成\n`;
    }
    
    // 3. 章节集数
    html += `\n**3️⃣ 章節規劃** (${a.chapters?.length || 0}集)\n`;
    if (a.chapters?.length > 0) {
        html += `• 總集數: ${a.chapters.length} 集\n`;
        html += `• 每集時長: ${p.durationMin || 3} 分鐘\n`;
        html += `• 總時長: ${(a.chapters.length * (p.durationMin || 3))} 分鐘\n`;
        a.chapters.slice(0, 3).forEach(c => {
            html += `  - 第${c.number}集: ${c.title || '未命名'}\n`;
        });
        if (a.chapters.length > 3) html += `  ... 共${a.chapters.length}集\n`;
    } else {
        html += `❌ 未生成\n`;
    }
    
    // 4. 服化道
    html += `\n**4️⃣ 服化道**\n`;
    const costumeCount = a.costumes?.length || 0;
    const setCount = a.sets?.length || 0;
    const propCount = a.props?.length || 0;
    if (costumeCount + setCount + propCount > 0) {
        html += `• 服裝: ${costumeCount} 套\n`;
        html += `• 場景: ${setCount} 個\n`;
        html += `• 道具: ${propCount} 件\n`;
    } else {
        html += `❌ 未生成\n`;
    }
    
    // 5. 人物提示词
    html += `\n**5️⃣ 人物提示詞**\n`;
    const charsWithPrompt = (a.characters || []).filter(c => c.prompt);
    if (charsWithPrompt.length > 0) {
        charsWithPrompt.slice(0, 3).forEach(c => {
            html += `• ${c.name}: ${(c.prompt || '').substring(0, 40)}...\n`;
        });
    } else {
        html += `❌ 未生成\n`;
    }
    
    // 6. 剧本
    const scripts = a.scripts || {};
    const scriptKeys = Object.keys(scripts);
    html += `\n**6️⃣ 劇本** (${scriptKeys.length}/${a.chapters?.length || 0}集)\n`;
    if (scriptKeys.length > 0) {
        scriptKeys.slice(0, 3).forEach(k => {
            const script = scripts[k];
            html += `• 第${k}集: ${(script || '').length}字\n`;
        });
        if (scriptKeys.length > 3) html += `  ... 共${scriptKeys.length}集劇本\n`;
    } else {
        html += `❌ 未生成\n`;
    }
    
    // 7. 分镜
    const sbs = a.storyboards || {};
    const sbKeys = Object.keys(sbs);
    const totalShots = sbKeys.reduce((sum, k) => sum + (sbs[k]?.length || 0), 0);
    html += `\n**7️⃣ 分鏡表** (${sbKeys.length}/${a.chapters?.length || 0}集, ${totalShots}鏡頭)\n`;
    if (sbKeys.length > 0) {
        sbKeys.slice(0, 3).forEach(k => {
            const shots = sbs[k] || [];
            html += `• 第${k}集: ${shots.length}個鏡頭\n`;
        });
        if (sbKeys.length > 3) html += `  ... 共${sbKeys.length}集分鏡\n`;
    } else {
        html += `❌ 未生成\n`;
    }
    
    // 统计
    html += `\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 **統計**: ${totalShots}/${p.totalShots || 0} 鏡頭 (${p.totalShots ? Math.round(totalShots/p.totalShots*100) : 0}%)`;
    
    addAIMessage(html, [
        { text: '📥 導出全部', action: () => exportAll() },
        { text: '📥 導出劇本', action: () => exportScripts() },
        { text: '📥 導出分鏡', action: () => exportStoryboards() }
    ]);
}

// ==================== 移动端导出菜单 ====================
function showMobileExportMenu() {
    const a = state.assets || {};
    const hasScripts = Object.keys(a.scripts || {}).length > 0;
    const hasStoryboards = Object.keys(a.storyboards || {}).length > 0;
    const hasAny = a.concept || a.characters?.length || a.chapters?.length;
    
    if (!hasAny) {
        addAIMessage(`📤 **導出功能**

⚠️ 目前還沒有項目內容可以導出。

請先：
1. 導入小說或創建新項目
2. 完成至少一個步驟`, [
            { text: '📄 導入小說', action: () => document.getElementById('fileInput').click() },
            { text: '✨ 新建項目', action: () => startNewProject() }
        ]);
        return;
    }
    
    addAIMessage(`📤 **導出選項**

選擇要導出的內容：

${hasScripts ? '✅' : '⬜'} **劇本** - Word格式 (.doc)
${hasStoryboards ? '✅' : '⬜'} **分鏡表** - Excel格式 (.xls)
✅ **全部資產** - JSON格式`, [
        { text: '📝 導出劇本', action: () => exportScripts() },
        { text: '📊 導出分鏡', action: () => exportStoryboards() },
        { text: '📦 導出全部', action: () => exportAll() }
    ]);
}

// ==================== 导出函数 ====================
function exportScripts() {
    const scripts = state.assets.scripts;
    if (!scripts || Object.keys(scripts).length === 0) {
        addAIMessage(`❌ 還沒有劇本可以導出`);
        return;
    }
    
    let content = `# ${state.novelTitle} - 劇本\n\n`;
    // 生成Word格式（HTML-based .doc）
    let wordContent = `
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
body { font-family: "Microsoft YaHei", "SimSun", serif; line-height: 1.8; }
h1 { font-size: 24pt; text-align: center; margin-bottom: 30px; }
h2 { font-size: 16pt; color: #333; border-bottom: 1px solid #ccc; padding-bottom: 5px; margin-top: 30px; }
.scene { font-weight: bold; margin-top: 20px; }
.action { color: #555; margin: 10px 0; }
.dialogue { margin-left: 40px; }
.character { font-weight: bold; }
hr { border: none; border-top: 1px dashed #999; margin: 30px 0; }
</style>
</head>
<body>
<h1>${state.novelTitle || '劇本'}</h1>
`;
    
    for (const [num, script] of Object.entries(scripts)) {
        const chapter = state.assets.chapters[num - 1];
        wordContent += `<h2>第${num}集 ${chapter?.title || ''}</h2>\n`;
        wordContent += `<div style="white-space: pre-wrap;">${escapeHtml(script)}</div>\n`;
        wordContent += `<hr>\n`;
    }
    
    wordContent += `</body></html>`;
    
    // 导出为 .doc 格式（Word可以直接打开HTML格式的.doc）
    const blob = new Blob([wordContent], { type: 'application/msword' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${state.novelTitle}_劇本.doc`;
    a.click();
    URL.revokeObjectURL(url);
    
    addAIMessage(`✅ 劇本已導出為 Word！

📄 **${state.novelTitle}_劇本.doc**
• 共 ${Object.keys(scripts).length} 集
• 可用 Microsoft Word 打開編輯`);
}

function exportStoryboards() {
    const sbs = state.assets.storyboards;
    if (!sbs || Object.keys(sbs).length === 0) {
        addAIMessage(`❌ 還沒有分鏡可以導出`);
        return;
    }
    
    // 合并所有分镜
    let allShots = [];
    for (const [num, shots] of Object.entries(sbs)) {
        shots.forEach((shot, i) => {
            allShots.push({
                episode: num,
                shot_id: `E${String(num).padStart(3,'0')}_S${String(i+1).padStart(3,'0')}`,
                ...shot
            });
        });
    }
    
    // 导出CSV（专业格式）
    const headers = ['shot_id', '集數', '畫面描述', '場景', '時間', '光線', '氛圍', '角色', '動作', '表情', '服裝', '台詞', '機位', '運鏡', '景別', '敘事功能', 'Image_Prompt', 'Video_Prompt'];
    
    let csv = headers.join(',') + '\n';
    allShots.forEach(shot => {
        const row = [
            shot.shot_id,
            shot.episode,
            `"${(shot.description || shot.scene || '').replace(/"/g, '""')}"`,
            `"${(shot.scene || shot.location || '').replace(/"/g, '""')}"`,
            shot.time || '',
            shot.lighting || '',
            shot.mood || shot.atmosphere || '',
            `"${(shot.characters || shot.character || '').replace(/"/g, '""')}"`,
            `"${(shot.action || '').replace(/"/g, '""')}"`,
            shot.expression || '',
            shot.costume || '',
            `"${(shot.dialogue || '').replace(/"/g, '""')}"`,
            shot.camera_position || shot.camera || '',
            shot.camera_movement || shot.movement || '',
            shot.shot_size || shot.framing || '',
            shot.narrative_function || '',
            `"${(shot.image_prompt || shot.ai_prompt || '').replace(/"/g, '""')}"`,
            `"${(shot.video_prompt || '').replace(/"/g, '""')}"`
        ];
        csv += row.join(',') + '\n';
    });
    
    // 生成Excel格式（XML-based .xls）
    let excelContent = `<?xml version="1.0" encoding="UTF-8"?>
<?mso-application progid="Excel.Sheet"?>
<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"
 xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet">
<Styles>
<Style ss:ID="header">
<Font ss:Bold="1" ss:Color="#FFFFFF"/>
<Interior ss:Color="#E31B23" ss:Pattern="Solid"/>
<Alignment ss:Horizontal="Center"/>
</Style>
<Style ss:ID="cell">
<Alignment ss:Vertical="Top" ss:WrapText="1"/>
</Style>
</Styles>
<Worksheet ss:Name="分鏡表">
<Table>
<Row>`;
    
    // 表头
    headers.forEach(h => {
        excelContent += `<Cell ss:StyleID="header"><Data ss:Type="String">${h}</Data></Cell>`;
    });
    excelContent += `</Row>`;
    
    // 数据行
    allShots.forEach(shot => {
        excelContent += `<Row>`;
        const values = [
            shot.shot_id,
            shot.episode,
            shot.description || shot.scene || '',
            shot.scene || shot.location || '',
            shot.time || '',
            shot.lighting || '',
            shot.mood || shot.atmosphere || '',
            shot.characters || shot.character || '',
            shot.action || '',
            shot.expression || '',
            shot.costume || '',
            shot.dialogue || '',
            shot.camera_position || shot.camera || '',
            shot.camera_movement || shot.movement || '',
            shot.shot_size || shot.framing || '',
            shot.narrative_function || '',
            shot.image_prompt || shot.ai_prompt || '',
            shot.video_prompt || ''
        ];
        values.forEach(v => {
            excelContent += `<Cell ss:StyleID="cell"><Data ss:Type="String">${escapeHtml(String(v))}</Data></Cell>`;
        });
        excelContent += `</Row>`;
    });
    
    excelContent += `</Table></Worksheet></Workbook>`;
    
    // 导出为 .xls 格式
    const blob = new Blob([excelContent], { type: 'application/vnd.ms-excel' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${state.novelTitle}_分鏡表.xls`;
    a.click();
    URL.revokeObjectURL(url);
    
    addAIMessage(`✅ 分鏡表已導出為 Excel！

📊 **${state.novelTitle}_分鏡表.xls**
• 總鏡頭: ${allShots.length} 個
• 18列專業字段
• 可用 Microsoft Excel 打開編輯

包含：場景、光線、運鏡、Image_Prompt、Video_Prompt 等`);
}

function downloadFile(filename, content, type) {
    const blob = new Blob([content], { type });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
}

// 导出全部项目资产
function exportAll() {
    const a = state.assets || {};
    const p = state.production || {};
    const title = state.novelTitle || '未命名';
    
    const projectData = {
        title: title,
        exportTime: new Date().toISOString(),
        production: p,
        
        // 1. 高概念
        concept: a.concept,
        
        // 2. 人物小传
        characters: a.characters,
        
        // 3. 章节规划
        chapters: a.chapters,
        
        // 4. 服化道
        costumes: a.costumes,
        sets: a.sets,
        props: a.props,
        
        // 5. 剧本
        scripts: a.scripts,
        
        // 6. 分镜
        storyboards: a.storyboards,
        
        // 统计
        stats: {
            totalChapters: a.chapters?.length || 0,
            totalCharacters: a.characters?.length || 0,
            totalScripts: Object.keys(a.scripts || {}).length,
            totalStoryboards: Object.keys(a.storyboards || {}).length,
            totalShots: Object.values(a.storyboards || {}).reduce((sum, shots) => sum + (shots?.length || 0), 0)
        }
    };
    
    downloadFile(`${title}_項目資產.json`, JSON.stringify(projectData, null, 2), 'application/json');
    
    addAIMessage(`✅ **項目資產已導出！**

📄 文件: ${title}_項目資產.json

包含內容:
• 高概念
• ${projectData.stats.totalCharacters} 個角色小傳
• ${projectData.stats.totalChapters} 集章節規劃
• 服化道設計
• ${projectData.stats.totalScripts} 集劇本
• ${projectData.stats.totalStoryboards} 集分鏡 (${projectData.stats.totalShots} 鏡頭)`);
}

// ==================== 导入FizzDragon ====================
function importToFizzDragon() {
    const a = state.assets || {};
    const storyboards = a.storyboards || {};
    const chapters = a.chapters || [];
    
    // 获取有分镜的集数
    const availableEpisodes = Object.keys(storyboards)
        .map(k => parseInt(k))
        .filter(k => storyboards[k]?.length > 0)
        .sort((a, b) => a - b);
    
    if (availableEpisodes.length === 0) {
        addAIMessage(`⚠️ **還沒有分鏡可以導入**

請先生成分鏡：
1. 完成章節規劃
2. 生成各集劇本
3. 生成分鏡表

然後再導入 FizzStudio。`, [
            { text: '📝 生成章節', action: () => runChapterPlanning() }
        ]);
        return;
    }
    
    // 显示选择对话框
    showStoryboardSelector(availableEpisodes, chapters, storyboards);
}

function showStoryboardSelector(episodes, chapters, storyboards) {
    const title = state.novelTitle || '未命名';
    
    // 创建选择框HTML
    let checkboxesHtml = episodes.map(ep => {
        const chapter = chapters[ep - 1];
        const shotCount = storyboards[ep]?.length || 0;
        const chapterTitle = chapter?.title || `第${ep}集`;
        return `
            <label class="storyboard-checkbox">
                <input type="checkbox" value="${ep}" checked>
                <span class="checkbox-label">
                    <strong>第${ep}集</strong> ${chapterTitle}
                    <span class="shot-count">${shotCount}鏡</span>
                </span>
            </label>
        `;
    }).join('');
    
    const totalShots = episodes.reduce((sum, ep) => sum + (storyboards[ep]?.length || 0), 0);
    
    const container = document.getElementById('chatContainer');
    const msgDiv = document.createElement('div');
    msgDiv.className = 'message ai';
    msgDiv.innerHTML = `
        <div class="role">🚀 FizzStudio</div>
        <div class="content">
            <div class="storyboard-selector">
                <div class="selector-header">
                    <strong>選擇要導入的分鏡</strong>
                    <span class="total-info">共 ${episodes.length} 集 / ${totalShots} 鏡頭</span>
                </div>
                <div class="selector-actions-top">
                    <button onclick="toggleAllStoryboards(true)">全選</button>
                    <button onclick="toggleAllStoryboards(false)">取消全選</button>
                </div>
                <div class="selector-list">
                    ${checkboxesHtml}
                </div>
                <div class="selector-actions">
                    <button class="btn-cancel" onclick="this.closest('.message').remove()">取消</button>
                    <button class="btn-confirm" onclick="confirmFizzStudioImport()">🚀 確認導入</button>
                </div>
            </div>
        </div>
    `;
    container.appendChild(msgDiv);
    scrollToBottom();
}

function toggleAllStoryboards(checked) {
    document.querySelectorAll('.storyboard-checkbox input').forEach(cb => {
        cb.checked = checked;
    });
}

function confirmFizzStudioImport() {
    const selected = Array.from(document.querySelectorAll('.storyboard-checkbox input:checked'))
        .map(cb => parseInt(cb.value));
    
    if (selected.length === 0) {
        alert('請至少選擇一集分鏡');
        return;
    }
    
    const a = state.assets || {};
    const title = state.novelTitle || '未命名';
    
    // 收集选中的分镜数据
    const exportData = {
        title: title,
        exportTime: new Date().toISOString(),
        source: 'aigc_workbench',
        version: '3.0',
        episodes: selected.map(ep => ({
            episode: ep,
            chapter: a.chapters?.[ep - 1],
            script: a.scripts?.[ep],
            storyboard: a.storyboards?.[ep]
        })),
        characters: a.characters,
        production: state.production
    };
    
    const totalShots = selected.reduce((sum, ep) => sum + (a.storyboards?.[ep]?.length || 0), 0);
    
    // 移除选择框
    document.querySelector('.storyboard-selector')?.closest('.message')?.remove();
    
    // 显示导入选项
    addAIMessage(`✅ **已選擇 ${selected.length} 集分鏡**

📊 共 ${totalShots} 個鏡頭

選擇導入方式：`, [
        { text: '📋 複製數據', action: () => copyToClipboard(JSON.stringify(exportData, null, 2)) },
        { text: '📥 下載JSON', action: () => downloadFile(`${title}_fizzstudio.json`, JSON.stringify(exportData, null, 2), 'application/json') },
        { text: '🌐 打開FizzStudio', action: () => window.open('https://fizzdragon.com/studio', '_blank') }
    ]);
}

function copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(() => {
        addAIMessage('✅ 已複製到剪貼板！\n\n前往 FizzDragon 平台粘貼導入即可。');
    }).catch(err => {
        addAIMessage('❌ 複製失敗，請手動下載JSON文件。');
    });
}

// ==================== 智能体状态显示 ====================
function showAgentStatus(agentName, status, agentId = null, steps = null) {
    // 🔧 先移除typing消息，避免重复
    const typingMsg = document.getElementById('typingIndicator');
    if (typingMsg) typingMsg.remove();
    
    // 获取Agent人格化短语
    const persona = agentId ? AGENT_PERSONAS[agentId] : null;
    const personalizedName = persona?.name || agentName;
    const avatar = persona?.avatar || '🤖';
    
    // 🔧 根据当前步骤获取对应的persona短语
    let phrase = status;
    if (persona?.phrases) {
        // 找到当前进行中的步骤索引
        const currentStepIndex = steps?.findIndex(s => s.current);
        if (currentStepIndex !== undefined && currentStepIndex >= 0) {
            // 尝试获取step1, step2, step3...对应的短语
            const stepKey = `step${currentStepIndex + 1}`;
            phrase = persona.phrases[stepKey] || persona.phrases.working || status;
        } else {
            phrase = persona.phrases.working || status;
        }
    }
    
    // 构建详细步骤HTML（更紧凑）
    let stepsHtml = '';
    if (steps && steps.length > 0) {
        stepsHtml = `<div class="agent-steps">` + 
            steps.map((step, i) => `
                <div class="step-item ${step.done ? 'done' : step.current ? 'current' : ''}">
                    <span class="step-icon">${step.done ? '✅' : step.current ? '⏳' : '○'}</span>
                    <span class="step-text">${step.text}</span>
                </div>
            `).join('') + 
        `</div>`;
    }
    
    // 在对话框中显示进度
    let progressMsg = document.getElementById('agentProgressMsg');
    if (!progressMsg) {
        progressMsg = document.createElement('div');
        progressMsg.id = 'agentProgressMsg';
        progressMsg.className = 'message ai agent-progress';
        document.getElementById('chatContainer').appendChild(progressMsg);
    }
    // 🔧 更紧凑的布局
    progressMsg.innerHTML = `
        <div class="role"><span style="font-size:14px;">${avatar}</span> ${personalizedName}</div>
        <div class="content" style="padding:2px 0;">
            <div style="display:flex;align-items:center;gap:6px;">
                <div class="agent-spinner-inline"></div>
                <span style="font-style:italic;color:#ccc;font-size:13px;">${phrase}</span>
            </div>
            ${stepsHtml}
        </div>
    `;
    scrollToBottom();
    
    // 添加spinner样式
    if (!document.getElementById('spinnerStyle')) {
        const style = document.createElement('style');
        style.id = 'spinnerStyle';
        style.textContent = `
            .agent-spinner, .agent-spinner-inline {
                width: 16px;
                height: 16px;
                border: 2px solid #E31B2333;
                border-top-color: #E31B23;
                border-radius: 50%;
                animation: spin 1s linear infinite;
                flex-shrink: 0;
            }
            @keyframes spin {
                to { transform: rotate(360deg); }
            }
            .agent-progress {
                border-left: 2px solid #E31B23 !important;
                background: rgba(227, 27, 35, 0.05) !important;
                padding: 4px 10px !important;
            }
            .agent-progress .role {
                margin-bottom: 2px !important;
                font-size: 12px !important;
            }
            /* 隊列狀態條 */
            .queue-status-bar {
                position: fixed;
                top: 60px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #ff6b35, #f72c25);
                color: white;
                padding: 8px 20px;
                border-radius: 20px;
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 13px;
                font-weight: 500;
                box-shadow: 0 4px 15px rgba(247, 44, 37, 0.4);
                z-index: 1000;
                animation: slideDown 0.3s ease;
            }
            @keyframes slideDown {
                from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
                to { transform: translateX(-50%) translateY(0); opacity: 1; }
            }
            .queue-icon {
                animation: spin 1s linear infinite;
            }
            .queue-waiting {
                color: #ff9800;
                font-style: italic;
            }
            .agent-progress .content {
                padding: 0 !important;
            }
            .agent-steps {
                margin-top: 8px;
                padding: 6px 10px;
                background: rgba(0,0,0,0.2);
                border-radius: 6px;
            }
            .step-item {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 4px 0;
                font-size: 12px;
                color: #666;
            }
            .step-item.done {
                color: #4CAF50;
            }
            .step-item.current {
                color: #E31B23;
                font-weight: 500;
            }
            .step-icon {
                width: 16px;
                text-align: center;
            }
            /* 思考过程样式 - DeepSeek风格 */
            .thinking-message {
                background: rgba(227, 27, 35, 0.03) !important;
                border-left: 2px solid #E31B23 !important;
            }
            .thinking-header {
                display: flex;
                align-items: center;
                gap: 8px;
                cursor: pointer;
                padding: 4px 0;
                user-select: none;
            }
            .thinking-header:hover {
                opacity: 0.8;
            }
            .thinking-icon {
                font-size: 16px;
            }
            .thinking-icon.spinning {
                animation: pulse 1.5s ease-in-out infinite;
            }
            @keyframes pulse {
                0%, 100% { opacity: 1; transform: scale(1); }
                50% { opacity: 0.6; transform: scale(0.95); }
            }
            .thinking-title {
                color: #E31B23;
                font-weight: 500;
                font-size: 13px;
            }
            .thinking-toggle {
                margin-left: auto;
                color: #666;
                transition: transform 0.2s;
            }
            .thinking-message.expanded .thinking-toggle {
                transform: rotate(180deg);
            }
            .thinking-content {
                margin-top: 8px;
                font-size: 12px;
                color: #888;
                line-height: 1.6;
            }
            .thinking-preview {
                white-space: pre-wrap;
            }
            .thinking-full {
                display: none;
                white-space: pre-wrap;
                max-height: 300px;
                overflow-y: auto;
            }
            .thinking-message.expanded .thinking-preview {
                display: none;
            }
            .thinking-message.expanded .thinking-full {
                display: block;
            }
            /* 动态思考动画 - DeepSeek风格 */
            .thinking-animation {
                background: transparent !important;
                border: none !important;
                padding: 8px 0 !important;
            }
            .thinking-header-ds {
                display: flex;
                align-items: center;
                gap: 6px;
                cursor: pointer;
                padding: 4px 0;
                user-select: none;
            }
            .thinking-title-ds {
                color: #888;
                font-size: 14px;
            }
            .thinking-title-ds::after {
                content: '...';
                animation: dots 1.5s steps(4) infinite;
            }
            @keyframes dots {
                0% { content: ''; }
                25% { content: '.'; }
                50% { content: '..'; }
                75% { content: '...'; }
            }
            .thinking-arrow-ds {
                color: #666;
                font-size: 10px;
                transition: transform 0.2s;
            }
            .thinking-steps-ds.collapsed {
                display: none;
            }
            .thinking-steps-ds.collapsed + .thinking-header-ds .thinking-arrow-ds {
                transform: rotate(-90deg);
            }
            .thinking-steps-ds {
                margin-top: 8px;
                padding-left: 4px;
            }
            .think-step-ds {
                padding: 6px 0;
                font-size: 14px;
                color: #ccc;
                line-height: 1.6;
                opacity: 0;
                animation: fadeIn 0.3s ease forwards;
            }
            .think-step-ds.current {
                color: #fff;
            }
            @keyframes fadeIn {
                to { opacity: 1; }
            }
        `;
        document.head.appendChild(style);
    }
}

// ========== 隊列狀態監控 ==========
let queuePollInterval = null;

async function checkQueueStatus() {
    try {
        const response = await fetch(`${API_BASE}/queue`);
        if (response.ok) {
            const queue = await response.json();
            updateQueueDisplay(queue);
            return queue;
        }
    } catch (e) {
        console.log('Queue check failed:', e);
    }
    return null;
}

function updateQueueDisplay(queue) {
    let queueBar = document.getElementById('queueStatusBar');
    
    // 如果沒有等待隊列，隱藏狀態條
    if (queue.queueLength === 0) {
        if (queueBar) queueBar.style.display = 'none';
        return;
    }
    
    // 創建或更新狀態條
    if (!queueBar) {
        queueBar = document.createElement('div');
        queueBar.id = 'queueStatusBar';
        queueBar.className = 'queue-status-bar';
        document.querySelector('.chat-header')?.appendChild(queueBar);
    }
    
    queueBar.style.display = 'flex';
    queueBar.innerHTML = `
        <span class="queue-icon">🔄</span>
        <span class="queue-text">
            排隊中 ${queue.queueLength} 個請求 | 
            正在處理 ${queue.activeRequests}/${queue.maxConcurrent}
        </span>
    `;
}

function startQueuePolling() {
    if (queuePollInterval) return;
    queuePollInterval = setInterval(checkQueueStatus, 2000);
}

function stopQueuePolling() {
    if (queuePollInterval) {
        clearInterval(queuePollInterval);
        queuePollInterval = null;
    }
    const queueBar = document.getElementById('queueStatusBar');
    if (queueBar) queueBar.style.display = 'none';
}

function updateAgentStatus(agentName, status) {
    const statusBar = document.getElementById('agentStatusBar');
    if (statusBar) {
        statusBar.innerHTML = `<span>✅ <strong>${agentName}</strong> ${status}</span>`;
    }
}

function hideAgentStatus() {
    // 移除旧的顶部状态栏（如果存在）
    const statusBar = document.getElementById('agentStatusBar');
    if (statusBar) statusBar.remove();
    
    // 移除对话框中的进度消息
    const progressMsg = document.getElementById('agentProgressMsg');
    if (progressMsg) progressMsg.remove();
}

// 思考过程展示 - DeepSeek风格可折叠面板
function showThinkingProcess(thinking) {
    if (!thinking || thinking.length < 10) return;
    
    const container = document.getElementById('chatContainer');
    const thinkingDiv = document.createElement('div');
    thinkingDiv.className = 'message ai thinking-message';
    
    // 默认折叠，点击展开
    const isLong = thinking.length > 200;
    const previewText = isLong ? thinking.substring(0, 200) + '...' : thinking;
    
    thinkingDiv.innerHTML = `
        <div class="thinking-header" onclick="this.parentElement.classList.toggle('expanded')">
            <span class="thinking-icon">💭</span>
            <span class="thinking-title">思考過程</span>
            <span class="thinking-toggle">${isLong ? '▼' : ''}</span>
        </div>
        <div class="thinking-content">
            <div class="thinking-preview">${escapeHtml(previewText)}</div>
            ${isLong ? `<div class="thinking-full">${escapeHtml(thinking)}</div>` : ''}
        </div>
    `;
    container.appendChild(thinkingDiv);
    scrollToBottom();
}

// 动态思考动画（调用API时显示）- FizzDragon品牌化
let thinkingAnimationInterval = null;
const THINKING_STEPS = {
    concept: [
        '🐉 FizzDragon 正在調動AI模型...',
        '📚 載入100+本大師著作（McKee《故事》、Campbell《千面英雄》）...',
        '🎭 運用三幕結構理論分析故事...',
        '💡 提取核心戲劇衝突與價值轉換...',
        '🎬 確定類型、主題與情感基調...',
        '✨ 生成專業級高概念Logline...'
    ],
    character: [
        '🐉 FizzDragon 正在調動AI模型...',
        '📖 載入Bancroft《角色塑造》+ Truby《角色解剖》...',
        '🧠 深度分析角色心理動機（Want vs Need）...',
        '💔 構建角色內心衝突與心理創傷...',
        '👤 設計視覺符號與外貌特徵...',
        '🎨 生成AI繪圖Prompt...',
        '✨ 完善人物小傳...'
    ],
    narrative: [
        '🐉 FizzDragon 正在調動AI模型...',
        '📚 載入Blake Snyder《Save the Cat》15節拍...',
        '🎯 分析故事節拍與情感弧線...',
        '📝 規劃章節結構（起承轉合）...',
        '🔗 設計每集結尾懸念鉤子...',
        '✨ 生成專業章節大綱...'
    ],
    storyboard: [
        '🐉 FizzDragon 正在調動AI模型...',
        '🎥 載入Katz《分鏡導演學》+ 電影運鏡技法...',
        '📐 計算鏡頭密度（10鏡/分鐘標準）...',
        '🎬 分析場景轉換與視覺節奏...',
        '💡 設計構圖、燈光、運鏡...',
        '🖼️ 生成AI繪圖Prompt（8K --ar 16:9）...',
        '✨ 輸出專業分鏡表...'
    ],
    screenwriter: [
        '🐉 FizzDragon 正在調動AI模型...',
        '📚 載入專業編劇格式標準...',
        '🎭 分析場景情感節奏...',
        '💬 撰寫角色對白...',
        '✨ 生成完整劇本...'
    ],
    default: [
        '🐉 FizzDragon 正在調動AI模型...',
        '📚 載入100+本專業知識庫...',
        '🧠 深度分析輸入內容...',
        '💡 應用大師方法論...',
        '✨ 生成專業結果...'
    ]
};

function startThinkingAnimation(agentId) {
    const steps = THINKING_STEPS[agentId] || THINKING_STEPS.default;
    let stepIndex = 0;
    
    // 创建思考动画元素
    const container = document.getElementById('chatContainer');
    let thinkingAnim = document.getElementById('thinkingAnimation');
    if (!thinkingAnim) {
        thinkingAnim = document.createElement('div');
        thinkingAnim.id = 'thinkingAnimation';
        thinkingAnim.className = 'message ai thinking-animation';
        container.appendChild(thinkingAnim);
    }
    
    // 更新动画内容 - DeepSeek风格
    function updateAnimation() {
        const currentStep = steps[stepIndex % steps.length];
        thinkingAnim.innerHTML = `
            <div class="thinking-header-ds" onclick="this.nextElementSibling.classList.toggle('collapsed')">
                <span class="thinking-title-ds">正在思考</span>
                <span class="thinking-arrow-ds">▼</span>
            </div>
            <div class="thinking-steps-ds">
                ${steps.slice(0, stepIndex + 1).map((s, i) => 
                    `<div class="think-step-ds ${i === stepIndex ? 'current' : ''}">${s.replace(/^[🐉📚🎭💡🎬✨🧠📖💔👤🎥📐🔗📝🎯🖼️💬]/u, '•')}</div>`
                ).join('')}
            </div>
        `;
        stepIndex++;
        scrollToBottom();
    }
    
    updateAnimation();
    thinkingAnimationInterval = setInterval(updateAnimation, 1500);
}

function stopThinkingAnimation() {
    if (thinkingAnimationInterval) {
        clearInterval(thinkingAnimationInterval);
        thinkingAnimationInterval = null;
    }
    const thinkingAnim = document.getElementById('thinkingAnimation');
    if (thinkingAnim) thinkingAnim.remove();
}

// ==================== 用户输入 ====================
function sendMessage() {
    const input = document.getElementById('userInput');
    const text = input.value.trim();
    if (!text) return;
    
    addUserMessage(text);
    input.value = '';
    
    // 处理用户回复
    handleUserInput(text);
}

function handleUserInput(text) {
    console.log('🔔 handleUserInput:', { 
        mode: state.mode, 
        step: state.step, 
        writeQ: writeState.currentQuestion,
        novelTitle: state.novelTitle,
        textLen: text.length,
        appMode: appMode,
        adStep: adState.step,
        pendingRevision: !!window.pendingRevision
    });
    
    // ==================== Auto-Pilot 配置輸入 ====================
    if (state.waitingForEpisodeInput) {
        const episodes = parseInt(text);
        if (episodes >= 1 && episodes <= 100) {
            state.waitingForEpisodeInput = false;
            askEpisodeDuration(episodes);
        } else {
            addAIMessage('❌ 請輸入1-100之間的數字');
        }
        return;
    }
    
    if (state.waitingForDurationInput) {
        const duration = parseInt(text);
        if (duration >= 1 && duration <= 30) {
            state.waitingForDurationInput = false;
            startAutoPilotWithConfig(state.production.episodes, duration);
        } else {
            addAIMessage('❌ 請輸入1-30之間的數字');
        }
        return;
    }
    
    // ==================== 修改意見處理 ====================
    if (window.pendingRevision) {
        handleRevisionFeedback(text);
        return;
    }
    
    // ==================== 角色編輯處理 ====================
    if (window.pendingCharacterEdit) {
        window.pendingCharacterEdit.onEdit(text);
        return;
    }
    
    // ==================== AI寫故事處理 ====================
    if (window.pendingAIStory) {
        console.log('🎯 pendingAIStory detected, calling generateAIStory');
        window.pendingAIStory = false;
        generateAIStory(text);
        return;
    }
    
    // ==================== 广告模式处理 ====================
    if (appMode === 'ad' && adState.step > 0) {
        handleAdInput(text);
        return;
    }
    
    // ==================== 命令处理 ====================
    const lowerText = text.toLowerCase().trim();
    
    // ==================== 智能Agent调用 ====================
    // 重新生成角色
    if (lowerText.includes('重新生成角色') || lowerText.includes('重新設計角色') || lowerText.includes('再生成角色')) {
        addAIMessage('🔄 好的，正在重新生成角色分析...');
        runCharacterAnalysis();
        return;
    }
    
    // 重新生成高概念
    if (lowerText.includes('重新生成概念') || lowerText.includes('重新分析') || lowerText.includes('重做高概念')) {
        addAIMessage('🔄 好的，正在重新生成高概念...');
        runConceptAnalysis();
        return;
    }
    
    // 重新规划章节
    if (lowerText.includes('重新規劃章節') || lowerText.includes('重新规划章节') || lowerText.includes('重做章節')) {
        addAIMessage('🔄 好的，正在重新規劃章節...');
        runChapterPlanning();
        return;
    }
    
    // 重新生成服化道
    if (lowerText.includes('重新生成服化道') || lowerText.includes('重做服化道') || lowerText.includes('重新設計服裝')) {
        addAIMessage('🔄 好的，正在重新生成服化道設計...');
        runProductionDesign();
        return;
    }
    
    // 生成剧本（指定集数）
    const scriptMatch = text.match(/(?:生成|寫|写)[第]?(\d+)[集章]?(?:的)?[剧劇]本/);
    if (scriptMatch) {
        const epNum = parseInt(scriptMatch[1]);
        runScriptWriting(epNum);
        return;
    }
    
    // 通用"生成XX"命令
    if (lowerText.includes('生成角色') || lowerText.includes('設計角色')) {
        runCharacterAnalysis();
        return;
    }
    if (lowerText.includes('生成概念') || lowerText.includes('分析概念')) {
        runConceptAnalysis();
        return;
    }
    if (lowerText.includes('生成章節') || lowerText.includes('規劃章節') || lowerText.includes('生成章节')) {
        runChapterPlanning();
        return;
    }
    if (lowerText.includes('生成服化道') || lowerText.includes('設計服化道')) {
        runProductionDesign();
        return;
    }
    if (lowerText.includes('生成劇本') || lowerText.includes('生成剧本') || lowerText.includes('寫劇本')) {
        // 如果没有指定集数，生成第一集
        runScriptWriting(1);
        return;
    }
    
    // 生成分镜命令
    const storyboardMatch = text.match(/生成[第]?(\d+)[集章]?分[镜鏡]/);
    if (storyboardMatch) {
        const epNum = parseInt(storyboardMatch[1]);
        runStoryboardGeneration(epNum);
        return;
    }
    
    // 导出命令
    if (lowerText.includes('导出') || lowerText.includes('導出')) {
        if (lowerText.includes('剧本') || lowerText.includes('劇本')) {
            exportScripts();
        } else if (lowerText.includes('分镜') || lowerText.includes('分鏡')) {
            exportStoryboards();
        } else {
            exportAll();
        }
        return;
    }
    
    // 查看项目资产
    if (lowerText.includes('项目资产') || lowerText.includes('項目資產') || lowerText === '资产' || lowerText === '資產') {
        showProjectAssets();
        return;
    }
    
    // 继续流程
    if (lowerText === '继续' || lowerText === '繼續') {
        continueCurrentStep();
        return;
    }
    
    // 帮助命令
    if (lowerText === '帮助' || lowerText === '幫助' || lowerText === 'help' || lowerText === '?') {
        addAIMessage(`📖 **可用命令**

**生成內容：**
• 生成概念 / 重新生成概念
• 生成角色 / 重新生成角色
• 生成章節 / 重新規劃章節
• 生成服化道 / 重新生成服化道
• 生成第X集劇本
• 生成第X集分鏡

**導出：**
• 導出劇本
• 導出分鏡
• 導出全部

**其他：**
• 項目資產 - 查看當前資產
• 繼續 - 繼續下一步
• 幫助 - 顯示此訊息`);
        return;
    }
    
    // 写作模式 - 处理初始想法输入（等待故事灵感）
    // 🔧 修复：放宽条件，-1 或 null 或 undefined 都算初始状态
    if (state.mode === 'write' && (writeState.currentQuestion === -1 || writeState.currentQuestion === null || writeState.currentQuestion === undefined) && !writeState.idea) {
        console.log('写作模式: 接收故事灵感, currentQuestion:', writeState.currentQuestion);
        writeState.idea = { premise: text };
        writeState.currentQuestion = -1;  // 确保设置为 -1
        startWriteInterview();
        return;
    }
    
    // 写作模式 - 访谈问题
    if (state.mode === 'write' && typeof writeState.currentQuestion === 'number' && writeState.currentQuestion >= 0 && writeState.currentQuestion < WRITE_QUESTIONS.length) {
        console.log('写作模式: 回答访谈问题', writeState.currentQuestion);
        if (text.toLowerCase() === '跳過' || text.toLowerCase() === '跳过') {
            writeState.interview[writeState.currentQuestion] = '(跳過)';
        } else {
            writeState.interview[writeState.currentQuestion] = text;
        }
        writeState.currentQuestion++;
        setTimeout(() => askWriteQuestion(), 500);
        return;
    }
    
    // 导入模式 - 制作设置问答
    if (state.step === 1.5 && productionStep < 3) {
        handleProductionInput(text);
        return;
    }
    
    // 导入模式 - 访谈问题（纯对话式）
    if (state.step === 2 && state.currentQuestion < (state.interviewQuestions?.length || 0)) {
        // 支持跳过命令
        if (text.toLowerCase() === '跳過' || text.toLowerCase() === '跳过') {
            state.interview[state.currentQuestion] = '(跳過)';
        } else {
            state.interview[state.currentQuestion] = text;
        }
        state.currentQuestion++;
        setTimeout(() => askNextQuestion(), 500);
        return;
    }
    
    // 导入模式 - 纯对话式状态提示（带可操作按钮）
    if (state.mode === 'import' && state.step >= 1) {
        const stepNames = ['等待導入', '概念分析', '訪談中', '章節規劃', '服化道', '劇本', '分鏡'];
        const a = state.assets || {};
        const scriptCount = Object.keys(a.scripts || {}).length;
        const sbCount = Object.keys(a.storyboards || {}).length;
        const chapterCount = a.chapters?.length || 0;
        
        addAIMessage(`📊 **項目狀態**: 《${state.novelTitle || '未命名'}》

• 高概念: ${a.concept ? '✅' : '⏳'}
• 角色: ${a.characters?.length || 0} 個
• 章節: ${chapterCount} 集
• 劇本: ${scriptCount}/${chapterCount} 集
• 分鏡: ${sbCount}/${chapterCount} 集

輸入「幫助」查看可用命令`, [
            { text: '📝 繼續流程', action: () => continueCurrentStep() },
            { text: '📥 導出進度', action: () => exportAll() }
        ]);
        return;
    }
    
    // 初始状态 - 用户直接发送文字
    if (state.step === 0 && !state.mode) {
        // 检测是否像是故事内容（超过100字）
        if (text.length > 100) {
            addAIMessage(`📖 收到你的內容（${text.length}字）！

這看起來像是故事內容，請選擇處理方式：`, [
                { text: '📝 作為創作靈感', action: () => {
                    state.mode = 'write';
                    writeState.currentQuestion = -1;
                    writeState.idea = { premise: text };
                    startWriteInterview();
                }},
                { text: '📄 直接分析生成分鏡', action: async () => {
                    state.novel = text;
                    state.novelTitle = '直接輸入';
                    state.step = 1;
                    state.mode = 'import';
                    await runConceptStep();
                }}
            ]);
        } else {
            addAIMessage(`👋 請選擇開始方式：`, [
                { text: '📄 導入小說文件', action: () => document.getElementById('fileInput').click() },
                { text: '✍️ AI幫我寫小說', action: () => startWriteMode() },
                { text: '📝 直接輸入故事', action: () => addAIMessage('請直接輸入或粘貼你的故事內容（100字以上），我會自動識別並處理。') }
            ]);
        }
        return;
    }
    
    // 其他情况 - 显示帮助选项
    addAIMessage(`📊 **當前狀態**
• 模式: ${state.mode === 'write' ? '創作' : state.mode === 'import' ? '導入' : '未開始'}
• 步驟: ${state.step}/5

需要什麼幫助？`, [
        { text: '▶️ 繼續', action: () => state.mode === 'write' ? continueWriteProject() : continueImportProject() },
        { text: '🆘 診斷問題', action: () => callHelpAgent() },
        { text: '🏠 重新開始', action: () => { resetWorkflowFromStep(0); document.getElementById('chatContainer').innerHTML = ''; showStartOptions(); }}
    ]);
}

// 回车发送
document.getElementById('userInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
    }
});

// 自动调整高度
document.getElementById('userInput').addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = Math.min(this.scrollHeight, 150) + 'px';
});

// ==================== 🖼️ 图像生成 (Replicate) ====================
async function generateImage(prompt, type = 'character') {
    addTypingIndicator();
    showAgentStatus('🖼️ 圖像生成', '正在生成...');
    
    try {
        const response = await fetch(`${API_BASE.replace('/api', '')}/api/generate-image`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                prompt,
                model: 'flux_schnell',  // 快速模式
                aspectRatio: type === 'character' ? '3:4' : '16:9'
            })
        });
        
        const result = await response.json();
        
        removeTypingIndicator();
        hideAgentStatus();
        
        if (result.error) {
            throw new Error(result.error);
        }
        
        // 显示生成的图片
        addAIMessage(`🖼️ **${type === 'character' ? '角色圖' : '場景圖'}生成完成！**

<img src="${result.url}" style="max-width:100%;border-radius:12px;margin:10px 0;">

**Prompt**: ${prompt.substring(0, 100)}...`, [
            { text: '📥 下載圖片', action: () => window.open(result.url, '_blank') },
            { text: '🔄 重新生成', action: () => generateImage(prompt, type) }
        ]);
        
        return result.url;
        
    } catch (err) {
        removeTypingIndicator();
        hideAgentStatus();
        addAIMessage(`❌ 圖片生成失敗: ${err.message}

可能原因：
• 未配置 REPLICATE_API_KEY
• API 額度用完
• 網絡問題`, [
            { text: '🔄 重試', action: () => generateImage(prompt, type) }
        ]);
        return null;
    }
}

// 批量生成角色图
async function generateCharacterImages() {
    const chars = state.characters?.characters || [];
    if (chars.length === 0) {
        addAIMessage('❌ 沒有角色數據，請先生成角色設計');
        return;
    }
    
    addAIMessage(`🖼️ **開始生成角色圖** (共 ${chars.length} 個)

這可能需要幾分鐘...`);
    
    for (const char of chars.slice(0, 5)) {  // 最多生成5个
        const prompt = char.ai_prompt || `${char.name}, ${char.appearance || ''}, portrait, cinematic lighting, detailed face`;
        await generateImage(prompt, 'character');
        await new Promise(r => setTimeout(r, 2000));  // 间隔2秒
    }
    
    addAIMessage(`✅ **角色圖生成完成！**`);
}

// 检查生图服务状态
async function checkImageGenStatus() {
    try {
        const response = await fetch(`${API_BASE.replace('/api', '')}/api/generate-image/status`);
        const status = await response.json();
        return status.enabled;
    } catch {
        return false;
    }
}

// ==================== 导出 ====================
function exportAll() {
    const data = {
        title: state.novelTitle,
        concept: state.concept,
        interview: state.interview,
        chapters: state.chapters,
        characters: state.characters,
        storyboard: state.storyboard,
        exportTime: new Date().toISOString()
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${state.novelTitle}_AI番劇.json`;
    a.click();
    
    addAIMessage(`✅ 已導出 **${state.novelTitle}_AI番劇.json**`);
}

// ==================== 启动 ====================
// 检查登录状态
const authToken = localStorage.getItem('fizzdragon_token');
const savedUser = JSON.parse(localStorage.getItem('fizzdragon_user') || 'null');
if (savedUser) {
    currentUser = { ...currentUser, ...savedUser };
}

if (!authToken) {
    // 未登录，内测模式直接初始化
    init();
} else {
    // 验证token
    fetch('/api/auth/verify', {
        headers: { 'Authorization': `Bearer ${authToken}` }
    }).then(res => {
        if (!res.ok) {
            localStorage.removeItem('fizzdragon_token');
            localStorage.removeItem('fizzdragon_user');
            init(); // 内测模式：验证失败也初始化
        } else {
            // 登录有效，初始化
            init();
        }
    }).catch(() => {
        // 网络错误，仍然尝试初始化（离线模式）
        init();
    });
}
    </script>
</body>
</html>
